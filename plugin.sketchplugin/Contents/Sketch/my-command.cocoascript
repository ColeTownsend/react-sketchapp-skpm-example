var console = {
  log: log,
  warn: log,
  error: log,
  dump: function (obj) {
    log('#####################################################################')
    log('## Dumping object ' + obj)
    if (obj.className) {
      log('## obj class is: ' + obj.className())
    }
    log('#####################################################################')

    if (obj.class && obj.class().mocha) {
      log('obj.properties:')
      log(obj.class().mocha().properties())
      log('obj.propertiesWithAncestors:')
      log(obj.class().mocha().propertiesWithAncestors())

      log('obj.classMethods:')
      log(obj.class().mocha().classMethods())
      log('obj.classMethodsWithAncestors:')
      log(obj.class().mocha().classMethodsWithAncestors())

      log('obj.instanceMethods:')
      log(obj.class().mocha().instanceMethods())
      log('obj.instanceMethodsWithAncestors:')
      log(obj.class().mocha().instanceMethodsWithAncestors())

      log('obj.protocols:')
      log(obj.class().mocha().protocols())
      log('obj.protocolsWithAncestors:')
      log(obj.class().mocha().protocolsWithAncestors())
    }

    if (obj.treeAsDictionary) {
      log('obj.treeAsDictionary():')
      log(obj.treeAsDictionary())
    }
  }
};


/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}
	return Object(val);
}
function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}
		var test1 = new String('abc');
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
			return false;
		}
		return true;
	} catch (err) {
		return false;
	}
}
var index = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;
	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);
		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}
		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}
	return to;
};

function reactProdInvariant(code) {
  var argCount = arguments.length - 1;
  var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;
  for (var argIdx = 0; argIdx < argCount; argIdx++) {
    message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
  }
  message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';
  var error = new Error(message);
  error.name = 'Invariant Violation';
  error.framesToPop = 1;
  throw error;
}
var reactProdInvariant_1 = reactProdInvariant;

var validateFormat = function validateFormat(format) {};
if (undefined !== 'production') {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}
function invariant$1(condition, format, a, b, c, d, e, f) {
  validateFormat(format);
  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }
    error.framesToPop = 1;
    throw error;
  }
}
var invariant_1 = invariant$1;

var _prodInvariant = reactProdInvariant_1;
var invariant = invariant_1;
var oneArgumentPooler = function (copyFieldsFrom) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, copyFieldsFrom);
    return instance;
  } else {
    return new Klass(copyFieldsFrom);
  }
};
var twoArgumentPooler$1 = function (a1, a2) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2);
    return instance;
  } else {
    return new Klass(a1, a2);
  }
};
var threeArgumentPooler = function (a1, a2, a3) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3);
    return instance;
  } else {
    return new Klass(a1, a2, a3);
  }
};
var fourArgumentPooler$1 = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
};
var standardReleaser = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? undefined !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;
  instance.destructor();
  if (Klass.instancePool.length < Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
};
var DEFAULT_POOL_SIZE = 10;
var DEFAULT_POOLER = oneArgumentPooler;
var addPoolingTo = function (CopyConstructor, pooler) {
  var NewKlass = CopyConstructor;
  NewKlass.instancePool = [];
  NewKlass.getPooled = pooler || DEFAULT_POOLER;
  if (!NewKlass.poolSize) {
    NewKlass.poolSize = DEFAULT_POOL_SIZE;
  }
  NewKlass.release = standardReleaser;
  return NewKlass;
};
var PooledClass$1 = {
  addPoolingTo: addPoolingTo,
  oneArgumentPooler: oneArgumentPooler,
  twoArgumentPooler: twoArgumentPooler$1,
  threeArgumentPooler: threeArgumentPooler,
  fourArgumentPooler: fourArgumentPooler$1
};
var PooledClass_1 = PooledClass$1;

var ReactCurrentOwner$1 = {
  current: null
};
var ReactCurrentOwner_1 = ReactCurrentOwner$1;

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}
var emptyFunction$2 = function emptyFunction() {};
emptyFunction$2.thatReturns = makeEmptyFunction;
emptyFunction$2.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction$2.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction$2.thatReturnsNull = makeEmptyFunction(null);
emptyFunction$2.thatReturnsThis = function () {
  return this;
};
emptyFunction$2.thatReturnsArgument = function (arg) {
  return arg;
};
var emptyFunction_1 = emptyFunction$2;

var emptyFunction$1 = emptyFunction_1;
var warning$2 = emptyFunction$1;
if (undefined !== 'production') {
  (function () {
    var printWarning = function printWarning(format) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      var argIndex = 0;
      var message = 'Warning: ' + format.replace(/%s/g, function () {
        return args[argIndex++];
      });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        throw new Error(message);
      } catch (x) {}
    };
    warning$2 = function warning(condition, format) {
      if (format === undefined) {
        throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
      }
      if (format.indexOf('Failed Composite propType: ') === 0) {
        return;
      }
      if (!condition) {
        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
          args[_key2 - 2] = arguments[_key2];
        }
        printWarning.apply(undefined, [format].concat(args));
      }
    };
  })();
}
var warning_1 = warning$2;

var canDefineProperty$1 = false;
if (undefined !== 'production') {
  try {
    Object.defineProperty({}, 'x', { get: function () {} });
    canDefineProperty$1 = true;
  } catch (x) {
  }
}
var canDefineProperty_1 = canDefineProperty$1;

var REACT_ELEMENT_TYPE$1 = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;
var ReactElementSymbol = REACT_ELEMENT_TYPE$1;

var _assign$1 = index;
var ReactCurrentOwner = ReactCurrentOwner_1;
var warning$1 = warning_1;
var canDefineProperty = canDefineProperty_1;
var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var REACT_ELEMENT_TYPE = ReactElementSymbol;
var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};
var specialPropKeyWarningShown;
var specialPropRefWarningShown;
function hasValidRef(config) {
  if (undefined !== 'production') {
    if (hasOwnProperty$1.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.ref !== undefined;
}
function hasValidKey(config) {
  if (undefined !== 'production') {
    if (hasOwnProperty$1.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.key !== undefined;
}
function defineKeyPropWarningGetter(props, displayName) {
  var warnAboutAccessingKey = function () {
    if (!specialPropKeyWarningShown) {
      specialPropKeyWarningShown = true;
      undefined !== 'production' ? warning$1(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
    }
  };
  warnAboutAccessingKey.isReactWarning = true;
  Object.defineProperty(props, 'key', {
    get: warnAboutAccessingKey,
    configurable: true
  });
}
function defineRefPropWarningGetter(props, displayName) {
  var warnAboutAccessingRef = function () {
    if (!specialPropRefWarningShown) {
      specialPropRefWarningShown = true;
      undefined !== 'production' ? warning$1(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
    }
  };
  warnAboutAccessingRef.isReactWarning = true;
  Object.defineProperty(props, 'ref', {
    get: warnAboutAccessingRef,
    configurable: true
  });
}
var ReactElement$2 = function (type, key, ref, self, source, owner, props) {
  var element = {
    $$typeof: REACT_ELEMENT_TYPE,
    type: type,
    key: key,
    ref: ref,
    props: props,
    _owner: owner
  };
  if (undefined !== 'production') {
    element._store = {};
    if (canDefineProperty) {
      Object.defineProperty(element._store, 'validated', {
        configurable: false,
        enumerable: false,
        writable: true,
        value: false
      });
      Object.defineProperty(element, '_self', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: self
      });
      Object.defineProperty(element, '_source', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: source
      });
    } else {
      element._store.validated = false;
      element._self = self;
      element._source = source;
    }
    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }
  return element;
};
ReactElement$2.createElement = function (type, config, children) {
  var propName;
  var props = {};
  var key = null;
  var ref = null;
  var self = null;
  var source = null;
  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }
    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source;
    for (propName in config) {
      if (hasOwnProperty$1.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  }
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    if (undefined !== 'production') {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }
    props.children = childArray;
  }
  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;
    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }
  if (undefined !== 'production') {
    if (key || ref) {
      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
        if (key) {
          defineKeyPropWarningGetter(props, displayName);
        }
        if (ref) {
          defineRefPropWarningGetter(props, displayName);
        }
      }
    }
  }
  return ReactElement$2(type, key, ref, self, source, ReactCurrentOwner.current, props);
};
ReactElement$2.createFactory = function (type) {
  var factory = ReactElement$2.createElement.bind(null, type);
  factory.type = type;
  return factory;
};
ReactElement$2.cloneAndReplaceKey = function (oldElement, newKey) {
  var newElement = ReactElement$2(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
  return newElement;
};
ReactElement$2.cloneElement = function (element, config, children) {
  var propName;
  var props = _assign$1({}, element.props);
  var key = element.key;
  var ref = element.ref;
  var self = element._self;
  var source = element._source;
  var owner = element._owner;
  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }
    var defaultProps;
    if (element.type && element.type.defaultProps) {
      defaultProps = element.type.defaultProps;
    }
    for (propName in config) {
      if (hasOwnProperty$1.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        if (config[propName] === undefined && defaultProps !== undefined) {
          props[propName] = defaultProps[propName];
        } else {
          props[propName] = config[propName];
        }
      }
    }
  }
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    props.children = childArray;
  }
  return ReactElement$2(element.type, key, ref, self, source, owner, props);
};
ReactElement$2.isValidElement = function (object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
};
var ReactElement_1 = ReactElement$2;

var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn$1(maybeIterable) {
  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
  if (typeof iteratorFn === 'function') {
    return iteratorFn;
  }
}
var getIteratorFn_1 = getIteratorFn$1;

function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = ('' + key).replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });
  return '$' + escapedString;
}
function unescape(key) {
  var unescapeRegex = /(=0|=2)/g;
  var unescaperLookup = {
    '=0': '=',
    '=2': ':'
  };
  var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);
  return ('' + keySubstring).replace(unescapeRegex, function (match) {
    return unescaperLookup[match];
  });
}
var KeyEscapeUtils$1 = {
  escape: escape,
  unescape: unescape
};
var KeyEscapeUtils_1 = KeyEscapeUtils$1;

var _prodInvariant$1 = reactProdInvariant_1;
var ReactCurrentOwner$2 = ReactCurrentOwner_1;
var REACT_ELEMENT_TYPE$2 = ReactElementSymbol;
var getIteratorFn = getIteratorFn_1;
var invariant$2 = invariant_1;
var KeyEscapeUtils = KeyEscapeUtils_1;
var warning$3 = warning_1;
var SEPARATOR = '.';
var SUBSEPARATOR = ':';
var didWarnAboutMaps = false;
function getComponentKey(component, index) {
  if (component && typeof component === 'object' && component.key != null) {
    return KeyEscapeUtils.escape(component.key);
  }
  return index.toString(36);
}
function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
  var type = typeof children;
  if (type === 'undefined' || type === 'boolean') {
    children = null;
  }
  if (children === null || type === 'string' || type === 'number' ||
  type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE$2) {
    callback(traverseContext, children,
    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
    return 1;
  }
  var child;
  var nextName;
  var subtreeCount = 0;
  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getComponentKey(child, i);
      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
    }
  } else {
    var iteratorFn = getIteratorFn(children);
    if (iteratorFn) {
      var iterator = iteratorFn.call(children);
      var step;
      if (iteratorFn !== children.entries) {
        var ii = 0;
        while (!(step = iterator.next()).done) {
          child = step.value;
          nextName = nextNamePrefix + getComponentKey(child, ii++);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } else {
        if (undefined !== 'production') {
          var mapsAsChildrenAddendum = '';
          if (ReactCurrentOwner$2.current) {
            var mapsAsChildrenOwnerName = ReactCurrentOwner$2.current.getName();
            if (mapsAsChildrenOwnerName) {
              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
            }
          }
          undefined !== 'production' ? warning$3(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
          didWarnAboutMaps = true;
        }
        while (!(step = iterator.next()).done) {
          var entry = step.value;
          if (entry) {
            child = entry[1];
            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        }
      }
    } else if (type === 'object') {
      var addendum = '';
      if (undefined !== 'production') {
        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
        if (children._isReactElement) {
          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
        }
        if (ReactCurrentOwner$2.current) {
          var name = ReactCurrentOwner$2.current.getName();
          if (name) {
            addendum += ' Check the render method of `' + name + '`.';
          }
        }
      }
      var childrenString = String(children);
      undefined !== 'production' ? invariant$2(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant$1('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum);
    }
  }
  return subtreeCount;
}
function traverseAllChildren$1(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }
  return traverseAllChildrenImpl(children, '', callback, traverseContext);
}
var traverseAllChildren_1 = traverseAllChildren$1;

var PooledClass = PooledClass_1;
var ReactElement$1 = ReactElement_1;
var emptyFunction = emptyFunction_1;
var traverseAllChildren = traverseAllChildren_1;
var twoArgumentPooler = PooledClass.twoArgumentPooler;
var fourArgumentPooler = PooledClass.fourArgumentPooler;
var userProvidedKeyEscapeRegex = /\/+/g;
function escapeUserProvidedKey(text) {
  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
}
function ForEachBookKeeping(forEachFunction, forEachContext) {
  this.func = forEachFunction;
  this.context = forEachContext;
  this.count = 0;
}
ForEachBookKeeping.prototype.destructor = function () {
  this.func = null;
  this.context = null;
  this.count = 0;
};
PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);
function forEachSingleChild(bookKeeping, child, name) {
  var func = bookKeeping.func,
      context = bookKeeping.context;
  func.call(context, child, bookKeeping.count++);
}
function forEachChildren(children, forEachFunc, forEachContext) {
  if (children == null) {
    return children;
  }
  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
  traverseAllChildren(children, forEachSingleChild, traverseContext);
  ForEachBookKeeping.release(traverseContext);
}
function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
  this.result = mapResult;
  this.keyPrefix = keyPrefix;
  this.func = mapFunction;
  this.context = mapContext;
  this.count = 0;
}
MapBookKeeping.prototype.destructor = function () {
  this.result = null;
  this.keyPrefix = null;
  this.func = null;
  this.context = null;
  this.count = 0;
};
PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);
function mapSingleChildIntoContext(bookKeeping, child, childKey) {
  var result = bookKeeping.result,
      keyPrefix = bookKeeping.keyPrefix,
      func = bookKeeping.func,
      context = bookKeeping.context;
  var mappedChild = func.call(context, child, bookKeeping.count++);
  if (Array.isArray(mappedChild)) {
    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
  } else if (mappedChild != null) {
    if (ReactElement$1.isValidElement(mappedChild)) {
      mappedChild = ReactElement$1.cloneAndReplaceKey(mappedChild,
      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
    }
    result.push(mappedChild);
  }
}
function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
  var escapedPrefix = '';
  if (prefix != null) {
    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
  }
  var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
  MapBookKeeping.release(traverseContext);
}
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
  return result;
}
function forEachSingleChildDummy(traverseContext, child, name) {
  return null;
}
function countChildren(children, context) {
  return traverseAllChildren(children, forEachSingleChildDummy, null);
}
function toArray(children) {
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
  return result;
}
var ReactChildren$1 = {
  forEach: forEachChildren,
  map: mapChildren,
  mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
  count: countChildren,
  toArray: toArray
};
var ReactChildren_1 = ReactChildren$1;

var warning$5 = warning_1;
function warnNoop(publicInstance, callerName) {
  if (undefined !== 'production') {
    var constructor = publicInstance.constructor;
    undefined !== 'production' ? warning$5(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
  }
}
var ReactNoopUpdateQueue$1 = {
  isMounted: function (publicInstance) {
    return false;
  },
  enqueueCallback: function (publicInstance, callback) {},
  enqueueForceUpdate: function (publicInstance) {
    warnNoop(publicInstance, 'forceUpdate');
  },
  enqueueReplaceState: function (publicInstance, completeState) {
    warnNoop(publicInstance, 'replaceState');
  },
  enqueueSetState: function (publicInstance, partialState) {
    warnNoop(publicInstance, 'setState');
  }
};
var ReactNoopUpdateQueue_1 = ReactNoopUpdateQueue$1;

var emptyObject$1 = {};
if (undefined !== 'production') {
  Object.freeze(emptyObject$1);
}
var emptyObject_1 = emptyObject$1;

var _prodInvariant$2 = reactProdInvariant_1;
var ReactNoopUpdateQueue = ReactNoopUpdateQueue_1;
var canDefineProperty$2 = canDefineProperty_1;
var emptyObject = emptyObject_1;
var invariant$3 = invariant_1;
var warning$4 = warning_1;
function ReactComponent$1(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}
ReactComponent$1.prototype.isReactComponent = {};
ReactComponent$1.prototype.setState = function (partialState, callback) {
  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? undefined !== 'production' ? invariant$3(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : _prodInvariant$2('85') : void 0;
  this.updater.enqueueSetState(this, partialState);
  if (callback) {
    this.updater.enqueueCallback(this, callback, 'setState');
  }
};
ReactComponent$1.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this);
  if (callback) {
    this.updater.enqueueCallback(this, callback, 'forceUpdate');
  }
};
if (undefined !== 'production') {
  var deprecatedAPIs = {
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
  };
  var defineDeprecationWarning = function (methodName, info) {
    if (canDefineProperty$2) {
      Object.defineProperty(ReactComponent$1.prototype, methodName, {
        get: function () {
          undefined !== 'production' ? warning$4(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : void 0;
          return undefined;
        }
      });
    }
  };
  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}
var ReactComponent_1 = ReactComponent$1;

var _assign$2 = index;
var ReactComponent$2 = ReactComponent_1;
var ReactNoopUpdateQueue$2 = ReactNoopUpdateQueue_1;
var emptyObject$2 = emptyObject_1;
function ReactPureComponent$1(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject$2;
  this.updater = updater || ReactNoopUpdateQueue$2;
}
function ComponentDummy() {}
ComponentDummy.prototype = ReactComponent$2.prototype;
ReactPureComponent$1.prototype = new ComponentDummy();
ReactPureComponent$1.prototype.constructor = ReactPureComponent$1;
_assign$2(ReactPureComponent$1.prototype, ReactComponent$2.prototype);
ReactPureComponent$1.prototype.isPureReactComponent = true;
var ReactPureComponent_1 = ReactPureComponent$1;

var ReactPropTypeLocationNames$1 = {};
if (undefined !== 'production') {
  ReactPropTypeLocationNames$1 = {
    prop: 'prop',
    context: 'context',
    childContext: 'child context'
  };
}
var ReactPropTypeLocationNames_1 = ReactPropTypeLocationNames$1;

var _prodInvariant$3 = reactProdInvariant_1;
var _assign$3 = index;
var ReactComponent$3 = ReactComponent_1;
var ReactElement$3 = ReactElement_1;
var ReactPropTypeLocationNames = ReactPropTypeLocationNames_1;
var ReactNoopUpdateQueue$3 = ReactNoopUpdateQueue_1;
var emptyObject$3 = emptyObject_1;
var invariant$4 = invariant_1;
var warning$6 = warning_1;
var MIXINS_KEY = 'mixins';
function identity(fn) {
  return fn;
}
var injectedMixins = [];
var ReactClassInterface = {
  mixins: 'DEFINE_MANY',
  statics: 'DEFINE_MANY',
  propTypes: 'DEFINE_MANY',
  contextTypes: 'DEFINE_MANY',
  childContextTypes: 'DEFINE_MANY',
  getDefaultProps: 'DEFINE_MANY_MERGED',
  getInitialState: 'DEFINE_MANY_MERGED',
  getChildContext: 'DEFINE_MANY_MERGED',
  render: 'DEFINE_ONCE',
  componentWillMount: 'DEFINE_MANY',
  componentDidMount: 'DEFINE_MANY',
  componentWillReceiveProps: 'DEFINE_MANY',
  shouldComponentUpdate: 'DEFINE_ONCE',
  componentWillUpdate: 'DEFINE_MANY',
  componentDidUpdate: 'DEFINE_MANY',
  componentWillUnmount: 'DEFINE_MANY',
  updateComponent: 'OVERRIDE_BASE'
};
var RESERVED_SPEC_KEYS = {
  displayName: function (Constructor, displayName) {
    Constructor.displayName = displayName;
  },
  mixins: function (Constructor, mixins) {
    if (mixins) {
      for (var i = 0; i < mixins.length; i++) {
        mixSpecIntoComponent(Constructor, mixins[i]);
      }
    }
  },
  childContextTypes: function (Constructor, childContextTypes) {
    if (undefined !== 'production') {
      validateTypeDef(Constructor, childContextTypes, 'childContext');
    }
    Constructor.childContextTypes = _assign$3({}, Constructor.childContextTypes, childContextTypes);
  },
  contextTypes: function (Constructor, contextTypes) {
    if (undefined !== 'production') {
      validateTypeDef(Constructor, contextTypes, 'context');
    }
    Constructor.contextTypes = _assign$3({}, Constructor.contextTypes, contextTypes);
  },
  getDefaultProps: function (Constructor, getDefaultProps) {
    if (Constructor.getDefaultProps) {
      Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);
    } else {
      Constructor.getDefaultProps = getDefaultProps;
    }
  },
  propTypes: function (Constructor, propTypes) {
    if (undefined !== 'production') {
      validateTypeDef(Constructor, propTypes, 'prop');
    }
    Constructor.propTypes = _assign$3({}, Constructor.propTypes, propTypes);
  },
  statics: function (Constructor, statics) {
    mixStaticSpecIntoComponent(Constructor, statics);
  },
  autobind: function () {} };
function validateTypeDef(Constructor, typeDef, location) {
  for (var propName in typeDef) {
    if (typeDef.hasOwnProperty(propName)) {
      undefined !== 'production' ? warning$6(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : void 0;
    }
  }
}
function validateMethodOverride(isAlreadyDefined, name) {
  var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;
  if (ReactClassMixin.hasOwnProperty(name)) {
    !(specPolicy === 'OVERRIDE_BASE') ? undefined !== 'production' ? invariant$4(false, 'ReactClassInterface: You are attempting to override `%s` from your class specification. Ensure that your method names do not overlap with React methods.', name) : _prodInvariant$3('73', name) : void 0;
  }
  if (isAlreadyDefined) {
    !(specPolicy === 'DEFINE_MANY' || specPolicy === 'DEFINE_MANY_MERGED') ? undefined !== 'production' ? invariant$4(false, 'ReactClassInterface: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant$3('74', name) : void 0;
  }
}
function mixSpecIntoComponent(Constructor, spec) {
  if (!spec) {
    if (undefined !== 'production') {
      var typeofSpec = typeof spec;
      var isMixinValid = typeofSpec === 'object' && spec !== null;
      undefined !== 'production' ? warning$6(isMixinValid, '%s: You\'re attempting to include a mixin that is either null ' + 'or not an object. Check the mixins included by the component, ' + 'as well as any mixins they include themselves. ' + 'Expected object but got %s.', Constructor.displayName || 'ReactClass', spec === null ? null : typeofSpec) : void 0;
    }
    return;
  }
  !(typeof spec !== 'function') ? undefined !== 'production' ? invariant$4(false, 'ReactClass: You\'re attempting to use a component class or function as a mixin. Instead, just use a regular object.') : _prodInvariant$3('75') : void 0;
  !!ReactElement$3.isValidElement(spec) ? undefined !== 'production' ? invariant$4(false, 'ReactClass: You\'re attempting to use a component as a mixin. Instead, just use a regular object.') : _prodInvariant$3('76') : void 0;
  var proto = Constructor.prototype;
  var autoBindPairs = proto.__reactAutoBindPairs;
  if (spec.hasOwnProperty(MIXINS_KEY)) {
    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
  }
  for (var name in spec) {
    if (!spec.hasOwnProperty(name)) {
      continue;
    }
    if (name === MIXINS_KEY) {
      continue;
    }
    var property = spec[name];
    var isAlreadyDefined = proto.hasOwnProperty(name);
    validateMethodOverride(isAlreadyDefined, name);
    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
      RESERVED_SPEC_KEYS[name](Constructor, property);
    } else {
      var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
      var isFunction = typeof property === 'function';
      var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;
      if (shouldAutoBind) {
        autoBindPairs.push(name, property);
        proto[name] = property;
      } else {
        if (isAlreadyDefined) {
          var specPolicy = ReactClassInterface[name];
          !(isReactClassMethod && (specPolicy === 'DEFINE_MANY_MERGED' || specPolicy === 'DEFINE_MANY')) ? undefined !== 'production' ? invariant$4(false, 'ReactClass: Unexpected spec policy %s for key %s when mixing in component specs.', specPolicy, name) : _prodInvariant$3('77', specPolicy, name) : void 0;
          if (specPolicy === 'DEFINE_MANY_MERGED') {
            proto[name] = createMergedResultFunction(proto[name], property);
          } else if (specPolicy === 'DEFINE_MANY') {
            proto[name] = createChainedFunction(proto[name], property);
          }
        } else {
          proto[name] = property;
          if (undefined !== 'production') {
            if (typeof property === 'function' && spec.displayName) {
              proto[name].displayName = spec.displayName + '_' + name;
            }
          }
        }
      }
    }
  }
}
function mixStaticSpecIntoComponent(Constructor, statics) {
  if (!statics) {
    return;
  }
  for (var name in statics) {
    var property = statics[name];
    if (!statics.hasOwnProperty(name)) {
      continue;
    }
    var isReserved = name in RESERVED_SPEC_KEYS;
    !!isReserved ? undefined !== 'production' ? invariant$4(false, 'ReactClass: You are attempting to define a reserved property, `%s`, that shouldn\'t be on the "statics" key. Define it as an instance property instead; it will still be accessible on the constructor.', name) : _prodInvariant$3('78', name) : void 0;
    var isInherited = name in Constructor;
    !!isInherited ? undefined !== 'production' ? invariant$4(false, 'ReactClass: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant$3('79', name) : void 0;
    Constructor[name] = property;
  }
}
function mergeIntoWithNoDuplicateKeys(one, two) {
  !(one && two && typeof one === 'object' && typeof two === 'object') ? undefined !== 'production' ? invariant$4(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : _prodInvariant$3('80') : void 0;
  for (var key in two) {
    if (two.hasOwnProperty(key)) {
      !(one[key] === undefined) ? undefined !== 'production' ? invariant$4(false, 'mergeIntoWithNoDuplicateKeys(): Tried to merge two objects with the same key: `%s`. This conflict may be due to a mixin; in particular, this may be caused by two getInitialState() or getDefaultProps() methods returning objects with clashing keys.', key) : _prodInvariant$3('81', key) : void 0;
      one[key] = two[key];
    }
  }
  return one;
}
function createMergedResultFunction(one, two) {
  return function mergedResult() {
    var a = one.apply(this, arguments);
    var b = two.apply(this, arguments);
    if (a == null) {
      return b;
    } else if (b == null) {
      return a;
    }
    var c = {};
    mergeIntoWithNoDuplicateKeys(c, a);
    mergeIntoWithNoDuplicateKeys(c, b);
    return c;
  };
}
function createChainedFunction(one, two) {
  return function chainedFunction() {
    one.apply(this, arguments);
    two.apply(this, arguments);
  };
}
function bindAutoBindMethod(component, method) {
  var boundMethod = method.bind(component);
  if (undefined !== 'production') {
    boundMethod.__reactBoundContext = component;
    boundMethod.__reactBoundMethod = method;
    boundMethod.__reactBoundArguments = null;
    var componentName = component.constructor.displayName;
    var _bind = boundMethod.bind;
    boundMethod.bind = function (newThis) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      if (newThis !== component && newThis !== null) {
        undefined !== 'production' ? warning$6(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : void 0;
      } else if (!args.length) {
        undefined !== 'production' ? warning$6(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : void 0;
        return boundMethod;
      }
      var reboundMethod = _bind.apply(boundMethod, arguments);
      reboundMethod.__reactBoundContext = component;
      reboundMethod.__reactBoundMethod = method;
      reboundMethod.__reactBoundArguments = args;
      return reboundMethod;
    };
  }
  return boundMethod;
}
function bindAutoBindMethods(component) {
  var pairs = component.__reactAutoBindPairs;
  for (var i = 0; i < pairs.length; i += 2) {
    var autoBindKey = pairs[i];
    var method = pairs[i + 1];
    component[autoBindKey] = bindAutoBindMethod(component, method);
  }
}
var ReactClassMixin = {
  replaceState: function (newState, callback) {
    this.updater.enqueueReplaceState(this, newState);
    if (callback) {
      this.updater.enqueueCallback(this, callback, 'replaceState');
    }
  },
  isMounted: function () {
    return this.updater.isMounted(this);
  }
};
var ReactClassComponent = function () {};
_assign$3(ReactClassComponent.prototype, ReactComponent$3.prototype, ReactClassMixin);
var ReactClass$1 = {
  createClass: function (spec) {
    var Constructor = identity(function (props, context, updater) {
      if (undefined !== 'production') {
        undefined !== 'production' ? warning$6(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : void 0;
      }
      if (this.__reactAutoBindPairs.length) {
        bindAutoBindMethods(this);
      }
      this.props = props;
      this.context = context;
      this.refs = emptyObject$3;
      this.updater = updater || ReactNoopUpdateQueue$3;
      this.state = null;
      var initialState = this.getInitialState ? this.getInitialState() : null;
      if (undefined !== 'production') {
        if (initialState === undefined && this.getInitialState._isMockFunction) {
          initialState = null;
        }
      }
      !(typeof initialState === 'object' && !Array.isArray(initialState)) ? undefined !== 'production' ? invariant$4(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : _prodInvariant$3('82', Constructor.displayName || 'ReactCompositeComponent') : void 0;
      this.state = initialState;
    });
    Constructor.prototype = new ReactClassComponent();
    Constructor.prototype.constructor = Constructor;
    Constructor.prototype.__reactAutoBindPairs = [];
    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));
    mixSpecIntoComponent(Constructor, spec);
    if (Constructor.getDefaultProps) {
      Constructor.defaultProps = Constructor.getDefaultProps();
    }
    if (undefined !== 'production') {
      if (Constructor.getDefaultProps) {
        Constructor.getDefaultProps.isReactClassApproved = {};
      }
      if (Constructor.prototype.getInitialState) {
        Constructor.prototype.getInitialState.isReactClassApproved = {};
      }
    }
    !Constructor.prototype.render ? undefined !== 'production' ? invariant$4(false, 'createClass(...): Class specification must implement a `render` method.') : _prodInvariant$3('83') : void 0;
    if (undefined !== 'production') {
      undefined !== 'production' ? warning$6(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : void 0;
      undefined !== 'production' ? warning$6(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : void 0;
    }
    for (var methodName in ReactClassInterface) {
      if (!Constructor.prototype[methodName]) {
        Constructor.prototype[methodName] = null;
      }
    }
    return Constructor;
  },
  injection: {
    injectMixin: function (mixin) {
      injectedMixins.push(mixin);
    }
  }
};
var ReactClass_1 = ReactClass$1;

var _prodInvariant$4 = reactProdInvariant_1;
var ReactCurrentOwner$4 = ReactCurrentOwner_1;
var invariant$5 = invariant_1;
var warning$8 = warning_1;
function isNative(fn) {
  var funcToString = Function.prototype.toString;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var reIsNative = RegExp('^' + funcToString
  .call(hasOwnProperty)
  .replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
  try {
    var source = funcToString.call(fn);
    return reIsNative.test(source);
  } catch (err) {
    return false;
  }
}
var canUseCollections =
typeof Array.from === 'function' &&
typeof Map === 'function' && isNative(Map) &&
Map.prototype != null && typeof Map.prototype.keys === 'function' && isNative(Map.prototype.keys) &&
typeof Set === 'function' && isNative(Set) &&
Set.prototype != null && typeof Set.prototype.keys === 'function' && isNative(Set.prototype.keys);
var setItem;
var getItem;
var removeItem;
var getItemIDs;
var addRoot;
var removeRoot;
var getRootIDs;
if (canUseCollections) {
  var itemMap = new Map();
  var rootIDSet = new Set();
  setItem = function (id, item) {
    itemMap.set(id, item);
  };
  getItem = function (id) {
    return itemMap.get(id);
  };
  removeItem = function (id) {
    itemMap['delete'](id);
  };
  getItemIDs = function () {
    return Array.from(itemMap.keys());
  };
  addRoot = function (id) {
    rootIDSet.add(id);
  };
  removeRoot = function (id) {
    rootIDSet['delete'](id);
  };
  getRootIDs = function () {
    return Array.from(rootIDSet.keys());
  };
} else {
  var itemByKey = {};
  var rootByKey = {};
  var getKeyFromID = function (id) {
    return '.' + id;
  };
  var getIDFromKey = function (key) {
    return parseInt(key.substr(1), 10);
  };
  setItem = function (id, item) {
    var key = getKeyFromID(id);
    itemByKey[key] = item;
  };
  getItem = function (id) {
    var key = getKeyFromID(id);
    return itemByKey[key];
  };
  removeItem = function (id) {
    var key = getKeyFromID(id);
    delete itemByKey[key];
  };
  getItemIDs = function () {
    return Object.keys(itemByKey).map(getIDFromKey);
  };
  addRoot = function (id) {
    var key = getKeyFromID(id);
    rootByKey[key] = true;
  };
  removeRoot = function (id) {
    var key = getKeyFromID(id);
    delete rootByKey[key];
  };
  getRootIDs = function () {
    return Object.keys(rootByKey).map(getIDFromKey);
  };
}
var unmountedIDs = [];
function purgeDeep(id) {
  var item = getItem(id);
  if (item) {
    var childIDs = item.childIDs;
    removeItem(id);
    childIDs.forEach(purgeDeep);
  }
}
function describeComponentFrame(name, source, ownerName) {
  return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
}
function getDisplayName(element) {
  if (element == null) {
    return '#empty';
  } else if (typeof element === 'string' || typeof element === 'number') {
    return '#text';
  } else if (typeof element.type === 'string') {
    return element.type;
  } else {
    return element.type.displayName || element.type.name || 'Unknown';
  }
}
function describeID(id) {
  var name = ReactComponentTreeHook$1.getDisplayName(id);
  var element = ReactComponentTreeHook$1.getElement(id);
  var ownerID = ReactComponentTreeHook$1.getOwnerID(id);
  var ownerName;
  if (ownerID) {
    ownerName = ReactComponentTreeHook$1.getDisplayName(ownerID);
  }
  undefined !== 'production' ? warning$8(element, 'ReactComponentTreeHook: Missing React element for debugID %s when ' + 'building stack', id) : void 0;
  return describeComponentFrame(name, element && element._source, ownerName);
}
var ReactComponentTreeHook$1 = {
  onSetChildren: function (id, nextChildIDs) {
    var item = getItem(id);
    !item ? undefined !== 'production' ? invariant$5(false, 'Item must have been set') : _prodInvariant$4('144') : void 0;
    item.childIDs = nextChildIDs;
    for (var i = 0; i < nextChildIDs.length; i++) {
      var nextChildID = nextChildIDs[i];
      var nextChild = getItem(nextChildID);
      !nextChild ? undefined !== 'production' ? invariant$5(false, 'Expected hook events to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant$4('140') : void 0;
      !(nextChild.childIDs != null || typeof nextChild.element !== 'object' || nextChild.element == null) ? undefined !== 'production' ? invariant$5(false, 'Expected onSetChildren() to fire for a container child before its parent includes it in onSetChildren().') : _prodInvariant$4('141') : void 0;
      !nextChild.isMounted ? undefined !== 'production' ? invariant$5(false, 'Expected onMountComponent() to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant$4('71') : void 0;
      if (nextChild.parentID == null) {
        nextChild.parentID = id;
      }
      !(nextChild.parentID === id) ? undefined !== 'production' ? invariant$5(false, 'Expected onBeforeMountComponent() parent and onSetChildren() to be consistent (%s has parents %s and %s).', nextChildID, nextChild.parentID, id) : _prodInvariant$4('142', nextChildID, nextChild.parentID, id) : void 0;
    }
  },
  onBeforeMountComponent: function (id, element, parentID) {
    var item = {
      element: element,
      parentID: parentID,
      text: null,
      childIDs: [],
      isMounted: false,
      updateCount: 0
    };
    setItem(id, item);
  },
  onBeforeUpdateComponent: function (id, element) {
    var item = getItem(id);
    if (!item || !item.isMounted) {
      return;
    }
    item.element = element;
  },
  onMountComponent: function (id) {
    var item = getItem(id);
    !item ? undefined !== 'production' ? invariant$5(false, 'Item must have been set') : _prodInvariant$4('144') : void 0;
    item.isMounted = true;
    var isRoot = item.parentID === 0;
    if (isRoot) {
      addRoot(id);
    }
  },
  onUpdateComponent: function (id) {
    var item = getItem(id);
    if (!item || !item.isMounted) {
      return;
    }
    item.updateCount++;
  },
  onUnmountComponent: function (id) {
    var item = getItem(id);
    if (item) {
      item.isMounted = false;
      var isRoot = item.parentID === 0;
      if (isRoot) {
        removeRoot(id);
      }
    }
    unmountedIDs.push(id);
  },
  purgeUnmountedComponents: function () {
    if (ReactComponentTreeHook$1._preventPurging) {
      return;
    }
    for (var i = 0; i < unmountedIDs.length; i++) {
      var id = unmountedIDs[i];
      purgeDeep(id);
    }
    unmountedIDs.length = 0;
  },
  isMounted: function (id) {
    var item = getItem(id);
    return item ? item.isMounted : false;
  },
  getCurrentStackAddendum: function (topElement) {
    var info = '';
    if (topElement) {
      var name = getDisplayName(topElement);
      var owner = topElement._owner;
      info += describeComponentFrame(name, topElement._source, owner && owner.getName());
    }
    var currentOwner = ReactCurrentOwner$4.current;
    var id = currentOwner && currentOwner._debugID;
    info += ReactComponentTreeHook$1.getStackAddendumByID(id);
    return info;
  },
  getStackAddendumByID: function (id) {
    var info = '';
    while (id) {
      info += describeID(id);
      id = ReactComponentTreeHook$1.getParentID(id);
    }
    return info;
  },
  getChildIDs: function (id) {
    var item = getItem(id);
    return item ? item.childIDs : [];
  },
  getDisplayName: function (id) {
    var element = ReactComponentTreeHook$1.getElement(id);
    if (!element) {
      return null;
    }
    return getDisplayName(element);
  },
  getElement: function (id) {
    var item = getItem(id);
    return item ? item.element : null;
  },
  getOwnerID: function (id) {
    var element = ReactComponentTreeHook$1.getElement(id);
    if (!element || !element._owner) {
      return null;
    }
    return element._owner._debugID;
  },
  getParentID: function (id) {
    var item = getItem(id);
    return item ? item.parentID : null;
  },
  getSource: function (id) {
    var item = getItem(id);
    var element = item ? item.element : null;
    var source = element != null ? element._source : null;
    return source;
  },
  getText: function (id) {
    var element = ReactComponentTreeHook$1.getElement(id);
    if (typeof element === 'string') {
      return element;
    } else if (typeof element === 'number') {
      return '' + element;
    } else {
      return null;
    }
  },
  getUpdateCount: function (id) {
    var item = getItem(id);
    return item ? item.updateCount : 0;
  },
  getRootIDs: getRootIDs,
  getRegisteredIDs: getItemIDs
};
var ReactComponentTreeHook_1 = ReactComponentTreeHook$1;

var ReactPropTypesSecret$1 = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;

var _prodInvariant$5 = reactProdInvariant_1;
var ReactPropTypeLocationNames$2 = ReactPropTypeLocationNames_1;
var ReactPropTypesSecret = ReactPropTypesSecret_1;
var invariant$6 = invariant_1;
var warning$9 = warning_1;
var ReactComponentTreeHook$2;
if (typeof process !== 'undefined' && process.env && undefined === 'test') {
  ReactComponentTreeHook$2 = ReactComponentTreeHook_1;
}
var loggedTypeFailures = {};
function checkReactTypeSpec$1(typeSpecs, values, location, componentName, element, debugID) {
  for (var typeSpecName in typeSpecs) {
    if (typeSpecs.hasOwnProperty(typeSpecName)) {
      var error;
      try {
        !(typeof typeSpecs[typeSpecName] === 'function') ? undefined !== 'production' ? invariant$6(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames$2[location], typeSpecName) : _prodInvariant$5('84', componentName || 'React class', ReactPropTypeLocationNames$2[location], typeSpecName) : void 0;
        error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
      } catch (ex) {
        error = ex;
      }
      undefined !== 'production' ? warning$9(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames$2[location], typeSpecName, typeof error) : void 0;
      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
        loggedTypeFailures[error.message] = true;
        var componentStackInfo = '';
        if (undefined !== 'production') {
          if (!ReactComponentTreeHook$2) {
            ReactComponentTreeHook$2 = ReactComponentTreeHook_1;
          }
          if (debugID !== null) {
            componentStackInfo = ReactComponentTreeHook$2.getStackAddendumByID(debugID);
          } else if (element !== null) {
            componentStackInfo = ReactComponentTreeHook$2.getCurrentStackAddendum(element);
          }
        }
        undefined !== 'production' ? warning$9(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
      }
    }
  }
}
var checkReactTypeSpec_1 = checkReactTypeSpec$1;

var ReactCurrentOwner$3 = ReactCurrentOwner_1;
var ReactComponentTreeHook = ReactComponentTreeHook_1;
var ReactElement$5 = ReactElement_1;
var checkReactTypeSpec = checkReactTypeSpec_1;
var canDefineProperty$3 = canDefineProperty_1;
var getIteratorFn$2 = getIteratorFn_1;
var warning$7 = warning_1;
function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner$3.current) {
    var name = ReactCurrentOwner$3.current.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}
var ownerHasKeyUseWarning = {};
function getCurrentComponentErrorInfo(parentType) {
  var info = getDeclarationErrorAddendum();
  if (!info) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
    if (parentName) {
      info = ' Check the top-level render call using <' + parentName + '>.';
    }
  }
  return info;
}
function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }
  element._store.validated = true;
  var memoizer = ownerHasKeyUseWarning.uniqueKey || (ownerHasKeyUseWarning.uniqueKey = {});
  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
  if (memoizer[currentComponentErrorInfo]) {
    return;
  }
  memoizer[currentComponentErrorInfo] = true;
  var childOwner = '';
  if (element && element._owner && element._owner !== ReactCurrentOwner$3.current) {
    childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
  }
  undefined !== 'production' ? warning$7(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, ReactComponentTreeHook.getCurrentStackAddendum(element)) : void 0;
}
function validateChildKeys(node, parentType) {
  if (typeof node !== 'object') {
    return;
  }
  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];
      if (ReactElement$5.isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (ReactElement$5.isValidElement(node)) {
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = getIteratorFn$2(node);
    if (iteratorFn) {
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;
        while (!(step = iterator.next()).done) {
          if (ReactElement$5.isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}
function validatePropTypes(element) {
  var componentClass = element.type;
  if (typeof componentClass !== 'function') {
    return;
  }
  var name = componentClass.displayName || componentClass.name;
  if (componentClass.propTypes) {
    checkReactTypeSpec(componentClass.propTypes, element.props, 'prop', name, element, null);
  }
  if (typeof componentClass.getDefaultProps === 'function') {
    undefined !== 'production' ? warning$7(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;
  }
}
var ReactElementValidator$2 = {
  createElement: function (type, props, children) {
    var validType = typeof type === 'string' || typeof type === 'function';
    if (!validType) {
      if (typeof type !== 'function' && typeof type !== 'string') {
        var info = '';
        if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
          info += ' You likely forgot to export your component from the file ' + 'it\'s defined in.';
        }
        info += getDeclarationErrorAddendum();
        undefined !== 'production' ? warning$7(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', type == null ? type : typeof type, info) : void 0;
      }
    }
    var element = ReactElement$5.createElement.apply(this, arguments);
    if (element == null) {
      return element;
    }
    if (validType) {
      for (var i = 2; i < arguments.length; i++) {
        validateChildKeys(arguments[i], type);
      }
    }
    validatePropTypes(element);
    return element;
  },
  createFactory: function (type) {
    var validatedFactory = ReactElementValidator$2.createElement.bind(null, type);
    validatedFactory.type = type;
    if (undefined !== 'production') {
      if (canDefineProperty$3) {
        Object.defineProperty(validatedFactory, 'type', {
          enumerable: false,
          get: function () {
            undefined !== 'production' ? warning$7(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : void 0;
            Object.defineProperty(this, 'type', {
              value: type
            });
            return type;
          }
        });
      }
    }
    return validatedFactory;
  },
  cloneElement: function (element, props, children) {
    var newElement = ReactElement$5.cloneElement.apply(this, arguments);
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], newElement.type);
    }
    validatePropTypes(newElement);
    return newElement;
  }
};
var ReactElementValidator_1 = ReactElementValidator$2;

var ReactElement$4 = ReactElement_1;
var createDOMFactory = ReactElement$4.createFactory;
if (undefined !== 'production') {
  var ReactElementValidator$1 = ReactElementValidator_1;
  createDOMFactory = ReactElementValidator$1.createFactory;
}
var ReactDOMFactories$1 = {
  a: createDOMFactory('a'),
  abbr: createDOMFactory('abbr'),
  address: createDOMFactory('address'),
  area: createDOMFactory('area'),
  article: createDOMFactory('article'),
  aside: createDOMFactory('aside'),
  audio: createDOMFactory('audio'),
  b: createDOMFactory('b'),
  base: createDOMFactory('base'),
  bdi: createDOMFactory('bdi'),
  bdo: createDOMFactory('bdo'),
  big: createDOMFactory('big'),
  blockquote: createDOMFactory('blockquote'),
  body: createDOMFactory('body'),
  br: createDOMFactory('br'),
  button: createDOMFactory('button'),
  canvas: createDOMFactory('canvas'),
  caption: createDOMFactory('caption'),
  cite: createDOMFactory('cite'),
  code: createDOMFactory('code'),
  col: createDOMFactory('col'),
  colgroup: createDOMFactory('colgroup'),
  data: createDOMFactory('data'),
  datalist: createDOMFactory('datalist'),
  dd: createDOMFactory('dd'),
  del: createDOMFactory('del'),
  details: createDOMFactory('details'),
  dfn: createDOMFactory('dfn'),
  dialog: createDOMFactory('dialog'),
  div: createDOMFactory('div'),
  dl: createDOMFactory('dl'),
  dt: createDOMFactory('dt'),
  em: createDOMFactory('em'),
  embed: createDOMFactory('embed'),
  fieldset: createDOMFactory('fieldset'),
  figcaption: createDOMFactory('figcaption'),
  figure: createDOMFactory('figure'),
  footer: createDOMFactory('footer'),
  form: createDOMFactory('form'),
  h1: createDOMFactory('h1'),
  h2: createDOMFactory('h2'),
  h3: createDOMFactory('h3'),
  h4: createDOMFactory('h4'),
  h5: createDOMFactory('h5'),
  h6: createDOMFactory('h6'),
  head: createDOMFactory('head'),
  header: createDOMFactory('header'),
  hgroup: createDOMFactory('hgroup'),
  hr: createDOMFactory('hr'),
  html: createDOMFactory('html'),
  i: createDOMFactory('i'),
  iframe: createDOMFactory('iframe'),
  img: createDOMFactory('img'),
  input: createDOMFactory('input'),
  ins: createDOMFactory('ins'),
  kbd: createDOMFactory('kbd'),
  keygen: createDOMFactory('keygen'),
  label: createDOMFactory('label'),
  legend: createDOMFactory('legend'),
  li: createDOMFactory('li'),
  link: createDOMFactory('link'),
  main: createDOMFactory('main'),
  map: createDOMFactory('map'),
  mark: createDOMFactory('mark'),
  menu: createDOMFactory('menu'),
  menuitem: createDOMFactory('menuitem'),
  meta: createDOMFactory('meta'),
  meter: createDOMFactory('meter'),
  nav: createDOMFactory('nav'),
  noscript: createDOMFactory('noscript'),
  object: createDOMFactory('object'),
  ol: createDOMFactory('ol'),
  optgroup: createDOMFactory('optgroup'),
  option: createDOMFactory('option'),
  output: createDOMFactory('output'),
  p: createDOMFactory('p'),
  param: createDOMFactory('param'),
  picture: createDOMFactory('picture'),
  pre: createDOMFactory('pre'),
  progress: createDOMFactory('progress'),
  q: createDOMFactory('q'),
  rp: createDOMFactory('rp'),
  rt: createDOMFactory('rt'),
  ruby: createDOMFactory('ruby'),
  s: createDOMFactory('s'),
  samp: createDOMFactory('samp'),
  script: createDOMFactory('script'),
  section: createDOMFactory('section'),
  select: createDOMFactory('select'),
  small: createDOMFactory('small'),
  source: createDOMFactory('source'),
  span: createDOMFactory('span'),
  strong: createDOMFactory('strong'),
  style: createDOMFactory('style'),
  sub: createDOMFactory('sub'),
  summary: createDOMFactory('summary'),
  sup: createDOMFactory('sup'),
  table: createDOMFactory('table'),
  tbody: createDOMFactory('tbody'),
  td: createDOMFactory('td'),
  textarea: createDOMFactory('textarea'),
  tfoot: createDOMFactory('tfoot'),
  th: createDOMFactory('th'),
  thead: createDOMFactory('thead'),
  time: createDOMFactory('time'),
  title: createDOMFactory('title'),
  tr: createDOMFactory('tr'),
  track: createDOMFactory('track'),
  u: createDOMFactory('u'),
  ul: createDOMFactory('ul'),
  'var': createDOMFactory('var'),
  video: createDOMFactory('video'),
  wbr: createDOMFactory('wbr'),
  circle: createDOMFactory('circle'),
  clipPath: createDOMFactory('clipPath'),
  defs: createDOMFactory('defs'),
  ellipse: createDOMFactory('ellipse'),
  g: createDOMFactory('g'),
  image: createDOMFactory('image'),
  line: createDOMFactory('line'),
  linearGradient: createDOMFactory('linearGradient'),
  mask: createDOMFactory('mask'),
  path: createDOMFactory('path'),
  pattern: createDOMFactory('pattern'),
  polygon: createDOMFactory('polygon'),
  polyline: createDOMFactory('polyline'),
  radialGradient: createDOMFactory('radialGradient'),
  rect: createDOMFactory('rect'),
  stop: createDOMFactory('stop'),
  svg: createDOMFactory('svg'),
  text: createDOMFactory('text'),
  tspan: createDOMFactory('tspan')
};
var ReactDOMFactories_1 = ReactDOMFactories$1;

var ReactElement$6 = ReactElement_1;
var ReactPropTypeLocationNames$3 = ReactPropTypeLocationNames_1;
var ReactPropTypesSecret$2 = ReactPropTypesSecret_1;
var emptyFunction$3 = emptyFunction_1;
var getIteratorFn$3 = getIteratorFn_1;
var warning$10 = warning_1;
var ANONYMOUS = '<<anonymous>>';
var ReactPropTypes$1 = {
  array: createPrimitiveTypeChecker('array'),
  bool: createPrimitiveTypeChecker('boolean'),
  func: createPrimitiveTypeChecker('function'),
  number: createPrimitiveTypeChecker('number'),
  object: createPrimitiveTypeChecker('object'),
  string: createPrimitiveTypeChecker('string'),
  symbol: createPrimitiveTypeChecker('symbol'),
  any: createAnyTypeChecker(),
  arrayOf: createArrayOfTypeChecker,
  element: createElementTypeChecker(),
  instanceOf: createInstanceTypeChecker,
  node: createNodeChecker(),
  objectOf: createObjectOfTypeChecker,
  oneOf: createEnumTypeChecker,
  oneOfType: createUnionTypeChecker,
  shape: createShapeTypeChecker
};
function is(x, y) {
  if (x === y) {
    return x !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}
function PropTypeError(message) {
  this.message = message;
  this.stack = '';
}
PropTypeError.prototype = Error.prototype;
function createChainableTypeChecker(validate) {
  if (undefined !== 'production') {
    var manualPropTypeCallCache = {};
  }
  function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
    componentName = componentName || ANONYMOUS;
    propFullName = propFullName || propName;
    if (undefined !== 'production') {
      if (secret !== ReactPropTypesSecret$2 && typeof console !== 'undefined') {
        var cacheKey = componentName + ':' + propName;
        if (!manualPropTypeCallCache[cacheKey]) {
          undefined !== 'production' ? warning$10(false, 'You are manually calling a React.PropTypes validation ' + 'function for the `%s` prop on `%s`. This is deprecated ' + 'and will not work in production with the next major version. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.', propFullName, componentName) : void 0;
          manualPropTypeCallCache[cacheKey] = true;
        }
      }
    }
    if (props[propName] == null) {
      var locationName = ReactPropTypeLocationNames$3[location];
      if (isRequired) {
        if (props[propName] === null) {
          return new PropTypeError('The ' + locationName + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
        }
        return new PropTypeError('The ' + locationName + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
      }
      return null;
    } else {
      return validate(props, propName, componentName, location, propFullName);
    }
  }
  var chainedCheckType = checkType.bind(null, false);
  chainedCheckType.isRequired = checkType.bind(null, true);
  return chainedCheckType;
}
function createPrimitiveTypeChecker(expectedType) {
  function validate(props, propName, componentName, location, propFullName, secret) {
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== expectedType) {
      var locationName = ReactPropTypeLocationNames$3[location];
      var preciseType = getPreciseType(propValue);
      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}
function createAnyTypeChecker() {
  return createChainableTypeChecker(emptyFunction$3.thatReturns(null));
}
function createArrayOfTypeChecker(typeChecker) {
  function validate(props, propName, componentName, location, propFullName) {
    if (typeof typeChecker !== 'function') {
      return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
    }
    var propValue = props[propName];
    if (!Array.isArray(propValue)) {
      var locationName = ReactPropTypeLocationNames$3[location];
      var propType = getPropType(propValue);
      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
    }
    for (var i = 0; i < propValue.length; i++) {
      var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret$2);
      if (error instanceof Error) {
        return error;
      }
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}
function createElementTypeChecker() {
  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    if (!ReactElement$6.isValidElement(propValue)) {
      var locationName = ReactPropTypeLocationNames$3[location];
      var propType = getPropType(propValue);
      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}
function createInstanceTypeChecker(expectedClass) {
  function validate(props, propName, componentName, location, propFullName) {
    if (!(props[propName] instanceof expectedClass)) {
      var locationName = ReactPropTypeLocationNames$3[location];
      var expectedClassName = expectedClass.name || ANONYMOUS;
      var actualClassName = getClassName(props[propName]);
      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}
function createEnumTypeChecker(expectedValues) {
  if (!Array.isArray(expectedValues)) {
    undefined !== 'production' ? warning$10(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
    return emptyFunction$3.thatReturnsNull;
  }
  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    for (var i = 0; i < expectedValues.length; i++) {
      if (is(propValue, expectedValues[i])) {
        return null;
      }
    }
    var locationName = ReactPropTypeLocationNames$3[location];
    var valuesString = JSON.stringify(expectedValues);
    return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
  }
  return createChainableTypeChecker(validate);
}
function createObjectOfTypeChecker(typeChecker) {
  function validate(props, propName, componentName, location, propFullName) {
    if (typeof typeChecker !== 'function') {
      return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
    }
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== 'object') {
      var locationName = ReactPropTypeLocationNames$3[location];
      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
    }
    for (var key in propValue) {
      if (propValue.hasOwnProperty(key)) {
        var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret$2);
        if (error instanceof Error) {
          return error;
        }
      }
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}
function createUnionTypeChecker(arrayOfTypeCheckers) {
  if (!Array.isArray(arrayOfTypeCheckers)) {
    undefined !== 'production' ? warning$10(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
    return emptyFunction$3.thatReturnsNull;
  }
  function validate(props, propName, componentName, location, propFullName) {
    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret$2) == null) {
        return null;
      }
    }
    var locationName = ReactPropTypeLocationNames$3[location];
    return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
  }
  return createChainableTypeChecker(validate);
}
function createNodeChecker() {
  function validate(props, propName, componentName, location, propFullName) {
    if (!isNode(props[propName])) {
      var locationName = ReactPropTypeLocationNames$3[location];
      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}
function createShapeTypeChecker(shapeTypes) {
  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== 'object') {
      var locationName = ReactPropTypeLocationNames$3[location];
      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
    }
    for (var key in shapeTypes) {
      var checker = shapeTypes[key];
      if (!checker) {
        continue;
      }
      var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret$2);
      if (error) {
        return error;
      }
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}
function isNode(propValue) {
  switch (typeof propValue) {
    case 'number':
    case 'string':
    case 'undefined':
      return true;
    case 'boolean':
      return !propValue;
    case 'object':
      if (Array.isArray(propValue)) {
        return propValue.every(isNode);
      }
      if (propValue === null || ReactElement$6.isValidElement(propValue)) {
        return true;
      }
      var iteratorFn = getIteratorFn$3(propValue);
      if (iteratorFn) {
        var iterator = iteratorFn.call(propValue);
        var step;
        if (iteratorFn !== propValue.entries) {
          while (!(step = iterator.next()).done) {
            if (!isNode(step.value)) {
              return false;
            }
          }
        } else {
          while (!(step = iterator.next()).done) {
            var entry = step.value;
            if (entry) {
              if (!isNode(entry[1])) {
                return false;
              }
            }
          }
        }
      } else {
        return false;
      }
      return true;
    default:
      return false;
  }
}
function isSymbol(propType, propValue) {
  if (propType === 'symbol') {
    return true;
  }
  if (propValue['@@toStringTag'] === 'Symbol') {
    return true;
  }
  if (typeof Symbol === 'function' && propValue instanceof Symbol) {
    return true;
  }
  return false;
}
function getPropType(propValue) {
  var propType = typeof propValue;
  if (Array.isArray(propValue)) {
    return 'array';
  }
  if (propValue instanceof RegExp) {
    return 'object';
  }
  if (isSymbol(propType, propValue)) {
    return 'symbol';
  }
  return propType;
}
function getPreciseType(propValue) {
  var propType = getPropType(propValue);
  if (propType === 'object') {
    if (propValue instanceof Date) {
      return 'date';
    } else if (propValue instanceof RegExp) {
      return 'regexp';
    }
  }
  return propType;
}
function getClassName(propValue) {
  if (!propValue.constructor || !propValue.constructor.name) {
    return ANONYMOUS;
  }
  return propValue.constructor.name;
}
var ReactPropTypes_1 = ReactPropTypes$1;

var ReactVersion$1 = '15.4.2';

var _prodInvariant$6 = reactProdInvariant_1;
var ReactElement$7 = ReactElement_1;
var invariant$7 = invariant_1;
function onlyChild$1(children) {
  !ReactElement$7.isValidElement(children) ? undefined !== 'production' ? invariant$7(false, 'React.Children.only expected to receive a single React element child.') : _prodInvariant$6('143') : void 0;
  return children;
}
var onlyChild_1 = onlyChild$1;

var _assign = index;
var ReactChildren = ReactChildren_1;
var ReactComponent = ReactComponent_1;
var ReactPureComponent = ReactPureComponent_1;
var ReactClass = ReactClass_1;
var ReactDOMFactories = ReactDOMFactories_1;
var ReactElement = ReactElement_1;
var ReactPropTypes = ReactPropTypes_1;
var ReactVersion = ReactVersion$1;
var onlyChild = onlyChild_1;
var warning = warning_1;
var createElement = ReactElement.createElement;
var createFactory = ReactElement.createFactory;
var cloneElement = ReactElement.cloneElement;
if (undefined !== 'production') {
  var ReactElementValidator = ReactElementValidator_1;
  createElement = ReactElementValidator.createElement;
  createFactory = ReactElementValidator.createFactory;
  cloneElement = ReactElementValidator.cloneElement;
}
var __spread = _assign;
if (undefined !== 'production') {
  var warned = false;
  __spread = function () {
    undefined !== 'production' ? warning(warned, 'React.__spread is deprecated and should not be used. Use ' + 'Object.assign directly or another helper function with similar ' + 'semantics. You may be seeing this warning due to your compiler. ' + 'See https://fb.me/react-spread-deprecation for more details.') : void 0;
    warned = true;
    return _assign.apply(null, arguments);
  };
}
var React$1 = {
  Children: {
    map: ReactChildren.map,
    forEach: ReactChildren.forEach,
    count: ReactChildren.count,
    toArray: ReactChildren.toArray,
    only: onlyChild
  },
  Component: ReactComponent,
  PureComponent: ReactPureComponent,
  createElement: createElement,
  cloneElement: cloneElement,
  isValidElement: ReactElement.isValidElement,
  PropTypes: ReactPropTypes,
  createClass: ReactClass.createClass,
  createFactory: createFactory,
  createMixin: function (mixin) {
    return mixin;
  },
  DOM: ReactDOMFactories,
  version: ReactVersion,
  __spread: __spread
};
var React_1 = React$1;

var react = React_1;

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};





function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

function reactProdInvariant$1(code) {
  var argCount = arguments.length - 1;
  var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;
  for (var argIdx = 0; argIdx < argCount; argIdx++) {
    message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
  }
  message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';
  var error = new Error(message);
  error.name = 'Invariant Violation';
  error.framesToPop = 1;
  throw error;
}
var reactProdInvariant_1$2 = reactProdInvariant$1;

var _prodInvariant$8 = reactProdInvariant_1$2;
var invariant$9 = invariant_1;
var injected = false;
var ReactComponentEnvironment$1 = {
  replaceNodeWithMarkup: null,
  processChildrenUpdates: null,
  injection: {
    injectEnvironment: function (environment) {
      !!injected ? undefined !== 'production' ? invariant$9(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : _prodInvariant$8('104') : void 0;
      ReactComponentEnvironment$1.replaceNodeWithMarkup = environment.replaceNodeWithMarkup;
      ReactComponentEnvironment$1.processChildrenUpdates = environment.processChildrenUpdates;
      injected = true;
    }
  }
};
var ReactComponentEnvironment_1 = ReactComponentEnvironment$1;

var _prodInvariant$11 = reactProdInvariant_1$2;
var invariant$12 = invariant_1;
var oneArgumentPooler$1 = function (copyFieldsFrom) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, copyFieldsFrom);
    return instance;
  } else {
    return new Klass(copyFieldsFrom);
  }
};
var twoArgumentPooler$2 = function (a1, a2) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2);
    return instance;
  } else {
    return new Klass(a1, a2);
  }
};
var threeArgumentPooler$1 = function (a1, a2, a3) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3);
    return instance;
  } else {
    return new Klass(a1, a2, a3);
  }
};
var fourArgumentPooler$2 = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
};
var standardReleaser$1 = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? undefined !== 'production' ? invariant$12(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant$11('25') : void 0;
  instance.destructor();
  if (Klass.instancePool.length < Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
};
var DEFAULT_POOL_SIZE$1 = 10;
var DEFAULT_POOLER$1 = oneArgumentPooler$1;
var addPoolingTo$1 = function (CopyConstructor, pooler) {
  var NewKlass = CopyConstructor;
  NewKlass.instancePool = [];
  NewKlass.getPooled = pooler || DEFAULT_POOLER$1;
  if (!NewKlass.poolSize) {
    NewKlass.poolSize = DEFAULT_POOL_SIZE$1;
  }
  NewKlass.release = standardReleaser$1;
  return NewKlass;
};
var PooledClass$4 = {
  addPoolingTo: addPoolingTo$1,
  oneArgumentPooler: oneArgumentPooler$1,
  twoArgumentPooler: twoArgumentPooler$2,
  threeArgumentPooler: threeArgumentPooler$1,
  fourArgumentPooler: fourArgumentPooler$2
};
var PooledClass_1$2 = PooledClass$4;

var _prodInvariant$10 = reactProdInvariant_1$2;
function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var PooledClass$3 = PooledClass_1$2;
var invariant$11 = invariant_1;
var CallbackQueue$1 = function () {
  function CallbackQueue(arg) {
    _classCallCheck$1(this, CallbackQueue);
    this._callbacks = null;
    this._contexts = null;
    this._arg = arg;
  }
  CallbackQueue.prototype.enqueue = function enqueue(callback, context) {
    this._callbacks = this._callbacks || [];
    this._callbacks.push(callback);
    this._contexts = this._contexts || [];
    this._contexts.push(context);
  };
  CallbackQueue.prototype.notifyAll = function notifyAll() {
    var callbacks = this._callbacks;
    var contexts = this._contexts;
    var arg = this._arg;
    if (callbacks && contexts) {
      !(callbacks.length === contexts.length) ? undefined !== 'production' ? invariant$11(false, 'Mismatched list of contexts in callback queue') : _prodInvariant$10('24') : void 0;
      this._callbacks = null;
      this._contexts = null;
      for (var i = 0; i < callbacks.length; i++) {
        callbacks[i].call(contexts[i], arg);
      }
      callbacks.length = 0;
      contexts.length = 0;
    }
  };
  CallbackQueue.prototype.checkpoint = function checkpoint() {
    return this._callbacks ? this._callbacks.length : 0;
  };
  CallbackQueue.prototype.rollback = function rollback(len) {
    if (this._callbacks && this._contexts) {
      this._callbacks.length = len;
      this._contexts.length = len;
    }
  };
  CallbackQueue.prototype.reset = function reset() {
    this._callbacks = null;
    this._contexts = null;
  };
  CallbackQueue.prototype.destructor = function destructor() {
    this.reset();
  };
  return CallbackQueue;
}();
var CallbackQueue_1 = PooledClass$3.addPoolingTo(CallbackQueue$1);

var ReactFeatureFlags$1 = {
  logTopLevelRenders: false
};
var ReactFeatureFlags_1 = ReactFeatureFlags$1;

var _prodInvariant$12 = reactProdInvariant_1$2;
var invariant$13 = invariant_1;
function isValidOwner(object) {
  return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
}
var ReactOwner$1 = {
  addComponentAsRefTo: function (component, ref, owner) {
    !isValidOwner(owner) ? undefined !== 'production' ? invariant$13(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might be adding a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant$12('119') : void 0;
    owner.attachRef(ref, component);
  },
  removeComponentAsRefFrom: function (component, ref, owner) {
    !isValidOwner(owner) ? undefined !== 'production' ? invariant$13(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might be removing a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant$12('120') : void 0;
    var ownerPublicInstance = owner.getPublicInstance();
    if (ownerPublicInstance && ownerPublicInstance.refs[ref] === component.getPublicInstance()) {
      owner.detachRef(ref);
    }
  }
};
var ReactOwner_1 = ReactOwner$1;

var ReactOwner = ReactOwner_1;
var ReactRef$1 = {};
function attachRef(ref, component, owner) {
  if (typeof ref === 'function') {
    ref(component.getPublicInstance());
  } else {
    ReactOwner.addComponentAsRefTo(component, ref, owner);
  }
}
function detachRef(ref, component, owner) {
  if (typeof ref === 'function') {
    ref(null);
  } else {
    ReactOwner.removeComponentAsRefFrom(component, ref, owner);
  }
}
ReactRef$1.attachRefs = function (instance, element) {
  if (element === null || typeof element !== 'object') {
    return;
  }
  var ref = element.ref;
  if (ref != null) {
    attachRef(ref, instance, element._owner);
  }
};
ReactRef$1.shouldUpdateRefs = function (prevElement, nextElement) {
  var prevRef = null;
  var prevOwner = null;
  if (prevElement !== null && typeof prevElement === 'object') {
    prevRef = prevElement.ref;
    prevOwner = prevElement._owner;
  }
  var nextRef = null;
  var nextOwner = null;
  if (nextElement !== null && typeof nextElement === 'object') {
    nextRef = nextElement.ref;
    nextOwner = nextElement._owner;
  }
  return prevRef !== nextRef ||
  typeof nextRef === 'string' && nextOwner !== prevOwner;
};
ReactRef$1.detachRefs = function (instance, element) {
  if (element === null || typeof element !== 'object') {
    return;
  }
  var ref = element.ref;
  if (ref != null) {
    detachRef(ref, instance, element._owner);
  }
};
var ReactRef_1 = ReactRef$1;

var warning$13 = warning_1;
if (undefined !== 'production') {
  var processingChildContext = false;
  var warnInvalidSetState = function () {
    undefined !== 'production' ? warning$13(!processingChildContext, 'setState(...): Cannot call setState() inside getChildContext()') : void 0;
  };
}
var ReactInvalidSetStateWarningHook$1 = {
  onBeginProcessingChildContext: function () {
    processingChildContext = true;
  },
  onEndProcessingChildContext: function () {
    processingChildContext = false;
  },
  onSetState: function () {
    warnInvalidSetState();
  }
};
var ReactInvalidSetStateWarningHook_1 = ReactInvalidSetStateWarningHook$1;

var history = [];
var ReactHostOperationHistoryHook$1 = {
  onHostOperation: function (operation) {
    history.push(operation);
  },
  clearHistory: function () {
    if (ReactHostOperationHistoryHook$1._preventClearing) {
      return;
    }
    history = [];
  },
  getHistory: function () {
    return history;
  }
};
var ReactHostOperationHistoryHook_1 = ReactHostOperationHistoryHook$1;

var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
var ExecutionEnvironment$1 = {
  canUseDOM: canUseDOM,
  canUseWorkers: typeof Worker !== 'undefined',
  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
  canUseViewport: canUseDOM && !!window.screen,
  isInWorker: !canUseDOM
};
var ExecutionEnvironment_1 = ExecutionEnvironment$1;

var ExecutionEnvironment$2 = ExecutionEnvironment_1;
var performance$2;
if (ExecutionEnvironment$2.canUseDOM) {
  performance$2 = window.performance || window.msPerformance || window.webkitPerformance;
}
var performance_1 = performance$2 || {};

var performance$1 = performance_1;
var performanceNow$1;
if (performance$1.now) {
  performanceNow$1 = function performanceNow() {
    return performance$1.now();
  };
} else {
  performanceNow$1 = function performanceNow() {
    return Date.now();
  };
}
var performanceNow_1 = performanceNow$1;

var ReactInvalidSetStateWarningHook = ReactInvalidSetStateWarningHook_1;
var ReactHostOperationHistoryHook = ReactHostOperationHistoryHook_1;
var ReactComponentTreeHook$3 = ReactComponentTreeHook_1;
var ExecutionEnvironment = ExecutionEnvironment_1;
var performanceNow = performanceNow_1;
var warning$12 = warning_1;
var hooks = [];
var didHookThrowForEvent = {};
function callHook(event, fn, context, arg1, arg2, arg3, arg4, arg5) {
  try {
    fn.call(context, arg1, arg2, arg3, arg4, arg5);
  } catch (e) {
    undefined !== 'production' ? warning$12(didHookThrowForEvent[event], 'Exception thrown by hook while handling %s: %s', event, e + '\n' + e.stack) : void 0;
    didHookThrowForEvent[event] = true;
  }
}
function emitEvent(event, arg1, arg2, arg3, arg4, arg5) {
  for (var i = 0; i < hooks.length; i++) {
    var hook = hooks[i];
    var fn = hook[event];
    if (fn) {
      callHook(event, fn, hook, arg1, arg2, arg3, arg4, arg5);
    }
  }
}
var isProfiling = false;
var flushHistory = [];
var lifeCycleTimerStack = [];
var currentFlushNesting = 0;
var currentFlushMeasurements = [];
var currentFlushStartTime = 0;
var currentTimerDebugID = null;
var currentTimerStartTime = 0;
var currentTimerNestedFlushDuration = 0;
var currentTimerType = null;
var lifeCycleTimerHasWarned = false;
function clearHistory() {
  ReactComponentTreeHook$3.purgeUnmountedComponents();
  ReactHostOperationHistoryHook.clearHistory();
}
function getTreeSnapshot(registeredIDs) {
  return registeredIDs.reduce(function (tree, id) {
    var ownerID = ReactComponentTreeHook$3.getOwnerID(id);
    var parentID = ReactComponentTreeHook$3.getParentID(id);
    tree[id] = {
      displayName: ReactComponentTreeHook$3.getDisplayName(id),
      text: ReactComponentTreeHook$3.getText(id),
      updateCount: ReactComponentTreeHook$3.getUpdateCount(id),
      childIDs: ReactComponentTreeHook$3.getChildIDs(id),
      ownerID: ownerID || parentID && ReactComponentTreeHook$3.getOwnerID(parentID) || 0,
      parentID: parentID
    };
    return tree;
  }, {});
}
function resetMeasurements() {
  var previousStartTime = currentFlushStartTime;
  var previousMeasurements = currentFlushMeasurements;
  var previousOperations = ReactHostOperationHistoryHook.getHistory();
  if (currentFlushNesting === 0) {
    currentFlushStartTime = 0;
    currentFlushMeasurements = [];
    clearHistory();
    return;
  }
  if (previousMeasurements.length || previousOperations.length) {
    var registeredIDs = ReactComponentTreeHook$3.getRegisteredIDs();
    flushHistory.push({
      duration: performanceNow() - previousStartTime,
      measurements: previousMeasurements || [],
      operations: previousOperations || [],
      treeSnapshot: getTreeSnapshot(registeredIDs)
    });
  }
  clearHistory();
  currentFlushStartTime = performanceNow();
  currentFlushMeasurements = [];
}
function checkDebugID(debugID) {
  var allowRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  if (allowRoot && debugID === 0) {
    return;
  }
  if (!debugID) {
    undefined !== 'production' ? warning$12(false, 'ReactDebugTool: debugID may not be empty.') : void 0;
  }
}
function beginLifeCycleTimer(debugID, timerType) {
  if (currentFlushNesting === 0) {
    return;
  }
  if (currentTimerType && !lifeCycleTimerHasWarned) {
    undefined !== 'production' ? warning$12(false, 'There is an internal error in the React performance measurement code. ' + 'Did not expect %s timer to start while %s timer is still in ' + 'progress for %s instance.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
    lifeCycleTimerHasWarned = true;
  }
  currentTimerStartTime = performanceNow();
  currentTimerNestedFlushDuration = 0;
  currentTimerDebugID = debugID;
  currentTimerType = timerType;
}
function endLifeCycleTimer(debugID, timerType) {
  if (currentFlushNesting === 0) {
    return;
  }
  if (currentTimerType !== timerType && !lifeCycleTimerHasWarned) {
    undefined !== 'production' ? warning$12(false, 'There is an internal error in the React performance measurement code. ' + 'We did not expect %s timer to stop while %s timer is still in ' + 'progress for %s instance. Please report this as a bug in React.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
    lifeCycleTimerHasWarned = true;
  }
  if (isProfiling) {
    currentFlushMeasurements.push({
      timerType: timerType,
      instanceID: debugID,
      duration: performanceNow() - currentTimerStartTime - currentTimerNestedFlushDuration
    });
  }
  currentTimerStartTime = 0;
  currentTimerNestedFlushDuration = 0;
  currentTimerDebugID = null;
  currentTimerType = null;
}
function pauseCurrentLifeCycleTimer() {
  var currentTimer = {
    startTime: currentTimerStartTime,
    nestedFlushStartTime: performanceNow(),
    debugID: currentTimerDebugID,
    timerType: currentTimerType
  };
  lifeCycleTimerStack.push(currentTimer);
  currentTimerStartTime = 0;
  currentTimerNestedFlushDuration = 0;
  currentTimerDebugID = null;
  currentTimerType = null;
}
function resumeCurrentLifeCycleTimer() {
  var _lifeCycleTimerStack$ = lifeCycleTimerStack.pop(),
      startTime = _lifeCycleTimerStack$.startTime,
      nestedFlushStartTime = _lifeCycleTimerStack$.nestedFlushStartTime,
      debugID = _lifeCycleTimerStack$.debugID,
      timerType = _lifeCycleTimerStack$.timerType;
  var nestedFlushDuration = performanceNow() - nestedFlushStartTime;
  currentTimerStartTime = startTime;
  currentTimerNestedFlushDuration += nestedFlushDuration;
  currentTimerDebugID = debugID;
  currentTimerType = timerType;
}
var lastMarkTimeStamp = 0;
var canUsePerformanceMeasure =
typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';
function shouldMark(debugID) {
  if (!isProfiling || !canUsePerformanceMeasure) {
    return false;
  }
  var element = ReactComponentTreeHook$3.getElement(debugID);
  if (element == null || typeof element !== 'object') {
    return false;
  }
  var isHostElement = typeof element.type === 'string';
  if (isHostElement) {
    return false;
  }
  return true;
}
function markBegin(debugID, markType) {
  if (!shouldMark(debugID)) {
    return;
  }
  var markName = debugID + '::' + markType;
  lastMarkTimeStamp = performanceNow();
  performance.mark(markName);
}
function markEnd(debugID, markType) {
  if (!shouldMark(debugID)) {
    return;
  }
  var markName = debugID + '::' + markType;
  var displayName = ReactComponentTreeHook$3.getDisplayName(debugID) || 'Unknown';
  var timeStamp = performanceNow();
  if (timeStamp - lastMarkTimeStamp > 0.1) {
    var measurementName = displayName + ' [' + markType + ']';
    performance.measure(measurementName, markName);
  }
  performance.clearMarks(markName);
  performance.clearMeasures(measurementName);
}
var ReactDebugTool$1 = {
  addHook: function (hook) {
    hooks.push(hook);
  },
  removeHook: function (hook) {
    for (var i = 0; i < hooks.length; i++) {
      if (hooks[i] === hook) {
        hooks.splice(i, 1);
        i--;
      }
    }
  },
  isProfiling: function () {
    return isProfiling;
  },
  beginProfiling: function () {
    if (isProfiling) {
      return;
    }
    isProfiling = true;
    flushHistory.length = 0;
    resetMeasurements();
    ReactDebugTool$1.addHook(ReactHostOperationHistoryHook);
  },
  endProfiling: function () {
    if (!isProfiling) {
      return;
    }
    isProfiling = false;
    resetMeasurements();
    ReactDebugTool$1.removeHook(ReactHostOperationHistoryHook);
  },
  getFlushHistory: function () {
    return flushHistory;
  },
  onBeginFlush: function () {
    currentFlushNesting++;
    resetMeasurements();
    pauseCurrentLifeCycleTimer();
    emitEvent('onBeginFlush');
  },
  onEndFlush: function () {
    resetMeasurements();
    currentFlushNesting--;
    resumeCurrentLifeCycleTimer();
    emitEvent('onEndFlush');
  },
  onBeginLifeCycleTimer: function (debugID, timerType) {
    checkDebugID(debugID);
    emitEvent('onBeginLifeCycleTimer', debugID, timerType);
    markBegin(debugID, timerType);
    beginLifeCycleTimer(debugID, timerType);
  },
  onEndLifeCycleTimer: function (debugID, timerType) {
    checkDebugID(debugID);
    endLifeCycleTimer(debugID, timerType);
    markEnd(debugID, timerType);
    emitEvent('onEndLifeCycleTimer', debugID, timerType);
  },
  onBeginProcessingChildContext: function () {
    emitEvent('onBeginProcessingChildContext');
  },
  onEndProcessingChildContext: function () {
    emitEvent('onEndProcessingChildContext');
  },
  onHostOperation: function (operation) {
    checkDebugID(operation.instanceID);
    emitEvent('onHostOperation', operation);
  },
  onSetState: function () {
    emitEvent('onSetState');
  },
  onSetChildren: function (debugID, childDebugIDs) {
    checkDebugID(debugID);
    childDebugIDs.forEach(checkDebugID);
    emitEvent('onSetChildren', debugID, childDebugIDs);
  },
  onBeforeMountComponent: function (debugID, element, parentDebugID) {
    checkDebugID(debugID);
    checkDebugID(parentDebugID, true);
    emitEvent('onBeforeMountComponent', debugID, element, parentDebugID);
    markBegin(debugID, 'mount');
  },
  onMountComponent: function (debugID) {
    checkDebugID(debugID);
    markEnd(debugID, 'mount');
    emitEvent('onMountComponent', debugID);
  },
  onBeforeUpdateComponent: function (debugID, element) {
    checkDebugID(debugID);
    emitEvent('onBeforeUpdateComponent', debugID, element);
    markBegin(debugID, 'update');
  },
  onUpdateComponent: function (debugID) {
    checkDebugID(debugID);
    markEnd(debugID, 'update');
    emitEvent('onUpdateComponent', debugID);
  },
  onBeforeUnmountComponent: function (debugID) {
    checkDebugID(debugID);
    emitEvent('onBeforeUnmountComponent', debugID);
    markBegin(debugID, 'unmount');
  },
  onUnmountComponent: function (debugID) {
    checkDebugID(debugID);
    markEnd(debugID, 'unmount');
    emitEvent('onUnmountComponent', debugID);
  },
  onTestEvent: function () {
    emitEvent('onTestEvent');
  }
};
ReactDebugTool$1.addDevtool = ReactDebugTool$1.addHook;
ReactDebugTool$1.removeDevtool = ReactDebugTool$1.removeHook;
ReactDebugTool$1.addHook(ReactInvalidSetStateWarningHook);
ReactDebugTool$1.addHook(ReactComponentTreeHook$3);
var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
if (/[?&]react_perf\b/.test(url)) {
  ReactDebugTool$1.beginProfiling();
}
var ReactDebugTool_1 = ReactDebugTool$1;

var debugTool = null;
if (undefined !== 'production') {
  var ReactDebugTool = ReactDebugTool_1;
  debugTool = ReactDebugTool;
}
var ReactInstrumentation$1 = { debugTool: debugTool };

var ReactRef = ReactRef_1;
var ReactInstrumentation = ReactInstrumentation$1;
var warning$11 = warning_1;
function attachRefs() {
  ReactRef.attachRefs(this, this._currentElement);
}
var ReactReconciler$1 = {
  mountComponent: function (internalInstance, transaction, hostParent, hostContainerInfo, context, parentDebugID
  ) {
    if (undefined !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onBeforeMountComponent(internalInstance._debugID, internalInstance._currentElement, parentDebugID);
      }
    }
    var markup = internalInstance.mountComponent(transaction, hostParent, hostContainerInfo, context, parentDebugID);
    if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
    }
    if (undefined !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onMountComponent(internalInstance._debugID);
      }
    }
    return markup;
  },
  getHostNode: function (internalInstance) {
    return internalInstance.getHostNode();
  },
  unmountComponent: function (internalInstance, safely) {
    if (undefined !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onBeforeUnmountComponent(internalInstance._debugID);
      }
    }
    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
    internalInstance.unmountComponent(safely);
    if (undefined !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onUnmountComponent(internalInstance._debugID);
      }
    }
  },
  receiveComponent: function (internalInstance, nextElement, transaction, context) {
    var prevElement = internalInstance._currentElement;
    if (nextElement === prevElement && context === internalInstance._context) {
      return;
    }
    if (undefined !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, nextElement);
      }
    }
    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);
    if (refsChanged) {
      ReactRef.detachRefs(internalInstance, prevElement);
    }
    internalInstance.receiveComponent(nextElement, transaction, context);
    if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
    }
    if (undefined !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
      }
    }
  },
  performUpdateIfNecessary: function (internalInstance, transaction, updateBatchNumber) {
    if (internalInstance._updateBatchNumber !== updateBatchNumber) {
      undefined !== 'production' ? warning$11(internalInstance._updateBatchNumber == null || internalInstance._updateBatchNumber === updateBatchNumber + 1, 'performUpdateIfNecessary: Unexpected batch number (current %s, ' + 'pending %s)', updateBatchNumber, internalInstance._updateBatchNumber) : void 0;
      return;
    }
    if (undefined !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, internalInstance._currentElement);
      }
    }
    internalInstance.performUpdateIfNecessary(transaction);
    if (undefined !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
      }
    }
  }
};
var ReactReconciler_1 = ReactReconciler$1;

var _prodInvariant$13 = reactProdInvariant_1$2;
var invariant$14 = invariant_1;
var OBSERVED_ERROR = {};
var TransactionImpl = {
  reinitializeTransaction: function () {
    this.transactionWrappers = this.getTransactionWrappers();
    if (this.wrapperInitData) {
      this.wrapperInitData.length = 0;
    } else {
      this.wrapperInitData = [];
    }
    this._isInTransaction = false;
  },
  _isInTransaction: false,
  getTransactionWrappers: null,
  isInTransaction: function () {
    return !!this._isInTransaction;
  },
  perform: function (method, scope, a, b, c, d, e, f) {
    !!this.isInTransaction() ? undefined !== 'production' ? invariant$14(false, 'Transaction.perform(...): Cannot initialize a transaction when there is already an outstanding transaction.') : _prodInvariant$13('27') : void 0;
    var errorThrown;
    var ret;
    try {
      this._isInTransaction = true;
      errorThrown = true;
      this.initializeAll(0);
      ret = method.call(scope, a, b, c, d, e, f);
      errorThrown = false;
    } finally {
      try {
        if (errorThrown) {
          try {
            this.closeAll(0);
          } catch (err) {}
        } else {
          this.closeAll(0);
        }
      } finally {
        this._isInTransaction = false;
      }
    }
    return ret;
  },
  initializeAll: function (startIndex) {
    var transactionWrappers = this.transactionWrappers;
    for (var i = startIndex; i < transactionWrappers.length; i++) {
      var wrapper = transactionWrappers[i];
      try {
        this.wrapperInitData[i] = OBSERVED_ERROR;
        this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
      } finally {
        if (this.wrapperInitData[i] === OBSERVED_ERROR) {
          try {
            this.initializeAll(i + 1);
          } catch (err) {}
        }
      }
    }
  },
  closeAll: function (startIndex) {
    !this.isInTransaction() ? undefined !== 'production' ? invariant$14(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : _prodInvariant$13('28') : void 0;
    var transactionWrappers = this.transactionWrappers;
    for (var i = startIndex; i < transactionWrappers.length; i++) {
      var wrapper = transactionWrappers[i];
      var initData = this.wrapperInitData[i];
      var errorThrown;
      try {
        errorThrown = true;
        if (initData !== OBSERVED_ERROR && wrapper.close) {
          wrapper.close.call(this, initData);
        }
        errorThrown = false;
      } finally {
        if (errorThrown) {
          try {
            this.closeAll(i + 1);
          } catch (e) {}
        }
      }
    }
    this.wrapperInitData.length = 0;
  }
};
var Transaction$2 = TransactionImpl;

var _prodInvariant$9 = reactProdInvariant_1$2;
var _assign$6 = index;
var CallbackQueue = CallbackQueue_1;
var PooledClass$2 = PooledClass_1$2;
var ReactFeatureFlags = ReactFeatureFlags_1;
var ReactReconciler = ReactReconciler_1;
var Transaction$1 = Transaction$2;
var invariant$10 = invariant_1;
var dirtyComponents = [];
var updateBatchNumber = 0;
var asapCallbackQueue = CallbackQueue.getPooled();
var asapEnqueued = false;
var batchingStrategy = null;
function ensureInjected() {
  !(ReactUpdates$2.ReactReconcileTransaction && batchingStrategy) ? undefined !== 'production' ? invariant$10(false, 'ReactUpdates: must inject a reconcile transaction class and batching strategy') : _prodInvariant$9('123') : void 0;
}
var NESTED_UPDATES = {
  initialize: function () {
    this.dirtyComponentsLength = dirtyComponents.length;
  },
  close: function () {
    if (this.dirtyComponentsLength !== dirtyComponents.length) {
      dirtyComponents.splice(0, this.dirtyComponentsLength);
      flushBatchedUpdates();
    } else {
      dirtyComponents.length = 0;
    }
  }
};
var UPDATE_QUEUEING = {
  initialize: function () {
    this.callbackQueue.reset();
  },
  close: function () {
    this.callbackQueue.notifyAll();
  }
};
var TRANSACTION_WRAPPERS$1 = [NESTED_UPDATES, UPDATE_QUEUEING];
function ReactUpdatesFlushTransaction() {
  this.reinitializeTransaction();
  this.dirtyComponentsLength = null;
  this.callbackQueue = CallbackQueue.getPooled();
  this.reconcileTransaction = ReactUpdates$2.ReactReconcileTransaction.getPooled(
  /* useCreateElement */true);
}
_assign$6(ReactUpdatesFlushTransaction.prototype, Transaction$1, {
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS$1;
  },
  destructor: function () {
    this.dirtyComponentsLength = null;
    CallbackQueue.release(this.callbackQueue);
    this.callbackQueue = null;
    ReactUpdates$2.ReactReconcileTransaction.release(this.reconcileTransaction);
    this.reconcileTransaction = null;
  },
  perform: function (method, scope, a) {
    return Transaction$1.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
  }
});
PooledClass$2.addPoolingTo(ReactUpdatesFlushTransaction);
function batchedUpdates(callback, a, b, c, d, e) {
  ensureInjected();
  return batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
}
function mountOrderComparator(c1, c2) {
  return c1._mountOrder - c2._mountOrder;
}
function runBatchedUpdates(transaction) {
  var len = transaction.dirtyComponentsLength;
  !(len === dirtyComponents.length) ? undefined !== 'production' ? invariant$10(false, 'Expected flush transaction\'s stored dirty-components length (%s) to match dirty-components array length (%s).', len, dirtyComponents.length) : _prodInvariant$9('124', len, dirtyComponents.length) : void 0;
  dirtyComponents.sort(mountOrderComparator);
  updateBatchNumber++;
  for (var i = 0; i < len; i++) {
    var component = dirtyComponents[i];
    var callbacks = component._pendingCallbacks;
    component._pendingCallbacks = null;
    var markerName;
    if (ReactFeatureFlags.logTopLevelRenders) {
      var namedComponent = component;
      if (component._currentElement.type.isReactTopLevelWrapper) {
        namedComponent = component._renderedComponent;
      }
      markerName = 'React update: ' + namedComponent.getName();
      console.time(markerName);
    }
    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction, updateBatchNumber);
    if (markerName) {
      console.timeEnd(markerName);
    }
    if (callbacks) {
      for (var j = 0; j < callbacks.length; j++) {
        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
      }
    }
  }
}
var flushBatchedUpdates = function () {
  while (dirtyComponents.length || asapEnqueued) {
    if (dirtyComponents.length) {
      var transaction = ReactUpdatesFlushTransaction.getPooled();
      transaction.perform(runBatchedUpdates, null, transaction);
      ReactUpdatesFlushTransaction.release(transaction);
    }
    if (asapEnqueued) {
      asapEnqueued = false;
      var queue = asapCallbackQueue;
      asapCallbackQueue = CallbackQueue.getPooled();
      queue.notifyAll();
      CallbackQueue.release(queue);
    }
  }
};
function enqueueUpdate(component) {
  ensureInjected();
  if (!batchingStrategy.isBatchingUpdates) {
    batchingStrategy.batchedUpdates(enqueueUpdate, component);
    return;
  }
  dirtyComponents.push(component);
  if (component._updateBatchNumber == null) {
    component._updateBatchNumber = updateBatchNumber + 1;
  }
}
function asap(callback, context) {
  !batchingStrategy.isBatchingUpdates ? undefined !== 'production' ? invariant$10(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context whereupdates are not being batched.') : _prodInvariant$9('125') : void 0;
  asapCallbackQueue.enqueue(callback, context);
  asapEnqueued = true;
}
var ReactUpdatesInjection = {
  injectReconcileTransaction: function (ReconcileTransaction) {
    !ReconcileTransaction ? undefined !== 'production' ? invariant$10(false, 'ReactUpdates: must provide a reconcile transaction class') : _prodInvariant$9('126') : void 0;
    ReactUpdates$2.ReactReconcileTransaction = ReconcileTransaction;
  },
  injectBatchingStrategy: function (_batchingStrategy) {
    !_batchingStrategy ? undefined !== 'production' ? invariant$10(false, 'ReactUpdates: must provide a batching strategy') : _prodInvariant$9('127') : void 0;
    !(typeof _batchingStrategy.batchedUpdates === 'function') ? undefined !== 'production' ? invariant$10(false, 'ReactUpdates: must provide a batchedUpdates() function') : _prodInvariant$9('128') : void 0;
    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? undefined !== 'production' ? invariant$10(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : _prodInvariant$9('129') : void 0;
    batchingStrategy = _batchingStrategy;
  }
};
var ReactUpdates$2 = {
  ReactReconcileTransaction: null,
  batchedUpdates: batchedUpdates,
  enqueueUpdate: enqueueUpdate,
  flushBatchedUpdates: flushBatchedUpdates,
  injection: ReactUpdatesInjection,
  asap: asap
};
var ReactUpdates_1 = ReactUpdates$2;

var _assign$5 = index;
var ReactUpdates$1 = ReactUpdates_1;
var Transaction = Transaction$2;
var emptyFunction$4 = emptyFunction_1;
var RESET_BATCHED_UPDATES = {
  initialize: emptyFunction$4,
  close: function () {
    ReactDefaultBatchingStrategy$1.isBatchingUpdates = false;
  }
};
var FLUSH_BATCHED_UPDATES = {
  initialize: emptyFunction$4,
  close: ReactUpdates$1.flushBatchedUpdates.bind(ReactUpdates$1)
};
var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];
function ReactDefaultBatchingStrategyTransaction() {
  this.reinitializeTransaction();
}
_assign$5(ReactDefaultBatchingStrategyTransaction.prototype, Transaction, {
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  }
});
var transaction = new ReactDefaultBatchingStrategyTransaction();
var ReactDefaultBatchingStrategy$1 = {
  isBatchingUpdates: false,
  batchedUpdates: function (callback, a, b, c, d, e) {
    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy$1.isBatchingUpdates;
    ReactDefaultBatchingStrategy$1.isBatchingUpdates = true;
    if (alreadyBatchingUpdates) {
      return callback(a, b, c, d, e);
    } else {
      return transaction.perform(callback, null, a, b, c, d, e);
    }
  }
};
var ReactDefaultBatchingStrategy_1 = ReactDefaultBatchingStrategy$1;

var emptyComponentFactory;
var ReactEmptyComponentInjection = {
  injectEmptyComponentFactory: function (factory) {
    emptyComponentFactory = factory;
  }
};
var ReactEmptyComponent$1 = {
  create: function (instantiate) {
    return emptyComponentFactory(instantiate);
  }
};
ReactEmptyComponent$1.injection = ReactEmptyComponentInjection;
var ReactEmptyComponent_1 = ReactEmptyComponent$1;

var ReactInstanceMap$1 = {
  remove: function (key) {
    key._reactInternalInstance = undefined;
  },
  get: function (key) {
    return key._reactInternalInstance;
  },
  has: function (key) {
    return key._reactInternalInstance !== undefined;
  },
  set: function (key, value) {
    key._reactInternalInstance = value;
  }
};
var ReactInstanceMap_1 = ReactInstanceMap$1;

var caughtError = null;
function invokeGuardedCallback(name, func, a) {
  try {
    func(a);
  } catch (x) {
    if (caughtError === null) {
      caughtError = x;
    }
  }
}
var ReactErrorUtils$1 = {
  invokeGuardedCallback: invokeGuardedCallback,
  invokeGuardedCallbackWithCatch: invokeGuardedCallback,
  rethrowCaughtError: function () {
    if (caughtError) {
      var error = caughtError;
      caughtError = null;
      throw error;
    }
  }
};
if (undefined !== 'production') {
  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
    var fakeNode = document.createElement('react');
    ReactErrorUtils$1.invokeGuardedCallback = function (name, func, a) {
      var boundFunc = func.bind(null, a);
      var evtType = 'react-' + name;
      fakeNode.addEventListener(evtType, boundFunc, false);
      var evt = document.createEvent('Event');
      evt.initEvent(evtType, false, false);
      fakeNode.dispatchEvent(evt);
      fakeNode.removeEventListener(evtType, boundFunc, false);
    };
  }
}
var ReactErrorUtils_1 = ReactErrorUtils$1;

var _prodInvariant$17 = reactProdInvariant_1$2;
var React$3 = React_1;
var invariant$18 = invariant_1;
var ReactNodeTypes$1 = {
  HOST: 0,
  COMPOSITE: 1,
  EMPTY: 2,
  getType: function (node) {
    if (node === null || node === false) {
      return ReactNodeTypes$1.EMPTY;
    } else if (React$3.isValidElement(node)) {
      if (typeof node.type === 'function') {
        return ReactNodeTypes$1.COMPOSITE;
      } else {
        return ReactNodeTypes$1.HOST;
      }
    }
    undefined !== 'production' ? invariant$18(false, 'Unexpected node: %s', node) : _prodInvariant$17('26', node);
  }
};
var ReactNodeTypes_1 = ReactNodeTypes$1;

var ReactPropTypeLocationNames$5 = {};
if (undefined !== 'production') {
  ReactPropTypeLocationNames$5 = {
    prop: 'prop',
    context: 'context',
    childContext: 'child context'
  };
}
var ReactPropTypeLocationNames_1$2 = ReactPropTypeLocationNames$5;

var ReactPropTypesSecret$4 = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
var ReactPropTypesSecret_1$2 = ReactPropTypesSecret$4;

var _prodInvariant$18 = reactProdInvariant_1$2;
var ReactPropTypeLocationNames$4 = ReactPropTypeLocationNames_1$2;
var ReactPropTypesSecret$3 = ReactPropTypesSecret_1$2;
var invariant$19 = invariant_1;
var warning$17 = warning_1;
var ReactComponentTreeHook$5;
if (typeof process !== 'undefined' && process.env && undefined === 'test') {
  ReactComponentTreeHook$5 = ReactComponentTreeHook_1;
}
var loggedTypeFailures$1 = {};
function checkReactTypeSpec$3(typeSpecs, values, location, componentName, element, debugID) {
  for (var typeSpecName in typeSpecs) {
    if (typeSpecs.hasOwnProperty(typeSpecName)) {
      var error;
      try {
        !(typeof typeSpecs[typeSpecName] === 'function') ? undefined !== 'production' ? invariant$19(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames$4[location], typeSpecName) : _prodInvariant$18('84', componentName || 'React class', ReactPropTypeLocationNames$4[location], typeSpecName) : void 0;
        error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret$3);
      } catch (ex) {
        error = ex;
      }
      undefined !== 'production' ? warning$17(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames$4[location], typeSpecName, typeof error) : void 0;
      if (error instanceof Error && !(error.message in loggedTypeFailures$1)) {
        loggedTypeFailures$1[error.message] = true;
        var componentStackInfo = '';
        if (undefined !== 'production') {
          if (!ReactComponentTreeHook$5) {
            ReactComponentTreeHook$5 = ReactComponentTreeHook_1;
          }
          if (debugID !== null) {
            componentStackInfo = ReactComponentTreeHook$5.getStackAddendumByID(debugID);
          } else if (element !== null) {
            componentStackInfo = ReactComponentTreeHook$5.getCurrentStackAddendum(element);
          }
        }
        undefined !== 'production' ? warning$17(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
      }
    }
  }
}
var checkReactTypeSpec_1$2 = checkReactTypeSpec$3;

var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function is$1(x, y) {
  if (x === y) {
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}
function shallowEqual$1(objA, objB) {
  if (is$1(objA, objB)) {
    return true;
  }
  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }
  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) {
    return false;
  }
  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwnProperty$2.call(objB, keysA[i]) || !is$1(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }
  return true;
}
var shallowEqual_1 = shallowEqual$1;

function shouldUpdateReactComponent$2(prevElement, nextElement) {
  var prevEmpty = prevElement === null || prevElement === false;
  var nextEmpty = nextElement === null || nextElement === false;
  if (prevEmpty || nextEmpty) {
    return prevEmpty === nextEmpty;
  }
  var prevType = typeof prevElement;
  var nextType = typeof nextElement;
  if (prevType === 'string' || prevType === 'number') {
    return nextType === 'string' || nextType === 'number';
  } else {
    return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
  }
}
var shouldUpdateReactComponent_1 = shouldUpdateReactComponent$2;

var _prodInvariant$16 = reactProdInvariant_1$2;
var _assign$8 = index;
var React$2 = React_1;
var ReactComponentEnvironment$3 = ReactComponentEnvironment_1;
var ReactCurrentOwner$6 = ReactCurrentOwner_1;
var ReactErrorUtils = ReactErrorUtils_1;
var ReactInstanceMap$2 = ReactInstanceMap_1;
var ReactInstrumentation$4 = ReactInstrumentation$1;
var ReactNodeTypes = ReactNodeTypes_1;
var ReactReconciler$4 = ReactReconciler_1;
if (undefined !== 'production') {
  var checkReactTypeSpec$2 = checkReactTypeSpec_1$2;
}
var emptyObject$4 = emptyObject_1;
var invariant$17 = invariant_1;
var shallowEqual = shallowEqual_1;
var shouldUpdateReactComponent$1 = shouldUpdateReactComponent_1;
var warning$16 = warning_1;
var CompositeTypes = {
  ImpureClass: 0,
  PureClass: 1,
  StatelessFunctional: 2
};
function StatelessComponent(Component) {}
StatelessComponent.prototype.render = function () {
  var Component = ReactInstanceMap$2.get(this)._currentElement.type;
  var element = Component(this.props, this.context, this.updater);
  warnIfInvalidElement(Component, element);
  return element;
};
function warnIfInvalidElement(Component, element) {
  if (undefined !== 'production') {
    undefined !== 'production' ? warning$16(element === null || element === false || React$2.isValidElement(element), '%s(...): A valid React element (or null) must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : void 0;
    undefined !== 'production' ? warning$16(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component') : void 0;
  }
}
function shouldConstruct(Component) {
  return !!(Component.prototype && Component.prototype.isReactComponent);
}
function isPureComponent(Component) {
  return !!(Component.prototype && Component.prototype.isPureReactComponent);
}
function measureLifeCyclePerf(fn, debugID, timerType) {
  if (debugID === 0) {
    return fn();
  }
  ReactInstrumentation$4.debugTool.onBeginLifeCycleTimer(debugID, timerType);
  try {
    return fn();
  } finally {
    ReactInstrumentation$4.debugTool.onEndLifeCycleTimer(debugID, timerType);
  }
}
var nextMountID = 1;
var ReactCompositeComponent$1 = {
  construct: function (element) {
    this._currentElement = element;
    this._rootNodeID = 0;
    this._compositeType = null;
    this._instance = null;
    this._hostParent = null;
    this._hostContainerInfo = null;
    this._updateBatchNumber = null;
    this._pendingElement = null;
    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;
    this._renderedNodeType = null;
    this._renderedComponent = null;
    this._context = null;
    this._mountOrder = 0;
    this._topLevelWrapper = null;
    this._pendingCallbacks = null;
    this._calledComponentWillUnmount = false;
    if (undefined !== 'production') {
      this._warnedAboutRefsInRender = false;
    }
  },
  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
    var _this = this;
    this._context = context;
    this._mountOrder = nextMountID++;
    this._hostParent = hostParent;
    this._hostContainerInfo = hostContainerInfo;
    var publicProps = this._currentElement.props;
    var publicContext = this._processContext(context);
    var Component = this._currentElement.type;
    var updateQueue = transaction.getUpdateQueue();
    var doConstruct = shouldConstruct(Component);
    var inst = this._constructComponent(doConstruct, publicProps, publicContext, updateQueue);
    var renderedElement;
    if (!doConstruct && (inst == null || inst.render == null)) {
      renderedElement = inst;
      warnIfInvalidElement(Component, renderedElement);
      !(inst === null || inst === false || React$2.isValidElement(inst)) ? undefined !== 'production' ? invariant$17(false, '%s(...): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : _prodInvariant$16('105', Component.displayName || Component.name || 'Component') : void 0;
      inst = new StatelessComponent(Component);
      this._compositeType = CompositeTypes.StatelessFunctional;
    } else {
      if (isPureComponent(Component)) {
        this._compositeType = CompositeTypes.PureClass;
      } else {
        this._compositeType = CompositeTypes.ImpureClass;
      }
    }
    if (undefined !== 'production') {
      if (inst.render == null) {
        undefined !== 'production' ? warning$16(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', Component.displayName || Component.name || 'Component') : void 0;
      }
      var propsMutated = inst.props !== publicProps;
      var componentName = Component.displayName || Component.name || 'Component';
      undefined !== 'production' ? warning$16(inst.props === undefined || !propsMutated, '%s(...): When calling super() in `%s`, make sure to pass ' + 'up the same props that your component\'s constructor was passed.', componentName, componentName) : void 0;
    }
    inst.props = publicProps;
    inst.context = publicContext;
    inst.refs = emptyObject$4;
    inst.updater = updateQueue;
    this._instance = inst;
    ReactInstanceMap$2.set(inst, this);
    if (undefined !== 'production') {
      undefined !== 'production' ? warning$16(!inst.getInitialState || inst.getInitialState.isReactClassApproved || inst.state, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : void 0;
      undefined !== 'production' ? warning$16(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : void 0;
      undefined !== 'production' ? warning$16(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : void 0;
      undefined !== 'production' ? warning$16(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : void 0;
      undefined !== 'production' ? warning$16(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : void 0;
      undefined !== 'production' ? warning$16(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : void 0;
      undefined !== 'production' ? warning$16(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : void 0;
    }
    var initialState = inst.state;
    if (initialState === undefined) {
      inst.state = initialState = null;
    }
    !(typeof initialState === 'object' && !Array.isArray(initialState)) ? undefined !== 'production' ? invariant$17(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : _prodInvariant$16('106', this.getName() || 'ReactCompositeComponent') : void 0;
    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;
    var markup;
    if (inst.unstable_handleError) {
      markup = this.performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context);
    } else {
      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
    }
    if (inst.componentDidMount) {
      if (undefined !== 'production') {
        transaction.getReactMountReady().enqueue(function () {
          measureLifeCyclePerf(function () {
            return inst.componentDidMount();
          }, _this._debugID, 'componentDidMount');
        });
      } else {
        transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
      }
    }
    return markup;
  },
  _constructComponent: function (doConstruct, publicProps, publicContext, updateQueue) {
    if (undefined !== 'production') {
      ReactCurrentOwner$6.current = this;
      try {
        return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
      } finally {
        ReactCurrentOwner$6.current = null;
      }
    } else {
      return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
    }
  },
  _constructComponentWithoutOwner: function (doConstruct, publicProps, publicContext, updateQueue) {
    var Component = this._currentElement.type;
    if (doConstruct) {
      if (undefined !== 'production') {
        return measureLifeCyclePerf(function () {
          return new Component(publicProps, publicContext, updateQueue);
        }, this._debugID, 'ctor');
      } else {
        return new Component(publicProps, publicContext, updateQueue);
      }
    }
    if (undefined !== 'production') {
      return measureLifeCyclePerf(function () {
        return Component(publicProps, publicContext, updateQueue);
      }, this._debugID, 'render');
    } else {
      return Component(publicProps, publicContext, updateQueue);
    }
  },
  performInitialMountWithErrorHandling: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
    var markup;
    var checkpoint = transaction.checkpoint();
    try {
      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
    } catch (e) {
      transaction.rollback(checkpoint);
      this._instance.unstable_handleError(e);
      if (this._pendingStateQueue) {
        this._instance.state = this._processPendingState(this._instance.props, this._instance.context);
      }
      checkpoint = transaction.checkpoint();
      this._renderedComponent.unmountComponent(true);
      transaction.rollback(checkpoint);
      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
    }
    return markup;
  },
  performInitialMount: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
    var inst = this._instance;
    var debugID = 0;
    if (undefined !== 'production') {
      debugID = this._debugID;
    }
    if (inst.componentWillMount) {
      if (undefined !== 'production') {
        measureLifeCyclePerf(function () {
          return inst.componentWillMount();
        }, debugID, 'componentWillMount');
      } else {
        inst.componentWillMount();
      }
      if (this._pendingStateQueue) {
        inst.state = this._processPendingState(inst.props, inst.context);
      }
    }
    if (renderedElement === undefined) {
      renderedElement = this._renderValidatedComponent();
    }
    var nodeType = ReactNodeTypes.getType(renderedElement);
    this._renderedNodeType = nodeType;
    var child = this._instantiateReactComponent(renderedElement, nodeType !== ReactNodeTypes.EMPTY
    );
    this._renderedComponent = child;
    var markup = ReactReconciler$4.mountComponent(child, transaction, hostParent, hostContainerInfo, this._processChildContext(context), debugID);
    if (undefined !== 'production') {
      if (debugID !== 0) {
        var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
        ReactInstrumentation$4.debugTool.onSetChildren(debugID, childDebugIDs);
      }
    }
    return markup;
  },
  getHostNode: function () {
    return ReactReconciler$4.getHostNode(this._renderedComponent);
  },
  unmountComponent: function (safely) {
    if (!this._renderedComponent) {
      return;
    }
    var inst = this._instance;
    if (inst.componentWillUnmount && !inst._calledComponentWillUnmount) {
      inst._calledComponentWillUnmount = true;
      if (safely) {
        var name = this.getName() + '.componentWillUnmount()';
        ReactErrorUtils.invokeGuardedCallback(name, inst.componentWillUnmount.bind(inst));
      } else {
        if (undefined !== 'production') {
          measureLifeCyclePerf(function () {
            return inst.componentWillUnmount();
          }, this._debugID, 'componentWillUnmount');
        } else {
          inst.componentWillUnmount();
        }
      }
    }
    if (this._renderedComponent) {
      ReactReconciler$4.unmountComponent(this._renderedComponent, safely);
      this._renderedNodeType = null;
      this._renderedComponent = null;
      this._instance = null;
    }
    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;
    this._pendingCallbacks = null;
    this._pendingElement = null;
    this._context = null;
    this._rootNodeID = 0;
    this._topLevelWrapper = null;
    ReactInstanceMap$2.remove(inst);
  },
  _maskContext: function (context) {
    var Component = this._currentElement.type;
    var contextTypes = Component.contextTypes;
    if (!contextTypes) {
      return emptyObject$4;
    }
    var maskedContext = {};
    for (var contextName in contextTypes) {
      maskedContext[contextName] = context[contextName];
    }
    return maskedContext;
  },
  _processContext: function (context) {
    var maskedContext = this._maskContext(context);
    if (undefined !== 'production') {
      var Component = this._currentElement.type;
      if (Component.contextTypes) {
        this._checkContextTypes(Component.contextTypes, maskedContext, 'context');
      }
    }
    return maskedContext;
  },
  _processChildContext: function (currentContext) {
    var Component = this._currentElement.type;
    var inst = this._instance;
    var childContext;
    if (inst.getChildContext) {
      if (undefined !== 'production') {
        ReactInstrumentation$4.debugTool.onBeginProcessingChildContext();
        try {
          childContext = inst.getChildContext();
        } finally {
          ReactInstrumentation$4.debugTool.onEndProcessingChildContext();
        }
      } else {
        childContext = inst.getChildContext();
      }
    }
    if (childContext) {
      !(typeof Component.childContextTypes === 'object') ? undefined !== 'production' ? invariant$17(false, '%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().', this.getName() || 'ReactCompositeComponent') : _prodInvariant$16('107', this.getName() || 'ReactCompositeComponent') : void 0;
      if (undefined !== 'production') {
        this._checkContextTypes(Component.childContextTypes, childContext, 'childContext');
      }
      for (var name in childContext) {
        !(name in Component.childContextTypes) ? undefined !== 'production' ? invariant$17(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : _prodInvariant$16('108', this.getName() || 'ReactCompositeComponent', name) : void 0;
      }
      return _assign$8({}, currentContext, childContext);
    }
    return currentContext;
  },
  _checkContextTypes: function (typeSpecs, values, location) {
    if (undefined !== 'production') {
      checkReactTypeSpec$2(typeSpecs, values, location, this.getName(), null, this._debugID);
    }
  },
  receiveComponent: function (nextElement, transaction, nextContext) {
    var prevElement = this._currentElement;
    var prevContext = this._context;
    this._pendingElement = null;
    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
  },
  performUpdateIfNecessary: function (transaction) {
    if (this._pendingElement != null) {
      ReactReconciler$4.receiveComponent(this, this._pendingElement, transaction, this._context);
    } else if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
    } else {
      this._updateBatchNumber = null;
    }
  },
  updateComponent: function (transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
    var inst = this._instance;
    !(inst != null) ? undefined !== 'production' ? invariant$17(false, 'Attempted to update component `%s` that has already been unmounted (or failed to mount).', this.getName() || 'ReactCompositeComponent') : _prodInvariant$16('136', this.getName() || 'ReactCompositeComponent') : void 0;
    var willReceive = false;
    var nextContext;
    if (this._context === nextUnmaskedContext) {
      nextContext = inst.context;
    } else {
      nextContext = this._processContext(nextUnmaskedContext);
      willReceive = true;
    }
    var prevProps = prevParentElement.props;
    var nextProps = nextParentElement.props;
    if (prevParentElement !== nextParentElement) {
      willReceive = true;
    }
    if (willReceive && inst.componentWillReceiveProps) {
      if (undefined !== 'production') {
        measureLifeCyclePerf(function () {
          return inst.componentWillReceiveProps(nextProps, nextContext);
        }, this._debugID, 'componentWillReceiveProps');
      } else {
        inst.componentWillReceiveProps(nextProps, nextContext);
      }
    }
    var nextState = this._processPendingState(nextProps, nextContext);
    var shouldUpdate = true;
    if (!this._pendingForceUpdate) {
      if (inst.shouldComponentUpdate) {
        if (undefined !== 'production') {
          shouldUpdate = measureLifeCyclePerf(function () {
            return inst.shouldComponentUpdate(nextProps, nextState, nextContext);
          }, this._debugID, 'shouldComponentUpdate');
        } else {
          shouldUpdate = inst.shouldComponentUpdate(nextProps, nextState, nextContext);
        }
      } else {
        if (this._compositeType === CompositeTypes.PureClass) {
          shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);
        }
      }
    }
    if (undefined !== 'production') {
      undefined !== 'production' ? warning$16(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : void 0;
    }
    this._updateBatchNumber = null;
    if (shouldUpdate) {
      this._pendingForceUpdate = false;
      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
    } else {
      this._currentElement = nextParentElement;
      this._context = nextUnmaskedContext;
      inst.props = nextProps;
      inst.state = nextState;
      inst.context = nextContext;
    }
  },
  _processPendingState: function (props, context) {
    var inst = this._instance;
    var queue = this._pendingStateQueue;
    var replace = this._pendingReplaceState;
    this._pendingReplaceState = false;
    this._pendingStateQueue = null;
    if (!queue) {
      return inst.state;
    }
    if (replace && queue.length === 1) {
      return queue[0];
    }
    var nextState = _assign$8({}, replace ? queue[0] : inst.state);
    for (var i = replace ? 1 : 0; i < queue.length; i++) {
      var partial = queue[i];
      _assign$8(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
    }
    return nextState;
  },
  _performComponentUpdate: function (nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
    var _this2 = this;
    var inst = this._instance;
    var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
    var prevProps;
    var prevState;
    var prevContext;
    if (hasComponentDidUpdate) {
      prevProps = inst.props;
      prevState = inst.state;
      prevContext = inst.context;
    }
    if (inst.componentWillUpdate) {
      if (undefined !== 'production') {
        measureLifeCyclePerf(function () {
          return inst.componentWillUpdate(nextProps, nextState, nextContext);
        }, this._debugID, 'componentWillUpdate');
      } else {
        inst.componentWillUpdate(nextProps, nextState, nextContext);
      }
    }
    this._currentElement = nextElement;
    this._context = unmaskedContext;
    inst.props = nextProps;
    inst.state = nextState;
    inst.context = nextContext;
    this._updateRenderedComponent(transaction, unmaskedContext);
    if (hasComponentDidUpdate) {
      if (undefined !== 'production') {
        transaction.getReactMountReady().enqueue(function () {
          measureLifeCyclePerf(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), _this2._debugID, 'componentDidUpdate');
        });
      } else {
        transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
      }
    }
  },
  _updateRenderedComponent: function (transaction, context) {
    var prevComponentInstance = this._renderedComponent;
    var prevRenderedElement = prevComponentInstance._currentElement;
    var nextRenderedElement = this._renderValidatedComponent();
    var debugID = 0;
    if (undefined !== 'production') {
      debugID = this._debugID;
    }
    if (shouldUpdateReactComponent$1(prevRenderedElement, nextRenderedElement)) {
      ReactReconciler$4.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
    } else {
      var oldHostNode = ReactReconciler$4.getHostNode(prevComponentInstance);
      ReactReconciler$4.unmountComponent(prevComponentInstance, false);
      var nodeType = ReactNodeTypes.getType(nextRenderedElement);
      this._renderedNodeType = nodeType;
      var child = this._instantiateReactComponent(nextRenderedElement, nodeType !== ReactNodeTypes.EMPTY
      );
      this._renderedComponent = child;
      var nextMarkup = ReactReconciler$4.mountComponent(child, transaction, this._hostParent, this._hostContainerInfo, this._processChildContext(context), debugID);
      if (undefined !== 'production') {
        if (debugID !== 0) {
          var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
          ReactInstrumentation$4.debugTool.onSetChildren(debugID, childDebugIDs);
        }
      }
      this._replaceNodeWithMarkup(oldHostNode, nextMarkup, prevComponentInstance);
    }
  },
  _replaceNodeWithMarkup: function (oldHostNode, nextMarkup, prevInstance) {
    ReactComponentEnvironment$3.replaceNodeWithMarkup(oldHostNode, nextMarkup, prevInstance);
  },
  _renderValidatedComponentWithoutOwnerOrContext: function () {
    var inst = this._instance;
    var renderedElement;
    if (undefined !== 'production') {
      renderedElement = measureLifeCyclePerf(function () {
        return inst.render();
      }, this._debugID, 'render');
    } else {
      renderedElement = inst.render();
    }
    if (undefined !== 'production') {
      if (renderedElement === undefined && inst.render._isMockFunction) {
        renderedElement = null;
      }
    }
    return renderedElement;
  },
  _renderValidatedComponent: function () {
    var renderedElement;
    if (undefined !== 'production' || this._compositeType !== CompositeTypes.StatelessFunctional) {
      ReactCurrentOwner$6.current = this;
      try {
        renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
      } finally {
        ReactCurrentOwner$6.current = null;
      }
    } else {
      renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
    }
    !(
    renderedElement === null || renderedElement === false || React$2.isValidElement(renderedElement)) ? undefined !== 'production' ? invariant$17(false, '%s.render(): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : _prodInvariant$16('109', this.getName() || 'ReactCompositeComponent') : void 0;
    return renderedElement;
  },
  attachRef: function (ref, component) {
    var inst = this.getPublicInstance();
    !(inst != null) ? undefined !== 'production' ? invariant$17(false, 'Stateless function components cannot have refs.') : _prodInvariant$16('110') : void 0;
    var publicComponentInstance = component.getPublicInstance();
    if (undefined !== 'production') {
      var componentName = component && component.getName ? component.getName() : 'a component';
      undefined !== 'production' ? warning$16(publicComponentInstance != null || component._compositeType !== CompositeTypes.StatelessFunctional, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : void 0;
    }
    var refs = inst.refs === emptyObject$4 ? inst.refs = {} : inst.refs;
    refs[ref] = publicComponentInstance;
  },
  detachRef: function (ref) {
    var refs = this.getPublicInstance().refs;
    delete refs[ref];
  },
  getName: function () {
    var type = this._currentElement.type;
    var constructor = this._instance && this._instance.constructor;
    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
  },
  getPublicInstance: function () {
    var inst = this._instance;
    if (this._compositeType === CompositeTypes.StatelessFunctional) {
      return null;
    }
    return inst;
  },
  _instantiateReactComponent: null
};
var ReactCompositeComponent_1 = ReactCompositeComponent$1;

var _prodInvariant$19 = reactProdInvariant_1$2;
var invariant$20 = invariant_1;
var genericComponentClass = null;
var textComponentClass = null;
var ReactHostComponentInjection = {
  injectGenericComponentClass: function (componentClass) {
    genericComponentClass = componentClass;
  },
  injectTextComponentClass: function (componentClass) {
    textComponentClass = componentClass;
  }
};
function createInternalComponent(element) {
  !genericComponentClass ? undefined !== 'production' ? invariant$20(false, 'There is no registered component for the tag %s', element.type) : _prodInvariant$19('111', element.type) : void 0;
  return new genericComponentClass(element);
}
function createInstanceForText(text) {
  return new textComponentClass(text);
}
function isTextComponent(component) {
  return component instanceof textComponentClass;
}
var ReactHostComponent$2 = {
  createInternalComponent: createInternalComponent,
  createInstanceForText: createInstanceForText,
  isTextComponent: isTextComponent,
  injection: ReactHostComponentInjection
};
var ReactHostComponent_1 = ReactHostComponent$2;

var nextDebugID = 1;
function getNextDebugID$1() {
  return nextDebugID++;
}
var getNextDebugID_1 = getNextDebugID$1;

var _prodInvariant$15 = reactProdInvariant_1$2;
var _assign$7 = index;
var ReactCompositeComponent = ReactCompositeComponent_1;
var ReactEmptyComponent$2 = ReactEmptyComponent_1;
var ReactHostComponent$1 = ReactHostComponent_1;
var getNextDebugID = getNextDebugID_1;
var invariant$16 = invariant_1;
var warning$15 = warning_1;
var ReactCompositeComponentWrapper = function (element) {
  this.construct(element);
};
_assign$7(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent, {
  _instantiateReactComponent: instantiateReactComponent$1
});
function getDeclarationErrorAddendum$1(owner) {
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}
function isInternalComponentType(type) {
  return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
}
function instantiateReactComponent$1(node, shouldHaveDebugID) {
  var instance;
  if (node === null || node === false) {
    instance = ReactEmptyComponent$2.create(instantiateReactComponent$1);
  } else if (typeof node === 'object') {
    var element = node;
    var type = element.type;
    if (typeof type !== 'function' && typeof type !== 'string') {
      var info = '';
      if (undefined !== 'production') {
        if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
          info += ' You likely forgot to export your component from the file ' + 'it\'s defined in.';
        }
      }
      info += getDeclarationErrorAddendum$1(element._owner);
      undefined !== 'production' ? invariant$16(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', type == null ? type : typeof type, info) : _prodInvariant$15('130', type == null ? type : typeof type, info);
    }
    if (typeof element.type === 'string') {
      instance = ReactHostComponent$1.createInternalComponent(element);
    } else if (isInternalComponentType(element.type)) {
      instance = new element.type(element);
      if (!instance.getHostNode) {
        instance.getHostNode = instance.getNativeNode;
      }
    } else {
      instance = new ReactCompositeComponentWrapper(element);
    }
  } else if (typeof node === 'string' || typeof node === 'number') {
    instance = ReactHostComponent$1.createInstanceForText(node);
  } else {
    undefined !== 'production' ? invariant$16(false, 'Encountered invalid React node of type %s', typeof node) : _prodInvariant$15('131', typeof node);
  }
  if (undefined !== 'production') {
    undefined !== 'production' ? warning$15(typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.getHostNode === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : void 0;
  }
  instance._mountIndex = 0;
  instance._mountImage = null;
  if (undefined !== 'production') {
    instance._debugID = shouldHaveDebugID ? getNextDebugID() : 0;
  }
  if (undefined !== 'production') {
    if (Object.preventExtensions) {
      Object.preventExtensions(instance);
    }
  }
  return instance;
}
var instantiateReactComponent_1 = instantiateReactComponent$1;

function escape$1(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = ('' + key).replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });
  return '$' + escapedString;
}
function unescape$1(key) {
  var unescapeRegex = /(=0|=2)/g;
  var unescaperLookup = {
    '=0': '=',
    '=2': ':'
  };
  var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);
  return ('' + keySubstring).replace(unescapeRegex, function (match) {
    return unescaperLookup[match];
  });
}
var KeyEscapeUtils$3 = {
  escape: escape$1,
  unescape: unescape$1
};
var KeyEscapeUtils_1$2 = KeyEscapeUtils$3;

var REACT_ELEMENT_TYPE$4 = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;
var ReactElementSymbol$2 = REACT_ELEMENT_TYPE$4;

var ITERATOR_SYMBOL$1 = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL$1 = '@@iterator';
function getIteratorFn$5(maybeIterable) {
  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL$1 && maybeIterable[ITERATOR_SYMBOL$1] || maybeIterable[FAUX_ITERATOR_SYMBOL$1]);
  if (typeof iteratorFn === 'function') {
    return iteratorFn;
  }
}
var getIteratorFn_1$2 = getIteratorFn$5;

var _prodInvariant$20 = reactProdInvariant_1$2;
var ReactCurrentOwner$7 = ReactCurrentOwner_1;
var REACT_ELEMENT_TYPE$3 = ReactElementSymbol$2;
var getIteratorFn$4 = getIteratorFn_1$2;
var invariant$21 = invariant_1;
var KeyEscapeUtils$4 = KeyEscapeUtils_1$2;
var warning$18 = warning_1;
var SEPARATOR$1 = '.';
var SUBSEPARATOR$1 = ':';
var didWarnAboutMaps$1 = false;
function getComponentKey$1(component, index) {
  if (component && typeof component === 'object' && component.key != null) {
    return KeyEscapeUtils$4.escape(component.key);
  }
  return index.toString(36);
}
function traverseAllChildrenImpl$1(children, nameSoFar, callback, traverseContext) {
  var type = typeof children;
  if (type === 'undefined' || type === 'boolean') {
    children = null;
  }
  if (children === null || type === 'string' || type === 'number' ||
  type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE$3) {
    callback(traverseContext, children,
    nameSoFar === '' ? SEPARATOR$1 + getComponentKey$1(children, 0) : nameSoFar);
    return 1;
  }
  var child;
  var nextName;
  var subtreeCount = 0;
  var nextNamePrefix = nameSoFar === '' ? SEPARATOR$1 : nameSoFar + SUBSEPARATOR$1;
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getComponentKey$1(child, i);
      subtreeCount += traverseAllChildrenImpl$1(child, nextName, callback, traverseContext);
    }
  } else {
    var iteratorFn = getIteratorFn$4(children);
    if (iteratorFn) {
      var iterator = iteratorFn.call(children);
      var step;
      if (iteratorFn !== children.entries) {
        var ii = 0;
        while (!(step = iterator.next()).done) {
          child = step.value;
          nextName = nextNamePrefix + getComponentKey$1(child, ii++);
          subtreeCount += traverseAllChildrenImpl$1(child, nextName, callback, traverseContext);
        }
      } else {
        if (undefined !== 'production') {
          var mapsAsChildrenAddendum = '';
          if (ReactCurrentOwner$7.current) {
            var mapsAsChildrenOwnerName = ReactCurrentOwner$7.current.getName();
            if (mapsAsChildrenOwnerName) {
              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
            }
          }
          undefined !== 'production' ? warning$18(didWarnAboutMaps$1, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
          didWarnAboutMaps$1 = true;
        }
        while (!(step = iterator.next()).done) {
          var entry = step.value;
          if (entry) {
            child = entry[1];
            nextName = nextNamePrefix + KeyEscapeUtils$4.escape(entry[0]) + SUBSEPARATOR$1 + getComponentKey$1(child, 0);
            subtreeCount += traverseAllChildrenImpl$1(child, nextName, callback, traverseContext);
          }
        }
      }
    } else if (type === 'object') {
      var addendum = '';
      if (undefined !== 'production') {
        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
        if (children._isReactElement) {
          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
        }
        if (ReactCurrentOwner$7.current) {
          var name = ReactCurrentOwner$7.current.getName();
          if (name) {
            addendum += ' Check the render method of `' + name + '`.';
          }
        }
      }
      var childrenString = String(children);
      undefined !== 'production' ? invariant$21(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant$20('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum);
    }
  }
  return subtreeCount;
}
function traverseAllChildren$3(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }
  return traverseAllChildrenImpl$1(children, '', callback, traverseContext);
}
var traverseAllChildren_1$2 = traverseAllChildren$3;

var ReactReconciler$3 = ReactReconciler_1;
var instantiateReactComponent = instantiateReactComponent_1;
var KeyEscapeUtils$2 = KeyEscapeUtils_1$2;
var shouldUpdateReactComponent = shouldUpdateReactComponent_1;
var traverseAllChildren$2 = traverseAllChildren_1$2;
var warning$14 = warning_1;
var ReactComponentTreeHook$4;
if (typeof process !== 'undefined' && process.env && undefined === 'test') {
  ReactComponentTreeHook$4 = ReactComponentTreeHook_1;
}
function instantiateChild(childInstances, child, name, selfDebugID) {
  var keyUnique = childInstances[name] === undefined;
  if (undefined !== 'production') {
    if (!ReactComponentTreeHook$4) {
      ReactComponentTreeHook$4 = ReactComponentTreeHook_1;
    }
    if (!keyUnique) {
      undefined !== 'production' ? warning$14(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils$2.unescape(name), ReactComponentTreeHook$4.getStackAddendumByID(selfDebugID)) : void 0;
    }
  }
  if (child != null && keyUnique) {
    childInstances[name] = instantiateReactComponent(child, true);
  }
}
var ReactChildReconciler$1 = {
  instantiateChildren: function (nestedChildNodes, transaction, context, selfDebugID
  ) {
    if (nestedChildNodes == null) {
      return null;
    }
    var childInstances = {};
    if (undefined !== 'production') {
      traverseAllChildren$2(nestedChildNodes, function (childInsts, child, name) {
        return instantiateChild(childInsts, child, name, selfDebugID);
      }, childInstances);
    } else {
      traverseAllChildren$2(nestedChildNodes, instantiateChild, childInstances);
    }
    return childInstances;
  },
  updateChildren: function (prevChildren, nextChildren, mountImages, removedNodes, transaction, hostParent, hostContainerInfo, context, selfDebugID
  ) {
    if (!nextChildren && !prevChildren) {
      return;
    }
    var name;
    var prevChild;
    for (name in nextChildren) {
      if (!nextChildren.hasOwnProperty(name)) {
        continue;
      }
      prevChild = prevChildren && prevChildren[name];
      var prevElement = prevChild && prevChild._currentElement;
      var nextElement = nextChildren[name];
      if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
        ReactReconciler$3.receiveComponent(prevChild, nextElement, transaction, context);
        nextChildren[name] = prevChild;
      } else {
        if (prevChild) {
          removedNodes[name] = ReactReconciler$3.getHostNode(prevChild);
          ReactReconciler$3.unmountComponent(prevChild, false);
        }
        var nextChildInstance = instantiateReactComponent(nextElement, true);
        nextChildren[name] = nextChildInstance;
        var nextChildMountImage = ReactReconciler$3.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context, selfDebugID);
        mountImages.push(nextChildMountImage);
      }
    }
    for (name in prevChildren) {
      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
        prevChild = prevChildren[name];
        removedNodes[name] = ReactReconciler$3.getHostNode(prevChild);
        ReactReconciler$3.unmountComponent(prevChild, false);
      }
    }
  },
  unmountChildren: function (renderedChildren, safely) {
    for (var name in renderedChildren) {
      if (renderedChildren.hasOwnProperty(name)) {
        var renderedChild = renderedChildren[name];
        ReactReconciler$3.unmountComponent(renderedChild, safely);
      }
    }
  }
};
var ReactChildReconciler_1 = ReactChildReconciler$1;

var KeyEscapeUtils$5 = KeyEscapeUtils_1$2;
var traverseAllChildren$4 = traverseAllChildren_1$2;
var warning$19 = warning_1;
var ReactComponentTreeHook$6;
if (typeof process !== 'undefined' && process.env && undefined === 'test') {
  ReactComponentTreeHook$6 = ReactComponentTreeHook_1;
}
function flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID) {
  if (traverseContext && typeof traverseContext === 'object') {
    var result = traverseContext;
    var keyUnique = result[name] === undefined;
    if (undefined !== 'production') {
      if (!ReactComponentTreeHook$6) {
        ReactComponentTreeHook$6 = ReactComponentTreeHook_1;
      }
      if (!keyUnique) {
        undefined !== 'production' ? warning$19(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils$5.unescape(name), ReactComponentTreeHook$6.getStackAddendumByID(selfDebugID)) : void 0;
      }
    }
    if (keyUnique && child != null) {
      result[name] = child;
    }
  }
}
function flattenChildren$1(children, selfDebugID) {
  if (children == null) {
    return children;
  }
  var result = {};
  if (undefined !== 'production') {
    traverseAllChildren$4(children, function (traverseContext, child, name) {
      return flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID);
    }, result);
  } else {
    traverseAllChildren$4(children, flattenSingleChildIntoContext, result);
  }
  return result;
}
var flattenChildren_1 = flattenChildren$1;

var _prodInvariant$14 = reactProdInvariant_1$2;
var ReactComponentEnvironment$2 = ReactComponentEnvironment_1;
var ReactInstanceMap = ReactInstanceMap_1;
var ReactInstrumentation$3 = ReactInstrumentation$1;
var ReactCurrentOwner$5 = ReactCurrentOwner_1;
var ReactReconciler$2 = ReactReconciler_1;
var ReactChildReconciler = ReactChildReconciler_1;
var emptyFunction$5 = emptyFunction_1;
var flattenChildren = flattenChildren_1;
var invariant$15 = invariant_1;
function makeInsertMarkup(markup, afterNode, toIndex) {
  return {
    type: 'INSERT_MARKUP',
    content: markup,
    fromIndex: null,
    fromNode: null,
    toIndex: toIndex,
    afterNode: afterNode
  };
}
function makeMove(child, afterNode, toIndex) {
  return {
    type: 'MOVE_EXISTING',
    content: null,
    fromIndex: child._mountIndex,
    fromNode: ReactReconciler$2.getHostNode(child),
    toIndex: toIndex,
    afterNode: afterNode
  };
}
function makeRemove(child, node) {
  return {
    type: 'REMOVE_NODE',
    content: null,
    fromIndex: child._mountIndex,
    fromNode: node,
    toIndex: null,
    afterNode: null
  };
}
function makeSetMarkup(markup) {
  return {
    type: 'SET_MARKUP',
    content: markup,
    fromIndex: null,
    fromNode: null,
    toIndex: null,
    afterNode: null
  };
}
function makeTextContent(textContent) {
  return {
    type: 'TEXT_CONTENT',
    content: textContent,
    fromIndex: null,
    fromNode: null,
    toIndex: null,
    afterNode: null
  };
}
function enqueue(queue, update) {
  if (update) {
    queue = queue || [];
    queue.push(update);
  }
  return queue;
}
function processQueue(inst, updateQueue) {
  ReactComponentEnvironment$2.processChildrenUpdates(inst, updateQueue);
}
var setChildrenForInstrumentation = emptyFunction$5;
if (undefined !== 'production') {
  var getDebugID = function (inst) {
    if (!inst._debugID) {
      var internal;
      if (internal = ReactInstanceMap.get(inst)) {
        inst = internal;
      }
    }
    return inst._debugID;
  };
  setChildrenForInstrumentation = function (children) {
    var debugID = getDebugID(this);
    if (debugID !== 0) {
      ReactInstrumentation$3.debugTool.onSetChildren(debugID, children ? Object.keys(children).map(function (key) {
        return children[key]._debugID;
      }) : []);
    }
  };
}
var ReactMultiChild$1 = {
  Mixin: {
    _reconcilerInstantiateChildren: function (nestedChildren, transaction, context) {
      if (undefined !== 'production') {
        var selfDebugID = getDebugID(this);
        if (this._currentElement) {
          try {
            ReactCurrentOwner$5.current = this._currentElement._owner;
            return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context, selfDebugID);
          } finally {
            ReactCurrentOwner$5.current = null;
          }
        }
      }
      return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
    },
    _reconcilerUpdateChildren: function (prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context) {
      var nextChildren;
      var selfDebugID = 0;
      if (undefined !== 'production') {
        selfDebugID = getDebugID(this);
        if (this._currentElement) {
          try {
            ReactCurrentOwner$5.current = this._currentElement._owner;
            nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
          } finally {
            ReactCurrentOwner$5.current = null;
          }
          ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
          return nextChildren;
        }
      }
      nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
      ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
      return nextChildren;
    },
    mountChildren: function (nestedChildren, transaction, context) {
      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
      this._renderedChildren = children;
      var mountImages = [];
      var index = 0;
      for (var name in children) {
        if (children.hasOwnProperty(name)) {
          var child = children[name];
          var selfDebugID = 0;
          if (undefined !== 'production') {
            selfDebugID = getDebugID(this);
          }
          var mountImage = ReactReconciler$2.mountComponent(child, transaction, this, this._hostContainerInfo, context, selfDebugID);
          child._mountIndex = index++;
          mountImages.push(mountImage);
        }
      }
      if (undefined !== 'production') {
        setChildrenForInstrumentation.call(this, children);
      }
      return mountImages;
    },
    updateTextContent: function (nextContent) {
      var prevChildren = this._renderedChildren;
      ReactChildReconciler.unmountChildren(prevChildren, false);
      for (var name in prevChildren) {
        if (prevChildren.hasOwnProperty(name)) {
          undefined !== 'production' ? invariant$15(false, 'updateTextContent called on non-empty component.') : _prodInvariant$14('118');
        }
      }
      var updates = [makeTextContent(nextContent)];
      processQueue(this, updates);
    },
    updateMarkup: function (nextMarkup) {
      var prevChildren = this._renderedChildren;
      ReactChildReconciler.unmountChildren(prevChildren, false);
      for (var name in prevChildren) {
        if (prevChildren.hasOwnProperty(name)) {
          undefined !== 'production' ? invariant$15(false, 'updateTextContent called on non-empty component.') : _prodInvariant$14('118');
        }
      }
      var updates = [makeSetMarkup(nextMarkup)];
      processQueue(this, updates);
    },
    updateChildren: function (nextNestedChildrenElements, transaction, context) {
      this._updateChildren(nextNestedChildrenElements, transaction, context);
    },
    _updateChildren: function (nextNestedChildrenElements, transaction, context) {
      var prevChildren = this._renderedChildren;
      var removedNodes = {};
      var mountImages = [];
      var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context);
      if (!nextChildren && !prevChildren) {
        return;
      }
      var updates = null;
      var name;
      var nextIndex = 0;
      var lastIndex = 0;
      var nextMountIndex = 0;
      var lastPlacedNode = null;
      for (name in nextChildren) {
        if (!nextChildren.hasOwnProperty(name)) {
          continue;
        }
        var prevChild = prevChildren && prevChildren[name];
        var nextChild = nextChildren[name];
        if (prevChild === nextChild) {
          updates = enqueue(updates, this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex));
          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
          prevChild._mountIndex = nextIndex;
        } else {
          if (prevChild) {
            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
          }
          updates = enqueue(updates, this._mountChildAtIndex(nextChild, mountImages[nextMountIndex], lastPlacedNode, nextIndex, transaction, context));
          nextMountIndex++;
        }
        nextIndex++;
        lastPlacedNode = ReactReconciler$2.getHostNode(nextChild);
      }
      for (name in removedNodes) {
        if (removedNodes.hasOwnProperty(name)) {
          updates = enqueue(updates, this._unmountChild(prevChildren[name], removedNodes[name]));
        }
      }
      if (updates) {
        processQueue(this, updates);
      }
      this._renderedChildren = nextChildren;
      if (undefined !== 'production') {
        setChildrenForInstrumentation.call(this, nextChildren);
      }
    },
    unmountChildren: function (safely) {
      var renderedChildren = this._renderedChildren;
      ReactChildReconciler.unmountChildren(renderedChildren, safely);
      this._renderedChildren = null;
    },
    moveChild: function (child, afterNode, toIndex, lastIndex) {
      if (child._mountIndex < lastIndex) {
        return makeMove(child, afterNode, toIndex);
      }
    },
    createChild: function (child, afterNode, mountImage) {
      return makeInsertMarkup(mountImage, afterNode, child._mountIndex);
    },
    removeChild: function (child, node) {
      return makeRemove(child, node);
    },
    _mountChildAtIndex: function (child, mountImage, afterNode, index, transaction, context) {
      child._mountIndex = index;
      return this.createChild(child, afterNode, mountImage);
    },
    _unmountChild: function (child, node) {
      var update = this.removeChild(child, node);
      child._mountIndex = null;
      return update;
    }
  }
};
var ReactMultiChild_1 = ReactMultiChild$1;

var ReactNodeTypes$2 = ReactNodeTypes_1;
function getHostComponentFromComposite$1(inst) {
  var type;
  while ((type = inst._renderedNodeType) === ReactNodeTypes$2.COMPOSITE) {
    inst = inst._renderedComponent;
  }
  if (type === ReactNodeTypes$2.HOST) {
    return inst._renderedComponent;
  } else if (type === ReactNodeTypes$2.EMPTY) {
    return null;
  }
}
var getHostComponentFromComposite_1 = getHostComponentFromComposite$1;

var _prodInvariant$21 = reactProdInvariant_1$2;
var _assign$9 = index;
var React$4 = React_1;
var ReactReconciler$5 = ReactReconciler_1;
var ReactUpdates$3 = ReactUpdates_1;
var emptyObject$5 = emptyObject_1;
var getHostComponentFromComposite = getHostComponentFromComposite_1;
var instantiateReactComponent$2 = instantiateReactComponent_1;
var invariant$22 = invariant_1;
var defaultTestOptions = {
  createNodeMock: function () {
    return null;
  }
};
var TopLevelWrapper = function () {};
TopLevelWrapper.prototype.isReactComponent = {};
if (undefined !== 'production') {
  TopLevelWrapper.displayName = 'TopLevelWrapper';
}
TopLevelWrapper.prototype.render = function () {
  return this.props.child;
};
TopLevelWrapper.isReactTopLevelWrapper = true;
function mountComponentIntoNode(componentInstance, transaction, hostParent, hostContainerInfo) {
  var image = ReactReconciler$5.mountComponent(componentInstance, transaction, null, hostContainerInfo, emptyObject$5);
  componentInstance._renderedComponent._topLevelWrapper = componentInstance;
  return image;
}
function batchedMountComponentIntoNode(componentInstance, options) {
  var transaction = ReactUpdates$3.ReactReconcileTransaction.getPooled(true);
  var image = transaction.perform(mountComponentIntoNode, null, componentInstance, transaction, null, options);
  ReactUpdates$3.ReactReconcileTransaction.release(transaction);
  return image;
}
var ReactTestInstance = function (component) {
  this._component = component;
};
ReactTestInstance.prototype.getInstance = function () {
  return this._component._renderedComponent.getPublicInstance();
};
ReactTestInstance.prototype.update = function (nextElement) {
  !this._component ? undefined !== 'production' ? invariant$22(false, 'ReactTestRenderer: .update() can\'t be called after unmount.') : _prodInvariant$21('139') : void 0;
  var nextWrappedElement = React$4.createElement(TopLevelWrapper, { child: nextElement });
  var component = this._component;
  ReactUpdates$3.batchedUpdates(function () {
    var transaction = ReactUpdates$3.ReactReconcileTransaction.getPooled(true);
    transaction.perform(function () {
      ReactReconciler$5.receiveComponent(component, nextWrappedElement, transaction, emptyObject$5);
    });
    ReactUpdates$3.ReactReconcileTransaction.release(transaction);
  });
};
ReactTestInstance.prototype.unmount = function (nextElement) {
  var component = this._component;
  ReactUpdates$3.batchedUpdates(function () {
    var transaction = ReactUpdates$3.ReactReconcileTransaction.getPooled(true);
    transaction.perform(function () {
      ReactReconciler$5.unmountComponent(component, false);
    });
    ReactUpdates$3.ReactReconcileTransaction.release(transaction);
  });
  this._component = null;
};
ReactTestInstance.prototype.toJSON = function () {
  var inst = getHostComponentFromComposite(this._component);
  if (inst === null) {
    return null;
  }
  return inst.toJSON();
};
var ReactTestMount$1 = {
  render: function (nextElement, options) {
    var nextWrappedElement = React$4.createElement(TopLevelWrapper, { child: nextElement });
    var instance = instantiateReactComponent$2(nextWrappedElement, false);
    ReactUpdates$3.batchedUpdates(batchedMountComponentIntoNode, instance, _assign$9({}, defaultTestOptions, options));
    return new ReactTestInstance(instance);
  }
};
var ReactTestMount_1 = ReactTestMount$1;

var _prodInvariant$22 = reactProdInvariant_1$2;
var ReactCurrentOwner$8 = ReactCurrentOwner_1;
var ReactInstanceMap$3 = ReactInstanceMap_1;
var ReactInstrumentation$5 = ReactInstrumentation$1;
var ReactUpdates$4 = ReactUpdates_1;
var invariant$23 = invariant_1;
var warning$20 = warning_1;
function enqueueUpdate$1(internalInstance) {
  ReactUpdates$4.enqueueUpdate(internalInstance);
}
function formatUnexpectedArgument(arg) {
  var type = typeof arg;
  if (type !== 'object') {
    return type;
  }
  var displayName = arg.constructor && arg.constructor.name || type;
  var keys = Object.keys(arg);
  if (keys.length > 0 && keys.length < 20) {
    return displayName + ' (keys: ' + keys.join(', ') + ')';
  }
  return displayName;
}
function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
  var internalInstance = ReactInstanceMap$3.get(publicInstance);
  if (!internalInstance) {
    if (undefined !== 'production') {
      var ctor = publicInstance.constructor;
      undefined !== 'production' ? warning$20(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, ctor && (ctor.displayName || ctor.name) || 'ReactClass') : void 0;
    }
    return null;
  }
  if (undefined !== 'production') {
    undefined !== 'production' ? warning$20(ReactCurrentOwner$8.current == null, '%s(...): Cannot update during an existing state transition (such as ' + 'within `render` or another component\'s constructor). Render methods ' + 'should be a pure function of props and state; constructor ' + 'side-effects are an anti-pattern, but can be moved to ' + '`componentWillMount`.', callerName) : void 0;
  }
  return internalInstance;
}
var ReactUpdateQueue$1 = {
  isMounted: function (publicInstance) {
    if (undefined !== 'production') {
      var owner = ReactCurrentOwner$8.current;
      if (owner !== null) {
        undefined !== 'production' ? warning$20(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
        owner._warnedAboutRefsInRender = true;
      }
    }
    var internalInstance = ReactInstanceMap$3.get(publicInstance);
    if (internalInstance) {
      return !!internalInstance._renderedComponent;
    } else {
      return false;
    }
  },
  enqueueCallback: function (publicInstance, callback, callerName) {
    ReactUpdateQueue$1.validateCallback(callback, callerName);
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);
    if (!internalInstance) {
      return null;
    }
    if (internalInstance._pendingCallbacks) {
      internalInstance._pendingCallbacks.push(callback);
    } else {
      internalInstance._pendingCallbacks = [callback];
    }
    enqueueUpdate$1(internalInstance);
  },
  enqueueCallbackInternal: function (internalInstance, callback) {
    if (internalInstance._pendingCallbacks) {
      internalInstance._pendingCallbacks.push(callback);
    } else {
      internalInstance._pendingCallbacks = [callback];
    }
    enqueueUpdate$1(internalInstance);
  },
  enqueueForceUpdate: function (publicInstance) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');
    if (!internalInstance) {
      return;
    }
    internalInstance._pendingForceUpdate = true;
    enqueueUpdate$1(internalInstance);
  },
  enqueueReplaceState: function (publicInstance, completeState) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');
    if (!internalInstance) {
      return;
    }
    internalInstance._pendingStateQueue = [completeState];
    internalInstance._pendingReplaceState = true;
    enqueueUpdate$1(internalInstance);
  },
  enqueueSetState: function (publicInstance, partialState) {
    if (undefined !== 'production') {
      ReactInstrumentation$5.debugTool.onSetState();
      undefined !== 'production' ? warning$20(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : void 0;
    }
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');
    if (!internalInstance) {
      return;
    }
    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
    queue.push(partialState);
    enqueueUpdate$1(internalInstance);
  },
  enqueueElementInternal: function (internalInstance, nextElement, nextContext) {
    internalInstance._pendingElement = nextElement;
    internalInstance._context = nextContext;
    enqueueUpdate$1(internalInstance);
  },
  validateCallback: function (callback, callerName) {
    !(!callback || typeof callback === 'function') ? undefined !== 'production' ? invariant$23(false, '%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.', callerName, formatUnexpectedArgument(callback)) : _prodInvariant$22('122', callerName, formatUnexpectedArgument(callback)) : void 0;
  }
};
var ReactUpdateQueue_1 = ReactUpdateQueue$1;

var _assign$10 = index;
var CallbackQueue$2 = CallbackQueue_1;
var PooledClass$5 = PooledClass_1$2;
var Transaction$4 = Transaction$2;
var ReactUpdateQueue = ReactUpdateQueue_1;
var ON_DOM_READY_QUEUEING = {
  initialize: function () {
    this.reactMountReady.reset();
  },
  close: function () {
    this.reactMountReady.notifyAll();
  }
};
var TRANSACTION_WRAPPERS$2 = [ON_DOM_READY_QUEUEING];
function ReactTestReconcileTransaction$1(testOptions) {
  this.reinitializeTransaction();
  this.testOptions = testOptions;
  this.reactMountReady = CallbackQueue$2.getPooled(this);
}
var Mixin = {
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS$2;
  },
  getReactMountReady: function () {
    return this.reactMountReady;
  },
  getTestOptions: function () {
    return this.testOptions;
  },
  getUpdateQueue: function () {
    return ReactUpdateQueue;
  },
  checkpoint: function () {
    return this.reactMountReady.checkpoint();
  },
  rollback: function (checkpoint) {
    this.reactMountReady.rollback(checkpoint);
  },
  destructor: function () {
    CallbackQueue$2.release(this.reactMountReady);
    this.reactMountReady = null;
  }
};
_assign$10(ReactTestReconcileTransaction$1.prototype, Transaction$4, ReactTestReconcileTransaction$1, Mixin);
PooledClass$5.addPoolingTo(ReactTestReconcileTransaction$1);
var ReactTestReconcileTransaction_1 = ReactTestReconcileTransaction$1;

function _classCallCheck$2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var ReactTestTextComponent$1 = function () {
  function ReactTestTextComponent(element) {
    _classCallCheck$2(this, ReactTestTextComponent);
    this._currentElement = element;
  }
  ReactTestTextComponent.prototype.receiveComponent = function receiveComponent(nextElement) {
    this._currentElement = nextElement;
  };
  ReactTestTextComponent.prototype.toJSON = function toJSON() {
    return this._currentElement;
  };
  ReactTestTextComponent.prototype.mountComponent = function mountComponent() {};
  ReactTestTextComponent.prototype.getHostNode = function getHostNode() {};
  ReactTestTextComponent.prototype.unmountComponent = function unmountComponent() {};
  return ReactTestTextComponent;
}();
var ReactTestTextComponent_1 = ReactTestTextComponent$1;

function _classCallCheck$3(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var ReactTestEmptyComponent$1 = function () {
  function ReactTestEmptyComponent() {
    _classCallCheck$3(this, ReactTestEmptyComponent);
    this._currentElement = null;
  }
  ReactTestEmptyComponent.prototype.receiveComponent = function receiveComponent() {};
  ReactTestEmptyComponent.prototype.toJSON = function toJSON() {};
  ReactTestEmptyComponent.prototype.mountComponent = function mountComponent() {};
  ReactTestEmptyComponent.prototype.getHostNode = function getHostNode() {};
  ReactTestEmptyComponent.prototype.unmountComponent = function unmountComponent() {};
  return ReactTestEmptyComponent;
}();
var ReactTestEmptyComponent_1 = ReactTestEmptyComponent$1;

var _prodInvariant$7 = reactProdInvariant_1$2;
var _assign$4 = index;
function _objectWithoutProperties(obj, keys) {
  var target = {};for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
  }return target;
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var ReactComponentEnvironment = ReactComponentEnvironment_1;
var ReactDefaultBatchingStrategy = ReactDefaultBatchingStrategy_1;
var ReactEmptyComponent = ReactEmptyComponent_1;
var ReactMultiChild = ReactMultiChild_1;
var ReactHostComponent = ReactHostComponent_1;
var ReactTestMount = ReactTestMount_1;
var ReactTestReconcileTransaction = ReactTestReconcileTransaction_1;
var ReactUpdates = ReactUpdates_1;
var ReactTestTextComponent = ReactTestTextComponent_1;
var ReactTestEmptyComponent = ReactTestEmptyComponent_1;
var invariant$8 = invariant_1;
function getRenderedHostOrTextFromComponent(component) {
  var rendered;
  while (rendered = component._renderedComponent) {
    component = rendered;
  }
  return component;
}
var ReactTestComponent = function () {
  function ReactTestComponent(element) {
    _classCallCheck(this, ReactTestComponent);
    this._currentElement = element;
    this._renderedChildren = null;
    this._topLevelWrapper = null;
    this._hostContainerInfo = null;
  }
  ReactTestComponent.prototype.mountComponent = function mountComponent(transaction, nativeParent, hostContainerInfo, context) {
    var element = this._currentElement;
    this._hostContainerInfo = hostContainerInfo;
    this.mountChildren(element.props.children, transaction, context);
  };
  ReactTestComponent.prototype.receiveComponent = function receiveComponent(nextElement, transaction, context) {
    this._currentElement = nextElement;
    this.updateChildren(nextElement.props.children, transaction, context);
  };
  ReactTestComponent.prototype.getPublicInstance = function getPublicInstance() {
    var element = this._currentElement;
    var hostContainerInfo = this._hostContainerInfo;
    !hostContainerInfo ? undefined !== 'production' ? invariant$8(false, 'hostContainerInfo should be populated before getPublicInstance is called.') : _prodInvariant$7('145') : void 0;
    return hostContainerInfo.createNodeMock(element);
  };
  ReactTestComponent.prototype.toJSON = function toJSON() {
    var _currentElement$props = this._currentElement.props,
        children = _currentElement$props.children,
        props = _objectWithoutProperties(_currentElement$props, ['children']);
    var childrenJSON = [];
    for (var key in this._renderedChildren) {
      var inst = this._renderedChildren[key];
      inst = getRenderedHostOrTextFromComponent(inst);
      var json = inst.toJSON();
      if (json !== undefined) {
        childrenJSON.push(json);
      }
    }
    var object = {
      type: this._currentElement.type,
      props: props,
      children: childrenJSON.length ? childrenJSON : null
    };
    Object.defineProperty(object, '$$typeof', {
      value: Symbol['for']('react.test.json')
    });
    return object;
  };
  ReactTestComponent.prototype.getHostNode = function getHostNode() {};
  ReactTestComponent.prototype.unmountComponent = function unmountComponent() {};
  return ReactTestComponent;
}();
_assign$4(ReactTestComponent.prototype, ReactMultiChild.Mixin);
ReactUpdates.injection.injectReconcileTransaction(ReactTestReconcileTransaction);
ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);
ReactHostComponent.injection.injectGenericComponentClass(ReactTestComponent);
ReactHostComponent.injection.injectTextComponentClass(ReactTestTextComponent);
ReactEmptyComponent.injection.injectEmptyComponentFactory(function () {
  return new ReactTestEmptyComponent();
});
ReactComponentEnvironment.injection.injectEnvironment({
  processChildrenUpdates: function () {},
  replaceNodeWithMarkup: function () {}
});
var ReactTestRenderer = {
  create: ReactTestMount.render,
  unstable_batchedUpdates: ReactUpdates.batchedUpdates
};
var ReactTestRenderer_1 = ReactTestRenderer;

var index$4 = ReactTestRenderer_1;

var cssLayout = createCommonjsModule(function (module, exports) {
(function (root, factory) {
  if (typeof undefined === 'function' && undefined.amd) {
    undefined([], factory);
  } else {
    module.exports = factory();
  }
})(commonjsGlobal, function () {
  var computeLayout = function () {
    var CSS_UNDEFINED;
    var CSS_DIRECTION_INHERIT = 'inherit';
    var CSS_DIRECTION_LTR = 'ltr';
    var CSS_DIRECTION_RTL = 'rtl';
    var CSS_FLEX_DIRECTION_ROW = 'row';
    var CSS_FLEX_DIRECTION_ROW_REVERSE = 'row-reverse';
    var CSS_FLEX_DIRECTION_COLUMN = 'column';
    var CSS_FLEX_DIRECTION_COLUMN_REVERSE = 'column-reverse';
    var CSS_JUSTIFY_FLEX_START = 'flex-start';
    var CSS_JUSTIFY_CENTER = 'center';
    var CSS_JUSTIFY_FLEX_END = 'flex-end';
    var CSS_JUSTIFY_SPACE_BETWEEN = 'space-between';
    var CSS_JUSTIFY_SPACE_AROUND = 'space-around';
    var CSS_ALIGN_FLEX_START = 'flex-start';
    var CSS_ALIGN_CENTER = 'center';
    var CSS_ALIGN_FLEX_END = 'flex-end';
    var CSS_ALIGN_STRETCH = 'stretch';
    var CSS_POSITION_RELATIVE = 'relative';
    var CSS_POSITION_ABSOLUTE = 'absolute';
    var leading = {
      'row': 'left',
      'row-reverse': 'right',
      'column': 'top',
      'column-reverse': 'bottom'
    };
    var trailing = {
      'row': 'right',
      'row-reverse': 'left',
      'column': 'bottom',
      'column-reverse': 'top'
    };
    var pos = {
      'row': 'left',
      'row-reverse': 'right',
      'column': 'top',
      'column-reverse': 'bottom'
    };
    var dim = {
      'row': 'width',
      'row-reverse': 'width',
      'column': 'height',
      'column-reverse': 'height'
    };
    function fillNodes(node) {
      if (!node.layout || node.isDirty) {
        node.layout = {
          width: undefined,
          height: undefined,
          top: 0,
          left: 0,
          right: 0,
          bottom: 0
        };
      }
      if (!node.style) {
        node.style = {};
      }
      if (!node.children) {
        node.children = [];
      }
      node.children.forEach(fillNodes);
      return node;
    }
    function isUndefined(value) {
      return value === undefined;
    }
    function isRowDirection(flexDirection) {
      return flexDirection === CSS_FLEX_DIRECTION_ROW || flexDirection === CSS_FLEX_DIRECTION_ROW_REVERSE;
    }
    function isColumnDirection(flexDirection) {
      return flexDirection === CSS_FLEX_DIRECTION_COLUMN || flexDirection === CSS_FLEX_DIRECTION_COLUMN_REVERSE;
    }
    function getLeadingMargin(node, axis) {
      if (node.style.marginStart !== undefined && isRowDirection(axis)) {
        return node.style.marginStart;
      }
      var value = null;
      switch (axis) {
        case 'row':
          value = node.style.marginLeft;break;
        case 'row-reverse':
          value = node.style.marginRight;break;
        case 'column':
          value = node.style.marginTop;break;
        case 'column-reverse':
          value = node.style.marginBottom;break;
      }
      if (value !== undefined) {
        return value;
      }
      if (node.style.margin !== undefined) {
        return node.style.margin;
      }
      return 0;
    }
    function getTrailingMargin(node, axis) {
      if (node.style.marginEnd !== undefined && isRowDirection(axis)) {
        return node.style.marginEnd;
      }
      var value = null;
      switch (axis) {
        case 'row':
          value = node.style.marginRight;break;
        case 'row-reverse':
          value = node.style.marginLeft;break;
        case 'column':
          value = node.style.marginBottom;break;
        case 'column-reverse':
          value = node.style.marginTop;break;
      }
      if (value != null) {
        return value;
      }
      if (node.style.margin !== undefined) {
        return node.style.margin;
      }
      return 0;
    }
    function getLeadingPadding(node, axis) {
      if (node.style.paddingStart !== undefined && node.style.paddingStart >= 0 && isRowDirection(axis)) {
        return node.style.paddingStart;
      }
      var value = null;
      switch (axis) {
        case 'row':
          value = node.style.paddingLeft;break;
        case 'row-reverse':
          value = node.style.paddingRight;break;
        case 'column':
          value = node.style.paddingTop;break;
        case 'column-reverse':
          value = node.style.paddingBottom;break;
      }
      if (value != null && value >= 0) {
        return value;
      }
      if (node.style.padding !== undefined && node.style.padding >= 0) {
        return node.style.padding;
      }
      return 0;
    }
    function getTrailingPadding(node, axis) {
      if (node.style.paddingEnd !== undefined && node.style.paddingEnd >= 0 && isRowDirection(axis)) {
        return node.style.paddingEnd;
      }
      var value = null;
      switch (axis) {
        case 'row':
          value = node.style.paddingRight;break;
        case 'row-reverse':
          value = node.style.paddingLeft;break;
        case 'column':
          value = node.style.paddingBottom;break;
        case 'column-reverse':
          value = node.style.paddingTop;break;
      }
      if (value != null && value >= 0) {
        return value;
      }
      if (node.style.padding !== undefined && node.style.padding >= 0) {
        return node.style.padding;
      }
      return 0;
    }
    function getLeadingBorder(node, axis) {
      if (node.style.borderStartWidth !== undefined && node.style.borderStartWidth >= 0 && isRowDirection(axis)) {
        return node.style.borderStartWidth;
      }
      var value = null;
      switch (axis) {
        case 'row':
          value = node.style.borderLeftWidth;break;
        case 'row-reverse':
          value = node.style.borderRightWidth;break;
        case 'column':
          value = node.style.borderTopWidth;break;
        case 'column-reverse':
          value = node.style.borderBottomWidth;break;
      }
      if (value != null && value >= 0) {
        return value;
      }
      if (node.style.borderWidth !== undefined && node.style.borderWidth >= 0) {
        return node.style.borderWidth;
      }
      return 0;
    }
    function getTrailingBorder(node, axis) {
      if (node.style.borderEndWidth !== undefined && node.style.borderEndWidth >= 0 && isRowDirection(axis)) {
        return node.style.borderEndWidth;
      }
      var value = null;
      switch (axis) {
        case 'row':
          value = node.style.borderRightWidth;break;
        case 'row-reverse':
          value = node.style.borderLeftWidth;break;
        case 'column':
          value = node.style.borderBottomWidth;break;
        case 'column-reverse':
          value = node.style.borderTopWidth;break;
      }
      if (value != null && value >= 0) {
        return value;
      }
      if (node.style.borderWidth !== undefined && node.style.borderWidth >= 0) {
        return node.style.borderWidth;
      }
      return 0;
    }
    function getLeadingPaddingAndBorder(node, axis) {
      return getLeadingPadding(node, axis) + getLeadingBorder(node, axis);
    }
    function getTrailingPaddingAndBorder(node, axis) {
      return getTrailingPadding(node, axis) + getTrailingBorder(node, axis);
    }
    function getBorderAxis(node, axis) {
      return getLeadingBorder(node, axis) + getTrailingBorder(node, axis);
    }
    function getMarginAxis(node, axis) {
      return getLeadingMargin(node, axis) + getTrailingMargin(node, axis);
    }
    function getPaddingAndBorderAxis(node, axis) {
      return getLeadingPaddingAndBorder(node, axis) + getTrailingPaddingAndBorder(node, axis);
    }
    function getJustifyContent(node) {
      if (node.style.justifyContent) {
        return node.style.justifyContent;
      }
      return 'flex-start';
    }
    function getAlignContent(node) {
      if (node.style.alignContent) {
        return node.style.alignContent;
      }
      return 'flex-start';
    }
    function getAlignItem(node, child) {
      if (child.style.alignSelf) {
        return child.style.alignSelf;
      }
      if (node.style.alignItems) {
        return node.style.alignItems;
      }
      return 'stretch';
    }
    function resolveAxis(axis, direction) {
      if (direction === CSS_DIRECTION_RTL) {
        if (axis === CSS_FLEX_DIRECTION_ROW) {
          return CSS_FLEX_DIRECTION_ROW_REVERSE;
        } else if (axis === CSS_FLEX_DIRECTION_ROW_REVERSE) {
          return CSS_FLEX_DIRECTION_ROW;
        }
      }
      return axis;
    }
    function resolveDirection(node, parentDirection) {
      var direction;
      if (node.style.direction) {
        direction = node.style.direction;
      } else {
        direction = CSS_DIRECTION_INHERIT;
      }
      if (direction === CSS_DIRECTION_INHERIT) {
        direction = parentDirection === undefined ? CSS_DIRECTION_LTR : parentDirection;
      }
      return direction;
    }
    function getFlexDirection(node) {
      if (node.style.flexDirection) {
        return node.style.flexDirection;
      }
      return CSS_FLEX_DIRECTION_COLUMN;
    }
    function getCrossFlexDirection(flexDirection, direction) {
      if (isColumnDirection(flexDirection)) {
        return resolveAxis(CSS_FLEX_DIRECTION_ROW, direction);
      } else {
        return CSS_FLEX_DIRECTION_COLUMN;
      }
    }
    function getPositionType(node) {
      if (node.style.position) {
        return node.style.position;
      }
      return 'relative';
    }
    function isFlex(node) {
      return getPositionType(node) === CSS_POSITION_RELATIVE && node.style.flex > 0;
    }
    function isFlexWrap(node) {
      return node.style.flexWrap === 'wrap';
    }
    function getDimWithMargin(node, axis) {
      return node.layout[dim[axis]] + getMarginAxis(node, axis);
    }
    function isDimDefined(node, axis) {
      return node.style[dim[axis]] !== undefined && node.style[dim[axis]] >= 0;
    }
    function isPosDefined(node, pos) {
      return node.style[pos] !== undefined;
    }
    function isMeasureDefined(node) {
      return node.style.measure !== undefined;
    }
    function getPosition(node, pos) {
      if (node.style[pos] !== undefined) {
        return node.style[pos];
      }
      return 0;
    }
    function boundAxis(node, axis, value) {
      var min = {
        'row': node.style.minWidth,
        'row-reverse': node.style.minWidth,
        'column': node.style.minHeight,
        'column-reverse': node.style.minHeight
      }[axis];
      var max = {
        'row': node.style.maxWidth,
        'row-reverse': node.style.maxWidth,
        'column': node.style.maxHeight,
        'column-reverse': node.style.maxHeight
      }[axis];
      var boundValue = value;
      if (max !== undefined && max >= 0 && boundValue > max) {
        boundValue = max;
      }
      if (min !== undefined && min >= 0 && boundValue < min) {
        boundValue = min;
      }
      return boundValue;
    }
    function fmaxf(a, b) {
      if (a > b) {
        return a;
      }
      return b;
    }
    function setDimensionFromStyle(node, axis) {
      if (node.layout[dim[axis]] !== undefined) {
        return;
      }
      if (!isDimDefined(node, axis)) {
        return;
      }
      node.layout[dim[axis]] = fmaxf(boundAxis(node, axis, node.style[dim[axis]]), getPaddingAndBorderAxis(node, axis));
    }
    function setTrailingPosition(node, child, axis) {
      child.layout[trailing[axis]] = node.layout[dim[axis]] - child.layout[dim[axis]] - child.layout[pos[axis]];
    }
    function getRelativePosition(node, axis) {
      if (node.style[leading[axis]] !== undefined) {
        return getPosition(node, leading[axis]);
      }
      return -getPosition(node, trailing[axis]);
    }
    function layoutNodeImpl(node, parentMaxWidth, /*css_direction_t*/parentDirection) {
      var /*css_direction_t*/direction = resolveDirection(node, parentDirection);
      var /*(c)!css_flex_direction_t*/ /*(java)!int*/mainAxis = resolveAxis(getFlexDirection(node), direction);
      var /*(c)!css_flex_direction_t*/ /*(java)!int*/crossAxis = getCrossFlexDirection(mainAxis, direction);
      var /*(c)!css_flex_direction_t*/ /*(java)!int*/resolvedRowAxis = resolveAxis(CSS_FLEX_DIRECTION_ROW, direction);
      setDimensionFromStyle(node, mainAxis);
      setDimensionFromStyle(node, crossAxis);
      node.layout.direction = direction;
      node.layout[leading[mainAxis]] += getLeadingMargin(node, mainAxis) + getRelativePosition(node, mainAxis);
      node.layout[trailing[mainAxis]] += getTrailingMargin(node, mainAxis) + getRelativePosition(node, mainAxis);
      node.layout[leading[crossAxis]] += getLeadingMargin(node, crossAxis) + getRelativePosition(node, crossAxis);
      node.layout[trailing[crossAxis]] += getTrailingMargin(node, crossAxis) + getRelativePosition(node, crossAxis);
      var /*int*/childCount = node.children.length;
      var /*float*/paddingAndBorderAxisResolvedRow = getPaddingAndBorderAxis(node, resolvedRowAxis);
      if (isMeasureDefined(node)) {
        var /*bool*/isResolvedRowDimDefined = !isUndefined(node.layout[dim[resolvedRowAxis]]);
        var /*float*/width = CSS_UNDEFINED;
        if (isDimDefined(node, resolvedRowAxis)) {
          width = node.style.width;
        } else if (isResolvedRowDimDefined) {
          width = node.layout[dim[resolvedRowAxis]];
        } else {
          width = parentMaxWidth - getMarginAxis(node, resolvedRowAxis);
        }
        width -= paddingAndBorderAxisResolvedRow;
        var /*bool*/isRowUndefined = !isDimDefined(node, resolvedRowAxis) && !isResolvedRowDimDefined;
        var /*bool*/isColumnUndefined = !isDimDefined(node, CSS_FLEX_DIRECTION_COLUMN) && isUndefined(node.layout[dim[CSS_FLEX_DIRECTION_COLUMN]]);
        if (isRowUndefined || isColumnUndefined) {
          var /*css_dim_t*/measureDim = node.style.measure(
          width);
          if (isRowUndefined) {
            node.layout.width = measureDim.width + paddingAndBorderAxisResolvedRow;
          }
          if (isColumnUndefined) {
            node.layout.height = measureDim.height + getPaddingAndBorderAxis(node, CSS_FLEX_DIRECTION_COLUMN);
          }
        }
        if (childCount === 0) {
          return;
        }
      }
      var /*bool*/isNodeFlexWrap = isFlexWrap(node);
      var /*css_justify_t*/justifyContent = getJustifyContent(node);
      var /*float*/leadingPaddingAndBorderMain = getLeadingPaddingAndBorder(node, mainAxis);
      var /*float*/leadingPaddingAndBorderCross = getLeadingPaddingAndBorder(node, crossAxis);
      var /*float*/paddingAndBorderAxisMain = getPaddingAndBorderAxis(node, mainAxis);
      var /*float*/paddingAndBorderAxisCross = getPaddingAndBorderAxis(node, crossAxis);
      var /*bool*/isMainDimDefined = !isUndefined(node.layout[dim[mainAxis]]);
      var /*bool*/isCrossDimDefined = !isUndefined(node.layout[dim[crossAxis]]);
      var /*bool*/isMainRowDirection = isRowDirection(mainAxis);
      var /*int*/i;
      var /*int*/ii;
      var /*css_node_t**/child;
      var /*(c)!css_flex_direction_t*/ /*(java)!int*/axis;
      var /*css_node_t**/firstAbsoluteChild = null;
      var /*css_node_t**/currentAbsoluteChild = null;
      var /*float*/definedMainDim = CSS_UNDEFINED;
      if (isMainDimDefined) {
        definedMainDim = node.layout[dim[mainAxis]] - paddingAndBorderAxisMain;
      }
      var /*int*/startLine = 0;
      var /*int*/endLine = 0;
      var /*int*/alreadyComputedNextLayout = 0;
      var /*float*/linesCrossDim = 0;
      var /*float*/linesMainDim = 0;
      var /*int*/linesCount = 0;
      while (endLine < childCount) {
        var /*float*/mainContentDim = 0;
        var /*int*/flexibleChildrenCount = 0;
        var /*float*/totalFlexible = 0;
        var /*int*/nonFlexibleChildrenCount = 0;
        var /*bool*/isSimpleStackMain = isMainDimDefined && justifyContent === CSS_JUSTIFY_FLEX_START || !isMainDimDefined && justifyContent !== CSS_JUSTIFY_CENTER;
        var /*int*/firstComplexMain = isSimpleStackMain ? childCount : startLine;
        var /*bool*/isSimpleStackCross = true;
        var /*int*/firstComplexCross = childCount;
        var /*css_node_t**/firstFlexChild = null;
        var /*css_node_t**/currentFlexChild = null;
        var /*float*/mainDim = leadingPaddingAndBorderMain;
        var /*float*/crossDim = 0;
        var /*float*/maxWidth;
        for (i = startLine; i < childCount; ++i) {
          child = node.children[i];
          child.lineIndex = linesCount;
          child.nextAbsoluteChild = null;
          child.nextFlexChild = null;
          var /*css_align_t*/alignItem = getAlignItem(node, child);
          if (alignItem === CSS_ALIGN_STRETCH && getPositionType(child) === CSS_POSITION_RELATIVE && isCrossDimDefined && !isDimDefined(child, crossAxis)) {
            child.layout[dim[crossAxis]] = fmaxf(boundAxis(child, crossAxis, node.layout[dim[crossAxis]] - paddingAndBorderAxisCross - getMarginAxis(child, crossAxis)),
            getPaddingAndBorderAxis(child, crossAxis));
          } else if (getPositionType(child) === CSS_POSITION_ABSOLUTE) {
            if (firstAbsoluteChild === null) {
              firstAbsoluteChild = child;
            }
            if (currentAbsoluteChild !== null) {
              currentAbsoluteChild.nextAbsoluteChild = child;
            }
            currentAbsoluteChild = child;
            for (ii = 0; ii < 2; ii++) {
              axis = ii !== 0 ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;
              if (!isUndefined(node.layout[dim[axis]]) && !isDimDefined(child, axis) && isPosDefined(child, leading[axis]) && isPosDefined(child, trailing[axis])) {
                child.layout[dim[axis]] = fmaxf(boundAxis(child, axis, node.layout[dim[axis]] - getPaddingAndBorderAxis(node, axis) - getMarginAxis(child, axis) - getPosition(child, leading[axis]) - getPosition(child, trailing[axis])),
                getPaddingAndBorderAxis(child, axis));
              }
            }
          }
          var /*float*/nextContentDim = 0;
          if (isMainDimDefined && isFlex(child)) {
            flexibleChildrenCount++;
            totalFlexible += child.style.flex;
            if (firstFlexChild === null) {
              firstFlexChild = child;
            }
            if (currentFlexChild !== null) {
              currentFlexChild.nextFlexChild = child;
            }
            currentFlexChild = child;
            nextContentDim = getPaddingAndBorderAxis(child, mainAxis) + getMarginAxis(child, mainAxis);
          } else {
            maxWidth = CSS_UNDEFINED;
            if (!isMainRowDirection) {
              if (isDimDefined(node, resolvedRowAxis)) {
                maxWidth = node.layout[dim[resolvedRowAxis]] - paddingAndBorderAxisResolvedRow;
              } else {
                maxWidth = parentMaxWidth - getMarginAxis(node, resolvedRowAxis) - paddingAndBorderAxisResolvedRow;
              }
            }
            if (alreadyComputedNextLayout === 0) {
              layoutNode( /*(java)!layoutContext, */child, maxWidth, direction);
            }
            if (getPositionType(child) === CSS_POSITION_RELATIVE) {
              nonFlexibleChildrenCount++;
              nextContentDim = getDimWithMargin(child, mainAxis);
            }
          }
          if (isNodeFlexWrap && isMainDimDefined && mainContentDim + nextContentDim > definedMainDim &&
          i !== startLine) {
            nonFlexibleChildrenCount--;
            alreadyComputedNextLayout = 1;
            break;
          }
          if (isSimpleStackMain && (getPositionType(child) !== CSS_POSITION_RELATIVE || isFlex(child))) {
            isSimpleStackMain = false;
            firstComplexMain = i;
          }
          if (isSimpleStackCross && (getPositionType(child) !== CSS_POSITION_RELATIVE || alignItem !== CSS_ALIGN_STRETCH && alignItem !== CSS_ALIGN_FLEX_START || isUndefined(child.layout[dim[crossAxis]]))) {
            isSimpleStackCross = false;
            firstComplexCross = i;
          }
          if (isSimpleStackMain) {
            child.layout[pos[mainAxis]] += mainDim;
            if (isMainDimDefined) {
              setTrailingPosition(node, child, mainAxis);
            }
            mainDim += getDimWithMargin(child, mainAxis);
            crossDim = fmaxf(crossDim, boundAxis(child, crossAxis, getDimWithMargin(child, crossAxis)));
          }
          if (isSimpleStackCross) {
            child.layout[pos[crossAxis]] += linesCrossDim + leadingPaddingAndBorderCross;
            if (isCrossDimDefined) {
              setTrailingPosition(node, child, crossAxis);
            }
          }
          alreadyComputedNextLayout = 0;
          mainContentDim += nextContentDim;
          endLine = i + 1;
        }
        var /*float*/leadingMainDim = 0;
        var /*float*/betweenMainDim = 0;
        var /*float*/remainingMainDim = 0;
        if (isMainDimDefined) {
          remainingMainDim = definedMainDim - mainContentDim;
        } else {
          remainingMainDim = fmaxf(mainContentDim, 0) - mainContentDim;
        }
        if (flexibleChildrenCount !== 0) {
          var /*float*/flexibleMainDim = remainingMainDim / totalFlexible;
          var /*float*/baseMainDim;
          var /*float*/boundMainDim;
          currentFlexChild = firstFlexChild;
          while (currentFlexChild !== null) {
            baseMainDim = flexibleMainDim * currentFlexChild.style.flex + getPaddingAndBorderAxis(currentFlexChild, mainAxis);
            boundMainDim = boundAxis(currentFlexChild, mainAxis, baseMainDim);
            if (baseMainDim !== boundMainDim) {
              remainingMainDim -= boundMainDim;
              totalFlexible -= currentFlexChild.style.flex;
            }
            currentFlexChild = currentFlexChild.nextFlexChild;
          }
          flexibleMainDim = remainingMainDim / totalFlexible;
          if (flexibleMainDim < 0) {
            flexibleMainDim = 0;
          }
          currentFlexChild = firstFlexChild;
          while (currentFlexChild !== null) {
            currentFlexChild.layout[dim[mainAxis]] = boundAxis(currentFlexChild, mainAxis, flexibleMainDim * currentFlexChild.style.flex + getPaddingAndBorderAxis(currentFlexChild, mainAxis));
            maxWidth = CSS_UNDEFINED;
            if (isDimDefined(node, resolvedRowAxis)) {
              maxWidth = node.layout[dim[resolvedRowAxis]] - paddingAndBorderAxisResolvedRow;
            } else if (!isMainRowDirection) {
              maxWidth = parentMaxWidth - getMarginAxis(node, resolvedRowAxis) - paddingAndBorderAxisResolvedRow;
            }
            layoutNode( /*(java)!layoutContext, */currentFlexChild, maxWidth, direction);
            child = currentFlexChild;
            currentFlexChild = currentFlexChild.nextFlexChild;
            child.nextFlexChild = null;
          }
        } else if (justifyContent !== CSS_JUSTIFY_FLEX_START) {
          if (justifyContent === CSS_JUSTIFY_CENTER) {
            leadingMainDim = remainingMainDim / 2;
          } else if (justifyContent === CSS_JUSTIFY_FLEX_END) {
            leadingMainDim = remainingMainDim;
          } else if (justifyContent === CSS_JUSTIFY_SPACE_BETWEEN) {
            remainingMainDim = fmaxf(remainingMainDim, 0);
            if (flexibleChildrenCount + nonFlexibleChildrenCount - 1 !== 0) {
              betweenMainDim = remainingMainDim / (flexibleChildrenCount + nonFlexibleChildrenCount - 1);
            } else {
              betweenMainDim = 0;
            }
          } else if (justifyContent === CSS_JUSTIFY_SPACE_AROUND) {
            betweenMainDim = remainingMainDim / (flexibleChildrenCount + nonFlexibleChildrenCount);
            leadingMainDim = betweenMainDim / 2;
          }
        }
        mainDim += leadingMainDim;
        for (i = firstComplexMain; i < endLine; ++i) {
          child = node.children[i];
          if (getPositionType(child) === CSS_POSITION_ABSOLUTE && isPosDefined(child, leading[mainAxis])) {
            child.layout[pos[mainAxis]] = getPosition(child, leading[mainAxis]) + getLeadingBorder(node, mainAxis) + getLeadingMargin(child, mainAxis);
          } else {
            child.layout[pos[mainAxis]] += mainDim;
            if (isMainDimDefined) {
              setTrailingPosition(node, child, mainAxis);
            }
            if (getPositionType(child) === CSS_POSITION_RELATIVE) {
              mainDim += betweenMainDim + getDimWithMargin(child, mainAxis);
              crossDim = fmaxf(crossDim, boundAxis(child, crossAxis, getDimWithMargin(child, crossAxis)));
            }
          }
        }
        var /*float*/containerCrossAxis = node.layout[dim[crossAxis]];
        if (!isCrossDimDefined) {
          containerCrossAxis = fmaxf(
          boundAxis(node, crossAxis, crossDim + paddingAndBorderAxisCross), paddingAndBorderAxisCross);
        }
        for (i = firstComplexCross; i < endLine; ++i) {
          child = node.children[i];
          if (getPositionType(child) === CSS_POSITION_ABSOLUTE && isPosDefined(child, leading[crossAxis])) {
            child.layout[pos[crossAxis]] = getPosition(child, leading[crossAxis]) + getLeadingBorder(node, crossAxis) + getLeadingMargin(child, crossAxis);
          } else {
            var /*float*/leadingCrossDim = leadingPaddingAndBorderCross;
            if (getPositionType(child) === CSS_POSITION_RELATIVE) {
              var /*css_align_t*/alignItem = getAlignItem(node, child);
              if (alignItem === CSS_ALIGN_STRETCH) {
                if (isUndefined(child.layout[dim[crossAxis]])) {
                  child.layout[dim[crossAxis]] = fmaxf(boundAxis(child, crossAxis, containerCrossAxis - paddingAndBorderAxisCross - getMarginAxis(child, crossAxis)),
                  getPaddingAndBorderAxis(child, crossAxis));
                }
              } else if (alignItem !== CSS_ALIGN_FLEX_START) {
                var /*float*/remainingCrossDim = containerCrossAxis - paddingAndBorderAxisCross - getDimWithMargin(child, crossAxis);
                if (alignItem === CSS_ALIGN_CENTER) {
                  leadingCrossDim += remainingCrossDim / 2;
                } else {
                  leadingCrossDim += remainingCrossDim;
                }
              }
            }
            child.layout[pos[crossAxis]] += linesCrossDim + leadingCrossDim;
            if (isCrossDimDefined) {
              setTrailingPosition(node, child, crossAxis);
            }
          }
        }
        linesCrossDim += crossDim;
        linesMainDim = fmaxf(linesMainDim, mainDim);
        linesCount += 1;
        startLine = endLine;
      }
      if (linesCount > 1 && isCrossDimDefined) {
        var /*float*/nodeCrossAxisInnerSize = node.layout[dim[crossAxis]] - paddingAndBorderAxisCross;
        var /*float*/remainingAlignContentDim = nodeCrossAxisInnerSize - linesCrossDim;
        var /*float*/crossDimLead = 0;
        var /*float*/currentLead = leadingPaddingAndBorderCross;
        var /*css_align_t*/alignContent = getAlignContent(node);
        if (alignContent === CSS_ALIGN_FLEX_END) {
          currentLead += remainingAlignContentDim;
        } else if (alignContent === CSS_ALIGN_CENTER) {
          currentLead += remainingAlignContentDim / 2;
        } else if (alignContent === CSS_ALIGN_STRETCH) {
          if (nodeCrossAxisInnerSize > linesCrossDim) {
            crossDimLead = remainingAlignContentDim / linesCount;
          }
        }
        var /*int*/endIndex = 0;
        for (i = 0; i < linesCount; ++i) {
          var /*int*/startIndex = endIndex;
          var /*float*/lineHeight = 0;
          for (ii = startIndex; ii < childCount; ++ii) {
            child = node.children[ii];
            if (getPositionType(child) !== CSS_POSITION_RELATIVE) {
              continue;
            }
            if (child.lineIndex !== i) {
              break;
            }
            if (!isUndefined(child.layout[dim[crossAxis]])) {
              lineHeight = fmaxf(lineHeight, child.layout[dim[crossAxis]] + getMarginAxis(child, crossAxis));
            }
          }
          endIndex = ii;
          lineHeight += crossDimLead;
          for (ii = startIndex; ii < endIndex; ++ii) {
            child = node.children[ii];
            if (getPositionType(child) !== CSS_POSITION_RELATIVE) {
              continue;
            }
            var /*css_align_t*/alignContentAlignItem = getAlignItem(node, child);
            if (alignContentAlignItem === CSS_ALIGN_FLEX_START) {
              child.layout[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);
            } else if (alignContentAlignItem === CSS_ALIGN_FLEX_END) {
              child.layout[pos[crossAxis]] = currentLead + lineHeight - getTrailingMargin(child, crossAxis) - child.layout[dim[crossAxis]];
            } else if (alignContentAlignItem === CSS_ALIGN_CENTER) {
              var /*float*/childHeight = child.layout[dim[crossAxis]];
              child.layout[pos[crossAxis]] = currentLead + (lineHeight - childHeight) / 2;
            } else if (alignContentAlignItem === CSS_ALIGN_STRETCH) {
              child.layout[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);
            }
          }
          currentLead += lineHeight;
        }
      }
      var /*bool*/needsMainTrailingPos = false;
      var /*bool*/needsCrossTrailingPos = false;
      if (!isMainDimDefined) {
        node.layout[dim[mainAxis]] = fmaxf(
        boundAxis(node, mainAxis, linesMainDim + getTrailingPaddingAndBorder(node, mainAxis)),
        paddingAndBorderAxisMain);
        if (mainAxis === CSS_FLEX_DIRECTION_ROW_REVERSE || mainAxis === CSS_FLEX_DIRECTION_COLUMN_REVERSE) {
          needsMainTrailingPos = true;
        }
      }
      if (!isCrossDimDefined) {
        node.layout[dim[crossAxis]] = fmaxf(
        boundAxis(node, crossAxis, linesCrossDim + paddingAndBorderAxisCross), paddingAndBorderAxisCross);
        if (crossAxis === CSS_FLEX_DIRECTION_ROW_REVERSE || crossAxis === CSS_FLEX_DIRECTION_COLUMN_REVERSE) {
          needsCrossTrailingPos = true;
        }
      }
      if (needsMainTrailingPos || needsCrossTrailingPos) {
        for (i = 0; i < childCount; ++i) {
          child = node.children[i];
          if (needsMainTrailingPos) {
            setTrailingPosition(node, child, mainAxis);
          }
          if (needsCrossTrailingPos) {
            setTrailingPosition(node, child, crossAxis);
          }
        }
      }
      currentAbsoluteChild = firstAbsoluteChild;
      while (currentAbsoluteChild !== null) {
        for (ii = 0; ii < 2; ii++) {
          axis = ii !== 0 ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;
          if (!isUndefined(node.layout[dim[axis]]) && !isDimDefined(currentAbsoluteChild, axis) && isPosDefined(currentAbsoluteChild, leading[axis]) && isPosDefined(currentAbsoluteChild, trailing[axis])) {
            currentAbsoluteChild.layout[dim[axis]] = fmaxf(boundAxis(currentAbsoluteChild, axis, node.layout[dim[axis]] - getBorderAxis(node, axis) - getMarginAxis(currentAbsoluteChild, axis) - getPosition(currentAbsoluteChild, leading[axis]) - getPosition(currentAbsoluteChild, trailing[axis])),
            getPaddingAndBorderAxis(currentAbsoluteChild, axis));
          }
          if (isPosDefined(currentAbsoluteChild, trailing[axis]) && !isPosDefined(currentAbsoluteChild, leading[axis])) {
            currentAbsoluteChild.layout[leading[axis]] = node.layout[dim[axis]] - currentAbsoluteChild.layout[dim[axis]] - getPosition(currentAbsoluteChild, trailing[axis]);
          }
        }
        child = currentAbsoluteChild;
        currentAbsoluteChild = currentAbsoluteChild.nextAbsoluteChild;
        child.nextAbsoluteChild = null;
      }
    }
    function layoutNode(node, parentMaxWidth, parentDirection) {
      node.shouldUpdate = true;
      var direction = node.style.direction || CSS_DIRECTION_LTR;
      var skipLayout = !node.isDirty && node.lastLayout && node.lastLayout.requestedHeight === node.layout.height && node.lastLayout.requestedWidth === node.layout.width && node.lastLayout.parentMaxWidth === parentMaxWidth && node.lastLayout.direction === direction;
      if (skipLayout) {
        node.layout.width = node.lastLayout.width;
        node.layout.height = node.lastLayout.height;
        node.layout.top = node.lastLayout.top;
        node.layout.left = node.lastLayout.left;
      } else {
        if (!node.lastLayout) {
          node.lastLayout = {};
        }
        node.lastLayout.requestedWidth = node.layout.width;
        node.lastLayout.requestedHeight = node.layout.height;
        node.lastLayout.parentMaxWidth = parentMaxWidth;
        node.lastLayout.direction = direction;
        node.children.forEach(function (child) {
          child.layout.width = undefined;
          child.layout.height = undefined;
          child.layout.top = 0;
          child.layout.left = 0;
        });
        layoutNodeImpl(node, parentMaxWidth, parentDirection);
        node.lastLayout.width = node.layout.width;
        node.lastLayout.height = node.layout.height;
        node.lastLayout.top = node.layout.top;
        node.lastLayout.left = node.layout.left;
      }
    }
    return {
      layoutNodeImpl: layoutNodeImpl,
      computeLayout: layoutNode,
      fillNodes: fillNodes
    };
  }();
  {
    module.exports = computeLayout;
  }
  return function (node) {
    computeLayout.fillNodes(node);
    computeLayout.computeLayout(node);
  };
});
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();
function _toConsumableArray(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }return arr2;
  } else {
    return Array.from(arr);
  }
}
function _classCallCheck$4(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var Context = function () {
  function Context() {
    var styles = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck$4(this, Context);
    this.styles = styles;
    this.staged = [];
  }
  _createClass(Context, [{
    key: "addInheritableStyles",
    value: function addInheritableStyles(styles) {
      this.staged.push(styles);
    }
  }, {
    key: "forChildren",
    value: function forChildren() {
      if (this.staged.length === 0) {
        return new Context(this.styles);
      }
      var styles = Object.assign.apply(Object, [{}, this.styles].concat(_toConsumableArray(this.staged)));
      return new Context(styles);
    }
  }, {
    key: "getInheritedStyles",
    value: function getInheritedStyles() {
      return this.styles;
    }
  }]);
  return Context;
}();
var Context_1 = Context;



var types = Object.freeze({

});

var require$$0$13 = ( types && undefined ) || types;

var findFont_1 = createCommonjsModule(function (module, exports) {
'use strict';
Object.defineProperty(exports, "__esModule", {
  value: true
});
var _types = require$$0$13;
var FONT_STYLES = {
  normal: false,
  italic: true,
  oblique: true
};
var FONT_WEIGHTS = {
  normal: NSFontWeightRegular,
  bold: NSFontWeightBold,
  '100': NSFontWeightUltraLight,
  '200': NSFontWeightThin,
  '300': NSFontWeightLight,
  '400': NSFontWeightRegular,
  '500': NSFontWeightMedium,
  '600': NSFontWeightSemibold,
  '700': NSFontWeightBold,
  '800': NSFontWeightHeavy,
  '900': NSFontWeightBlack
};
var isItalicFont = function isItalicFont(font) {
  var traits = font.fontDescriptor().objectForKey(NSFontTraitsAttribute);
  var symbolicTraits = traits[NSFontSymbolicTrait].unsignedIntValue();
  return (symbolicTraits & NSFontItalicTrait) !== 0;
};
var isCondensedFont = function isCondensedFont(font) {
  var traits = font.fontDescriptor().objectForKey(NSFontTraitsAttribute);
  var symbolicTraits = traits[NSFontSymbolicTrait].unsignedIntValue();
  return (symbolicTraits & NSFontCondensedTrait) !== 0;
};
var weightOfFont = function weightOfFont(font) {
  var traits = font.fontDescriptor().objectForKey(NSFontTraitsAttribute);
  var weight = traits[NSFontWeightTrait].doubleValue();
  if (weight === 0.0) {
    var weights = Object.keys(FONT_WEIGHTS);
    for (var i = 0; i < weights.length; i += 1) {
      var w = weights[i];
      if (font.fontName().toLowerCase().endsWith(w)) {
        return FONT_WEIGHTS[w];
      }
    }
  }
  return weight;
};
var fontNamesForFamilyName = function fontNamesForFamilyName(familyName) {
  var manager = NSFontManager.sharedFontManager();
  var members = NSArray.arrayWithArray(manager.availableMembersOfFontFamily(familyName));
  var results = [];
  for (var i = 0; i < members.length; i += 1) {
    results.push(members[i][0]);
  }
  return results;
};
var findFont = function findFont(style) {
  var font = void 0;
  var defaultFontFamily = NSFont.systemFontOfSize(14).familyName();
  var defaultFontWeight = NSFontWeightRegular;
  var defaultFontSize = 14;
  var fontSize = defaultFontSize;
  var fontWeight = defaultFontWeight;
  var familyName = defaultFontFamily;
  var isItalic = false;
  var isCondensed = false;
  if (style.fontSize) {
    fontSize = style.fontSize;
  }
  if (style.fontFamily) {
    familyName = style.fontFamily;
  }
  if (style.fontStyle) {
    isItalic = FONT_STYLES[style.fontStyle] || false;
  }
  if (style.fontWeight) {
    fontWeight = FONT_WEIGHTS[style.fontWeight] || NSFontWeightRegular;
  }
  var didFindFont = false;
  if (familyName === defaultFontFamily || familyName === 'System') {
    font = NSFont.systemFontOfSize_weight(fontSize, fontWeight);
    if (font) {
      didFindFont = true;
      if (isItalic || isCondensed) {
        var fontDescriptor = font.fontDescriptor();
        var symbolicTraits = fontDescriptor.symbolicTraits();
        if (isItalic) {
          symbolicTraits |= NSFontItalicTrait;
        }
        if (isCondensed) {
          symbolicTraits |= NSFontCondensedTrait;
        }
        fontDescriptor = fontDescriptor.fontDescriptorWithSymbolicTraits(symbolicTraits);
        font = NSFont.fontWithDescriptor_size(fontDescriptor, fontSize);
      }
    }
  }
  var fontNames = fontNamesForFamilyName(familyName);
  if (!didFindFont && fontNames.length === 0) {
    font = NSFont.fontWithName_size(familyName, fontSize);
    if (font) {
      familyName = font.familyName();
      fontWeight = style.fontWeight ? fontWeight : weightOfFont(font);
      isItalic = style.fontStyle ? isItalic : isItalicFont(font);
      isCondensed = isCondensedFont(font);
    } else {
      log('Unrecognized font family \'' + familyName + '\'');
      font = NSFont.systemFontOfSize_weight(fontSize, fontWeight);
    }
  }
  var closestWeight = Infinity;
  for (var i = 0; i < fontNames.length; i += 1) {
    var match = NSFont.fontWithName_size(fontNames[i], fontSize);
    if (isItalic === isItalicFont(match) && isCondensed === isCondensedFont(match)) {
      var testWeight = weightOfFont(match);
      if (Math.abs(testWeight - fontWeight) < Math.abs(closestWeight - fontWeight)) {
        font = match;
        closestWeight = testWeight;
      }
    }
  }
  if (!font) {
    if (fontNames.length > 0) {
      font = NSFont.fontWithName_size(fontNames[0], fontSize);
    }
  }
  return font;
};
exports.default = findFont;
});

var createStringMeasurer_1 = createCommonjsModule(function (module) {
'use strict';
var _types = require$$0$13;
var _findFont = findFont_1;
var _findFont2 = _interopRequireDefault(_findFont);
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }return obj;
}
var FLOAT_MAX = 999999;
var createStringMeasurer = function createStringMeasurer(string, style) {
  return function (width) {
    var font = (0, _findFont2.default)(style);
    var attributes = _defineProperty({}, NSFontAttributeName, font);
    if (style.lineHeight !== undefined) {
      var paragraphStyle = NSMutableParagraphStyle.alloc().init();
      paragraphStyle.minimumLineHeight = style.lineHeight;
      paragraphStyle.lineHeightMultiple = 1.0;
      paragraphStyle.maximumLineHeight = style.lineHeight;
      attributes[NSParagraphStyleAttributeName] = paragraphStyle;
    }
    if (style.letterSpacing !== undefined) {
      attributes[NSKernAttributeName] = style.letterSpacing;
    }
    var rect = NSString.alloc().initWithString(string).boundingRectWithSize_options_attributes_context(CGSizeMake(width, FLOAT_MAX), NSStringDrawingUsesLineFragmentOrigin, attributes, null);
    return {
      width: 0 + rect.size.width,
      height: 0 + rect.size.height
    };
  };
};
module.exports = createStringMeasurer;
});

function normalizeColor(color) {
  var match;
  if (typeof color === 'number') {
    if (color >>> 0 === color && color >= 0 && color <= 0xffffffff) {
      return color;
    }
    return null;
  }
  if (match = matchers.hex6.exec(color)) {
    return parseInt(match[1] + 'ff', 16) >>> 0;
  }
  if (names.hasOwnProperty(color)) {
    return names[color];
  }
  if (match = matchers.rgb.exec(color)) {
    return (parse255(match[1]) << 24 |
    parse255(match[2]) << 16 |
    parse255(match[3]) << 8 |
    0x000000ff
    ) >>> 0;
  }
  if (match = matchers.rgba.exec(color)) {
    return (parse255(match[1]) << 24 |
    parse255(match[2]) << 16 |
    parse255(match[3]) << 8 |
    parse1(match[4])
    ) >>> 0;
  }
  if (match = matchers.hex3.exec(color)) {
    return parseInt(match[1] + match[1] +
    match[2] + match[2] +
    match[3] + match[3] +
    'ff',
    16) >>> 0;
  }
  if (match = matchers.hex8.exec(color)) {
    return parseInt(match[1], 16) >>> 0;
  }
  if (match = matchers.hex4.exec(color)) {
    return parseInt(match[1] + match[1] +
    match[2] + match[2] +
    match[3] + match[3] +
    match[4] + match[4],
    16) >>> 0;
  }
  if (match = matchers.hsl.exec(color)) {
    return (hslToRgb(parse360(match[1]),
    parsePercentage(match[2]),
    parsePercentage(match[3])
    ) | 0x000000ff
    ) >>> 0;
  }
  if (match = matchers.hsla.exec(color)) {
    return (hslToRgb(parse360(match[1]),
    parsePercentage(match[2]),
    parsePercentage(match[3])
    ) | parse1(match[4])
    ) >>> 0;
  }
  return null;
}
function hue2rgb(p, q, t) {
  if (t < 0) {
    t += 1;
  }
  if (t > 1) {
    t -= 1;
  }
  if (t < 1 / 6) {
    return p + (q - p) * 6 * t;
  }
  if (t < 1 / 2) {
    return q;
  }
  if (t < 2 / 3) {
    return p + (q - p) * (2 / 3 - t) * 6;
  }
  return p;
}
function hslToRgb(h, s, l) {
  var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
  var p = 2 * l - q;
  var r = hue2rgb(p, q, h + 1 / 3);
  var g = hue2rgb(p, q, h);
  var b = hue2rgb(p, q, h - 1 / 3);
  return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b * 255) << 8;
}
var NUMBER = '[-+]?\\d*\\.?\\d+';
var PERCENTAGE = NUMBER + '%';
function toArray$1(arrayLike) {
  return Array.prototype.slice.call(arrayLike, 0);
}
function call() {
  return '\\(\\s*(' + toArray$1(arguments).join(')\\s*,\\s*(') + ')\\s*\\)';
}
var matchers = {
  rgb: new RegExp('rgb' + call(NUMBER, NUMBER, NUMBER)),
  rgba: new RegExp('rgba' + call(NUMBER, NUMBER, NUMBER, NUMBER)),
  hsl: new RegExp('hsl' + call(NUMBER, PERCENTAGE, PERCENTAGE)),
  hsla: new RegExp('hsla' + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER)),
  hex3: /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex4: /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#([0-9a-fA-F]{6})$/,
  hex8: /^#([0-9a-fA-F]{8})$/
};
function parse255(str) {
  var int = parseInt(str, 10);
  if (int < 0) {
    return 0;
  }
  if (int > 255) {
    return 255;
  }
  return int;
}
function parse360(str) {
  var int = parseFloat(str);
  return (int % 360 + 360) % 360 / 360;
}
function parse1(str) {
  var num = parseFloat(str);
  if (num < 0) {
    return 0;
  }
  if (num > 1) {
    return 255;
  }
  return Math.round(num * 255);
}
function parsePercentage(str) {
  var int = parseFloat(str, 10);
  if (int < 0) {
    return 0;
  }
  if (int > 100) {
    return 1;
  }
  return int / 100;
}
var names = {
  transparent: 0x00000000,
  aliceblue: 0xf0f8ffff,
  antiquewhite: 0xfaebd7ff,
  aqua: 0x00ffffff,
  aquamarine: 0x7fffd4ff,
  azure: 0xf0ffffff,
  beige: 0xf5f5dcff,
  bisque: 0xffe4c4ff,
  black: 0x000000ff,
  blanchedalmond: 0xffebcdff,
  blue: 0x0000ffff,
  blueviolet: 0x8a2be2ff,
  brown: 0xa52a2aff,
  burlywood: 0xdeb887ff,
  burntsienna: 0xea7e5dff,
  cadetblue: 0x5f9ea0ff,
  chartreuse: 0x7fff00ff,
  chocolate: 0xd2691eff,
  coral: 0xff7f50ff,
  cornflowerblue: 0x6495edff,
  cornsilk: 0xfff8dcff,
  crimson: 0xdc143cff,
  cyan: 0x00ffffff,
  darkblue: 0x00008bff,
  darkcyan: 0x008b8bff,
  darkgoldenrod: 0xb8860bff,
  darkgray: 0xa9a9a9ff,
  darkgreen: 0x006400ff,
  darkgrey: 0xa9a9a9ff,
  darkkhaki: 0xbdb76bff,
  darkmagenta: 0x8b008bff,
  darkolivegreen: 0x556b2fff,
  darkorange: 0xff8c00ff,
  darkorchid: 0x9932ccff,
  darkred: 0x8b0000ff,
  darksalmon: 0xe9967aff,
  darkseagreen: 0x8fbc8fff,
  darkslateblue: 0x483d8bff,
  darkslategray: 0x2f4f4fff,
  darkslategrey: 0x2f4f4fff,
  darkturquoise: 0x00ced1ff,
  darkviolet: 0x9400d3ff,
  deeppink: 0xff1493ff,
  deepskyblue: 0x00bfffff,
  dimgray: 0x696969ff,
  dimgrey: 0x696969ff,
  dodgerblue: 0x1e90ffff,
  firebrick: 0xb22222ff,
  floralwhite: 0xfffaf0ff,
  forestgreen: 0x228b22ff,
  fuchsia: 0xff00ffff,
  gainsboro: 0xdcdcdcff,
  ghostwhite: 0xf8f8ffff,
  gold: 0xffd700ff,
  goldenrod: 0xdaa520ff,
  gray: 0x808080ff,
  green: 0x008000ff,
  greenyellow: 0xadff2fff,
  grey: 0x808080ff,
  honeydew: 0xf0fff0ff,
  hotpink: 0xff69b4ff,
  indianred: 0xcd5c5cff,
  indigo: 0x4b0082ff,
  ivory: 0xfffff0ff,
  khaki: 0xf0e68cff,
  lavender: 0xe6e6faff,
  lavenderblush: 0xfff0f5ff,
  lawngreen: 0x7cfc00ff,
  lemonchiffon: 0xfffacdff,
  lightblue: 0xadd8e6ff,
  lightcoral: 0xf08080ff,
  lightcyan: 0xe0ffffff,
  lightgoldenrodyellow: 0xfafad2ff,
  lightgray: 0xd3d3d3ff,
  lightgreen: 0x90ee90ff,
  lightgrey: 0xd3d3d3ff,
  lightpink: 0xffb6c1ff,
  lightsalmon: 0xffa07aff,
  lightseagreen: 0x20b2aaff,
  lightskyblue: 0x87cefaff,
  lightslategray: 0x778899ff,
  lightslategrey: 0x778899ff,
  lightsteelblue: 0xb0c4deff,
  lightyellow: 0xffffe0ff,
  lime: 0x00ff00ff,
  limegreen: 0x32cd32ff,
  linen: 0xfaf0e6ff,
  magenta: 0xff00ffff,
  maroon: 0x800000ff,
  mediumaquamarine: 0x66cdaaff,
  mediumblue: 0x0000cdff,
  mediumorchid: 0xba55d3ff,
  mediumpurple: 0x9370dbff,
  mediumseagreen: 0x3cb371ff,
  mediumslateblue: 0x7b68eeff,
  mediumspringgreen: 0x00fa9aff,
  mediumturquoise: 0x48d1ccff,
  mediumvioletred: 0xc71585ff,
  midnightblue: 0x191970ff,
  mintcream: 0xf5fffaff,
  mistyrose: 0xffe4e1ff,
  moccasin: 0xffe4b5ff,
  navajowhite: 0xffdeadff,
  navy: 0x000080ff,
  oldlace: 0xfdf5e6ff,
  olive: 0x808000ff,
  olivedrab: 0x6b8e23ff,
  orange: 0xffa500ff,
  orangered: 0xff4500ff,
  orchid: 0xda70d6ff,
  palegoldenrod: 0xeee8aaff,
  palegreen: 0x98fb98ff,
  paleturquoise: 0xafeeeeff,
  palevioletred: 0xdb7093ff,
  papayawhip: 0xffefd5ff,
  peachpuff: 0xffdab9ff,
  peru: 0xcd853fff,
  pink: 0xffc0cbff,
  plum: 0xdda0ddff,
  powderblue: 0xb0e0e6ff,
  purple: 0x800080ff,
  rebeccapurple: 0x663399ff,
  red: 0xff0000ff,
  rosybrown: 0xbc8f8fff,
  royalblue: 0x4169e1ff,
  saddlebrown: 0x8b4513ff,
  salmon: 0xfa8072ff,
  sandybrown: 0xf4a460ff,
  seagreen: 0x2e8b57ff,
  seashell: 0xfff5eeff,
  sienna: 0xa0522dff,
  silver: 0xc0c0c0ff,
  skyblue: 0x87ceebff,
  slateblue: 0x6a5acdff,
  slategray: 0x708090ff,
  slategrey: 0x708090ff,
  snow: 0xfffafaff,
  springgreen: 0x00ff7fff,
  steelblue: 0x4682b4ff,
  tan: 0xd2b48cff,
  teal: 0x008080ff,
  thistle: 0xd8bfd8ff,
  tomato: 0xff6347ff,
  turquoise: 0x40e0d0ff,
  violet: 0xee82eeff,
  wheat: 0xf5deb3ff,
  white: 0xffffffff,
  whitesmoke: 0xf5f5f5ff,
  yellow: 0xffff00ff,
  yellowgreen: 0x9acd32ff
};
function rgba(colorInt) {
  var r = Math.round((colorInt & 0xff000000) >>> 24);
  var g = Math.round((colorInt & 0x00ff0000) >>> 16);
  var b = Math.round((colorInt & 0x0000ff00) >>> 8);
  var a = ((colorInt & 0x000000ff) >>> 0) / 255;
  return {
    r: r,
    g: g,
    b: b,
    a: a
  };
}
normalizeColor.rgba = rgba;
var index$8 = normalizeColor;

var convertToColor_1 = createCommonjsModule(function (module) {
'use strict';
var _normalizeCssColor = index$8;
var _normalizeCssColor2 = _interopRequireDefault(_normalizeCssColor);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}
var convertToColor = function convertToColor(input) {
    var nullableColor = (0, _normalizeCssColor2.default)(input);
    var colorInt = nullableColor == null ? 0x00000000 : nullableColor;
    var _normalizeColor$rgba = _normalizeCssColor2.default.rgba(colorInt),
        r = _normalizeColor$rgba.r,
        g = _normalizeColor$rgba.g,
        b = _normalizeColor$rgba.b,
        a = _normalizeColor$rgba.a;
    return MSColor.colorWithRGBADictionary({ r: r / 255, g: g / 255, b: b / 255, a: a });
};
module.exports = convertToColor;
});

var _createClass$1 = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();
function _classCallCheck$5(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var SketchRenderer = function () {
  function SketchRenderer() {
    _classCallCheck$5(this, SketchRenderer);
  }
  _createClass$1(SketchRenderer, [{
    key: 'getDefaultGroupName',
    value: function getDefaultGroupName() /* props: any, value: ?string */{
      return 'Group';
    }
  }, {
    key: 'renderGroupLayer',
    value: function renderGroupLayer(layout, style, textStyle, props,
    value) {
      var layer = MSLayerGroup.alloc().init();
      layer.frame().setX(layout.left);
      layer.frame().setY(layout.top);
      layer.frame().setWidth(layout.width);
      layer.frame().setHeight(layout.height);
      if (props.name) {
        layer.setName(props.name);
      } else {
        layer.setName(this.getDefaultGroupName(props, value));
      }
      if (style.opacity !== undefined) {
        layer.style().contextSettings().opacity = style.opacity;
      }
      return layer;
    }
  }, {
    key: 'renderBackingLayers',
    value: function renderBackingLayers(layout, style, textStyle, props,
    value) {
      return [];
    }
  }]);
  return SketchRenderer;
}();
var SketchRenderer_1 = SketchRenderer;

var ArtboardRenderer_1 = createCommonjsModule(function (module) {
'use strict';
var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();
var _convertToColor = convertToColor_1;
var _convertToColor2 = _interopRequireDefault(_convertToColor);
var _SketchRenderer2 = SketchRenderer_1;
var _SketchRenderer3 = _interopRequireDefault(_SketchRenderer2);
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && (typeof call === "object" || typeof call === "function") ? call : self;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var ArtboardRenderer = function (_SketchRenderer) {
  _inherits(ArtboardRenderer, _SketchRenderer);
  function ArtboardRenderer() {
    _classCallCheck(this, ArtboardRenderer);
    return _possibleConstructorReturn(this, (ArtboardRenderer.__proto__ || Object.getPrototypeOf(ArtboardRenderer)).apply(this, arguments));
  }
  _createClass(ArtboardRenderer, [{
    key: 'renderGroupLayer',
    value: function renderGroupLayer(layout, style, textStyle, props,
    value) {
      var layer = MSArtboardGroup.alloc().init();
      layer.frame = MSRect.rectWithRect(NSMakeRect(layout.top, layout.left, layout.width, layout.height));
      if (props.name !== undefined) {
        layer.setName(props.name);
      }
      if (style.backgroundColor !== undefined) {
        layer.setBackgroundColor((0, _convertToColor2.default)(style.backgroundColor));
        layer.hasBackgroundColor = true;
      }
      return layer;
    }
  }]);
  return ArtboardRenderer;
}(_SketchRenderer3.default);
module.exports = ArtboardRenderer;
});

var processTransform_1 = createCommonjsModule(function (module, exports) {
'use strict';
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = processTransform;
function CGAffineTransformMake(a, b, c, d, tx, ty) {
  return { a: a, b: b, c: c, d: d, tx: tx, ty: ty };
}
function convertToRadians(value) {
  var floatValue = parseFloat(value, 10);
  return value.indexOf('rad') > -1 ? floatValue : floatValue * Math.PI / 180;
}
var IDENTITY = CGAffineTransformMake(1, 0, 0, 1, 0, 0);
var TRANSLATE = CGAffineTransformMakeTranslation(-0.5, -0.5);
var UNTRANSLATE = CGAffineTransformMakeTranslation(0.5, 0.5);
function makeTransformFromKeyValue(layout, key, value) {
  var transform = IDENTITY;
  switch (key) {
    case 'perspective':
      break;
    case 'rotate':
    case 'rotateZ':
      transform = CGAffineTransformMakeRotation(convertToRadians(value));
      break;
    case 'rotateX':
    case 'rotateY':
      break;
    case 'scale':
      transform = CGAffineTransformMakeScale(value, value);
      break;
    case 'scaleX':
      transform = CGAffineTransformMakeScale(value, 1);
      break;
    case 'scaleY':
      transform = CGAffineTransformMakeScale(1, value);
      break;
    case 'translateX':
      transform = CGAffineTransformMakeTranslation(value / layout.width, 0);
      break;
    case 'translateY':
      transform = CGAffineTransformMakeTranslation(0, value / layout.height);
      break;
    case 'skewX':
      {
        var rads = convertToRadians(value);
        transform = CGAffineTransformMake(1, 0, Math.sin(rads), Math.cos(rads), 0, 0);
      }break;
    case 'skewY':
      {
        var _rads = convertToRadians(value);
        transform = CGAffineTransformMake(Math.cos(_rads), Math.sin(_rads), 0, 1, 0, 0);
      }break;
    default:
      log('did an unsupported transform: ' + key + ': ' + value);
      break;
  }
  return transform;
}
function transformFromTransformArray(layout, transforms) {
  var transform = IDENTITY;
  transforms.forEach(function (t) {
    Object.keys(t).forEach(function (key) {
      transform = CGAffineTransformConcat(transform, makeTransformFromKeyValue(layout, key, t[key]));
    });
  });
  return transform;
}
function processTransform(rect, layout, transforms) {
  var transform = transformFromTransformArray(layout, transforms);
  transform = CGAffineTransformConcat(TRANSLATE, transform);
  transform = CGAffineTransformConcat(transform, UNTRANSLATE);
  rect.applyAffineTransformToPath(transform);
}
});

var ImageRenderer_1 = createCommonjsModule(function (module) {
'use strict';
var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();
var _convertToColor = convertToColor_1;
var _convertToColor2 = _interopRequireDefault(_convertToColor);
var _SketchRenderer2 = SketchRenderer_1;
var _SketchRenderer3 = _interopRequireDefault(_SketchRenderer2);
var _processTransform = processTransform_1;
var _processTransform2 = _interopRequireDefault(_processTransform);
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && (typeof call === "object" || typeof call === "function") ? call : self;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var FILL_TYPE = {
  Solid: 0,
  Gradient: 1,
  Pattern: 4,
  Noise: 5
};
var PATTERN_FILL_TYPE = {
  Tile: 0,
  Fill: 1,
  Stretch: 2,
  Fit: 3
};
function makeRect(x, y, width, height, color) {
  var rect = MSRectangleShape.alloc().init();
  rect.frame = MSRect.rectWithRect(NSMakeRect(x, y, width, height));
  var layer = MSShapeGroup.shapeWithPath(rect);
  if (color !== undefined) {
    var fillStyle = layer.style().addStylePartOfType(0);
    fillStyle.color = (0, _convertToColor2.default)(color);
  }
  return layer;
}
function same(a, b, c, d) {
  return a === b && b === c && c === d;
}
function extractURLFromSource(source) {
  if (typeof source === 'string') {
    return source;
  }
  return source.uri;
}
var ImageRenderer = function (_SketchRenderer) {
  _inherits(ImageRenderer, _SketchRenderer);
  function ImageRenderer() {
    _classCallCheck(this, ImageRenderer);
    return _possibleConstructorReturn(this, (ImageRenderer.__proto__ || Object.getPrototypeOf(ImageRenderer)).apply(this, arguments));
  }
  _createClass(ImageRenderer, [{
    key: 'renderBackingLayers',
    value: function renderBackingLayers(layout, style, textStyle, props,
    value) {
      var bl = style.borderLeftWidth || 0;
      var br = style.borderRightWidth || 0;
      var bt = style.borderTopWidth || 0;
      var bb = style.borderBottomWidth || 0;
      var btlr = style.borderTopLeftRadius || 0;
      var btrr = style.borderTopRightRadius || 0;
      var bbrr = style.borderBottomRightRadius || 0;
      var bblr = style.borderBottomLeftRadius || 0;
      var layers = [];
      var rect = MSRectangleShape.alloc().init();
      rect.frame = MSRect.rectWithRect(NSMakeRect(0, 0, layout.width, layout.height));
      rect.setCornerRadiusFromComponents(btlr + '/' + btrr + '/' + bbrr + '/' + bblr);
      var content = MSShapeGroup.shapeWithPath(rect);
      if (style.backgroundColor !== undefined) {
        var fillStyle = content.style().addStylePartOfType(0);
        fillStyle.color = (0, _convertToColor2.default)(style.backgroundColor);
      }
      var imageFill = content.style().addStylePartOfType(0);
      var imageData = NSImage.alloc().initByReferencingURL(NSURL.URLWithString(extractURLFromSource(props.source)));
      imageFill.setImage(MSImageData.alloc().initWithImage_convertColorSpace(imageData, false));
      imageFill.setFillType(FILL_TYPE.Pattern);
      imageFill.setPatternFillType(PATTERN_FILL_TYPE[props.resizeMode] || PATTERN_FILL_TYPE.Fill);
      if (style.transform !== undefined) {
        (0, _processTransform2.default)(rect, layout, style.transform);
      }
      layers.push(content);
      if (same(bl, br, bt, bb)) {
        var borderStyle = content.style().addStylePartOfType(1);
        borderStyle.setFillType(0);
        if (style.borderTopColor !== undefined) {
          borderStyle.setColor((0, _convertToColor2.default)(style.borderTopColor));
        }
        borderStyle.setThickness(style.borderTopWidth || 0);
        borderStyle.setPosition(2);
      } else {
        if (bt > 0) {
          var topBorder = makeRect(0, 0, layout.width, bt, style.borderTopColor);
          layers.push(topBorder);
        }
        if (bl > 0) {
          var leftBorder = makeRect(0, 0, bl, layout.height, style.borderLeftColor);
          layers.push(leftBorder);
        }
        if (bb > 0) {
          var bottomBorder = makeRect(0, layout.height - bb, layout.width, bb, style.borderBottomColor);
          layers.push(bottomBorder);
        }
        if (br > 0) {
          var rightBorder = makeRect(layout.width - br, 0, br, layout.height, style.borderRightColor);
          layers.push(rightBorder);
        }
      }
      return layers;
    }
  }]);
  return ImageRenderer;
}(_SketchRenderer3.default);
module.exports = ImageRenderer;
});

var colorWithOpacity_1 = createCommonjsModule(function (module) {
'use strict';
var _normalizeCssColor = index$8;
var _normalizeCssColor2 = _interopRequireDefault(_normalizeCssColor);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}
var colorWithOpacity = function colorWithOpacity(input, opacity) {
    var nullableColor = (0, _normalizeCssColor2.default)(input);
    var colorInt = nullableColor == null ? 0x00000000 : nullableColor;
    var _normalizeColor$rgba = _normalizeCssColor2.default.rgba(colorInt),
        r = _normalizeColor$rgba.r,
        g = _normalizeColor$rgba.g,
        b = _normalizeColor$rgba.b,
        a = _normalizeColor$rgba.a;
    return MSColor.colorWithRGBADictionary({ r: r / 255, g: g / 255, b: b / 255, a: a * opacity });
};
module.exports = colorWithOpacity;
});

var ViewRenderer_1 = createCommonjsModule(function (module) {
'use strict';
var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();
var _convertToColor = convertToColor_1;
var _convertToColor2 = _interopRequireDefault(_convertToColor);
var _colorWithOpacity = colorWithOpacity_1;
var _colorWithOpacity2 = _interopRequireDefault(_colorWithOpacity);
var _SketchRenderer2 = SketchRenderer_1;
var _SketchRenderer3 = _interopRequireDefault(_SketchRenderer2);
var _processTransform = processTransform_1;
var _processTransform2 = _interopRequireDefault(_processTransform);
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && (typeof call === "object" || typeof call === "function") ? call : self;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var hasAnyDefined = function hasAnyDefined(obj, names) {
  return names.some(function (key) {
    return obj[key] !== undefined;
  });
};
var DEFAULT_BORDER_COLOR = '#000';
var DEFAULT_BORDER_STYLE = 'solid';
var DEFAULT_SHADOW_COLOR = '#000';
var DEFAULT_BACKGROUND_COLOR = '#fff';
var TRANSPARENT = (0, _convertToColor2.default)('transparent');
var VISIBLE_STYLES = ['shadowColor', 'shadowOffset', 'shadowOpacity', 'shadowRadius', 'backgroundColor', 'borderColor', 'borderTopColor', 'borderRightColor', 'borderBottomColor', 'borderLeftColor', 'borderStyle', 'borderTopStyle', 'borderRightStyle', 'borderBottomStyle', 'borderLeftStyle', 'borderWidth', 'borderTopWidth', 'borderRightWidth', 'borderBottomWidth', 'borderLeftWidth'];
var SHADOW_STYLES = ['shadowColor', 'shadowOffset', 'shadowOpacity', 'shadowRadius'];
function addShadowToLayer(content, style) {
  var shadowStyle = content.style().addStylePartOfType(2);
  var opacity = style.shadowOpacity !== undefined ? style.shadowOpacity : 1;
  var color = style.shadowColor || DEFAULT_SHADOW_COLOR;
  var radius = style.shadowRadius !== undefined ? style.shadowRadius : 1;
  shadowStyle.color = (0, _colorWithOpacity2.default)(color, opacity);
  shadowStyle.blurRadius = radius * 2;
  if (style.shadowOffset) {
    shadowStyle.offsetX = style.shadowOffset.width || 0;
    shadowStyle.offsetY = style.shadowOffset.height || 0;
  }
}
function makeRect(x, y, width, height, color) {
  var rect = MSRectangleShape.alloc().init();
  rect.frame = MSRect.rectWithRect(NSMakeRect(x, y, width, height));
  var layer = MSShapeGroup.shapeWithPath(rect);
  if (color !== undefined) {
    var fillStyle = layer.style().addStylePartOfType(0);
    fillStyle.color = (0, _convertToColor2.default)(color);
  }
  return layer;
}
function makeBorderFromRect(rect, thickness, color, style) {
  var layer = MSShapeGroup.shapeWithPath(rect);
  layer.style().addStylePartOfType(0).color = TRANSPARENT;
  var borderStyle = layer.style().addStylePartOfType(1);
  var borderOptions = layer.style().borderOptions();
  borderStyle.setFillType(0);
  borderStyle.setThickness(thickness || 0);
  borderStyle.setPosition(1);
  borderStyle.setColor((0, _convertToColor2.default)(color || DEFAULT_BORDER_COLOR));
  switch (style) {
    case 'dashed':
      borderOptions.setDashPattern([thickness * 3, thickness * 4]);
      break;
    case 'dotted':
      borderOptions.setDashPattern([thickness / 2, thickness / 2]);
      borderOptions.setLineJoinStyle(0);
      break;
    case 'solid':
    default:
      break;
  }
  return layer;
}
function makeVerticalBorder(x, y, length, thickness, color, style) {
  var rect = MSRectangleShape.alloc().init();
  rect.frame = MSRect.rectWithRect(NSMakeRect(x, y, thickness, length));
  return makeBorderFromRect(rect, thickness, color, style);
}
function makeHorizontalBorder(x, y, length, thickness, color, style) {
  var rect = MSRectangleShape.alloc().init();
  rect.frame = MSRect.rectWithRect(NSMakeRect(x, y, length, thickness));
  return makeBorderFromRect(rect, thickness, color, style);
}
function same(a, b, c, d) {
  return a === b && b === c && c === d;
}
var ViewRenderer = function (_SketchRenderer) {
  _inherits(ViewRenderer, _SketchRenderer);
  function ViewRenderer() {
    _classCallCheck(this, ViewRenderer);
    return _possibleConstructorReturn(this, (ViewRenderer.__proto__ || Object.getPrototypeOf(ViewRenderer)).apply(this, arguments));
  }
  _createClass(ViewRenderer, [{
    key: 'getDefaultGroupName',
    value: function getDefaultGroupName() /* props: any, value: ?string */{
      return 'View';
    }
  }, {
    key: 'renderBackingLayers',
    value: function renderBackingLayers(layout, style, textStyle, props,
    value) {
      var layers = [];
      var bl = style.borderLeftWidth || 0;
      var br = style.borderRightWidth || 0;
      var bt = style.borderTopWidth || 0;
      var bb = style.borderBottomWidth || 0;
      var btlr = style.borderTopLeftRadius || 0;
      var btrr = style.borderTopRightRadius || 0;
      var bbrr = style.borderBottomRightRadius || 0;
      var bblr = style.borderBottomLeftRadius || 0;
      var bcl = style.borderLeftColor || DEFAULT_BORDER_COLOR;
      var bcr = style.borderRightColor || DEFAULT_BORDER_COLOR;
      var bct = style.borderTopColor || DEFAULT_BORDER_COLOR;
      var bcb = style.borderBottomColor || DEFAULT_BORDER_COLOR;
      var bsl = style.borderLeftStyle || DEFAULT_BORDER_STYLE;
      var bsr = style.borderRightStyle || DEFAULT_BORDER_STYLE;
      var bst = style.borderTopStyle || DEFAULT_BORDER_STYLE;
      var bsb = style.borderBottomStyle || DEFAULT_BORDER_STYLE;
      if (!hasAnyDefined(style, VISIBLE_STYLES)) {
      } else if (same(bl, br, bt, bb) && same(bcl, bcr, bct, bcb) && same(bsl, bsr, bst, bsb)) {
        var rect = MSRectangleShape.alloc().init();
        rect.frame = MSRect.rectWithRect(NSMakeRect(bl, bt, layout.width - bl - br, layout.height - bt - bb));
        rect.setCornerRadiusFromComponents(btlr + '/' + btrr + '/' + bbrr + '/' + bblr);
        if (style.transform !== undefined) {
          (0, _processTransform2.default)(rect, layout, style.transform);
        }
        var content = MSShapeGroup.shapeWithPath(rect);
        content.setName('Content');
        var fillStyle = content.style().addStylePartOfType(0);
        fillStyle.color = (0, _convertToColor2.default)(style.backgroundColor || DEFAULT_BACKGROUND_COLOR);
        if (hasAnyDefined(style, SHADOW_STYLES)) {
          addShadowToLayer(content, style);
        }
        var borderStyle = content.style().addStylePartOfType(1);
        borderStyle.setFillType(0);
        if (style.borderTopStyle !== undefined) {
          var borderOptions = content.style().borderOptions();
          var width = style.borderTopWidth;
          switch (style.borderTopStyle) {
            case 'dashed':
              borderOptions.setDashPattern([width * 3, width * 3]);
              break;
            case 'dotted':
              borderOptions.setDashPattern([width, width]);
              borderOptions.setLineJoinStyle(0);
              break;
            case 'solid':
            default:
              break;
          }
        }
        if (style.borderTopColor !== undefined) {
          borderStyle.setColor((0, _convertToColor2.default)(style.borderTopColor));
        }
        borderStyle.setThickness(style.borderTopWidth || 0);
        borderStyle.setPosition(2);
        layers.push(content);
      } else {
        var _content = makeRect(bl, bt, layout.width - bl - br, layout.height - bt - bb, style.backgroundColor || DEFAULT_BACKGROUND_COLOR);
        if (hasAnyDefined(style, SHADOW_STYLES)) {
          addShadowToLayer(_content, style);
        }
        _content.setName('Content');
        layers.push(_content);
        if (bt > 0) {
          var topBorder = makeHorizontalBorder(0, 0, layout.width, bt, bct, bst);
          topBorder.setName('Border (top)');
          layers.push(topBorder);
        }
        if (bl > 0) {
          var leftBorder = makeVerticalBorder(0, 0, layout.height, bl, bcl, bsl);
          leftBorder.setName('Border (left)');
          layers.push(leftBorder);
        }
        if (bb > 0) {
          var bottomBorder = makeHorizontalBorder(0, layout.height - bb, layout.width, bb, bcb, bsb);
          bottomBorder.setName('Border (bottom)');
          layers.push(bottomBorder);
        }
        if (br > 0) {
          var rightBorder = makeVerticalBorder(layout.width - br, 0, layout.height, br, bcr, bsr);
          rightBorder.setName('Border (right)');
          layers.push(rightBorder);
        }
      }
      return layers;
    }
  }]);
  return ViewRenderer;
}(_SketchRenderer3.default);
module.exports = ViewRenderer;
});

var TextRenderer_1 = createCommonjsModule(function (module) {
'use strict';
var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();
var _convertToColor = convertToColor_1;
var _convertToColor2 = _interopRequireDefault(_convertToColor);
var _SketchRenderer2 = SketchRenderer_1;
var _SketchRenderer3 = _interopRequireDefault(_SketchRenderer2);
var _ViewRenderer = ViewRenderer_1;
var _ViewRenderer2 = _interopRequireDefault(_ViewRenderer);
var _findFont = findFont_1;
var _findFont2 = _interopRequireDefault(_findFont);
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && (typeof call === "object" || typeof call === "function") ? call : self;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var TEXT_ALIGN = {
  auto: 0,
  left: 0,
  right: 1,
  center: 2,
  justify: 3
};
var TEXT_BEHAVIOR = {
  auto: 0,
  fixed: 1
};
var TextRenderer = function (_SketchRenderer) {
  _inherits(TextRenderer, _SketchRenderer);
  function TextRenderer() {
    _classCallCheck(this, TextRenderer);
    return _possibleConstructorReturn(this, (TextRenderer.__proto__ || Object.getPrototypeOf(TextRenderer)).apply(this, arguments));
  }
  _createClass(TextRenderer, [{
    key: 'getDefaultGroupName',
    value: function getDefaultGroupName(props, value) {
      return value || 'Text';
    }
  }, {
    key: 'renderBackingLayers',
    value: function renderBackingLayers(layout, style, textStyle, props, value) {
      if (value === null) {
        var viewRenderer = new _ViewRenderer2.default();
        return viewRenderer.renderBackingLayers(layout, style, textStyle, props, value);
      }
      var layer = MSTextLayer.alloc().initWithFrame_(NSMakeRect(layout.left, layout.top, layout.width, layout.height));
      layer.setStringValue(value);
      layer.setName(value);
      var font = (0, _findFont2.default)(textStyle);
      layer.setFont(font);
      if (textStyle.color !== undefined) {
        layer.setTextColor((0, _convertToColor2.default)(textStyle.color));
      }
      if (textStyle.lineHeight !== undefined) {
        layer.setLineHeight(textStyle.lineHeight);
      }
      if (textStyle.letterSpacing !== undefined) {
        layer.setCharacterSpacing(textStyle.letterSpacing);
      }
      if (textStyle.textAlign) {
        layer.setTextAlignment(TEXT_ALIGN[textStyle.textAlign]);
      }
      if (style.opacity !== undefined) {
        layer.style().contextSettings().opacity = style.opacity;
      }
      layer.setTextBehaviour(TEXT_BEHAVIOR.fixed);
      layer.frame().setWidth(layout.width);
      layer.frame().setHeight(layout.height);
      return [layer];
    }
  }]);
  return TextRenderer;
}(_SketchRenderer3.default);
module.exports = TextRenderer;
});

var renderers = {
  artboard: ArtboardRenderer_1,
  image: ImageRenderer_1,
  text: TextRenderer_1,
  view: ViewRenderer_1
};
var index$6 = renderers;

var stackframe = createCommonjsModule(function (module, exports) {
(function (root, factory) {
    'use strict';
    if (typeof undefined === 'function' && undefined.amd) {
        undefined('stackframe', [], factory);
    } else {
        module.exports = factory();
    }
})(commonjsGlobal, function () {
    'use strict';
    function _isNumber(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
    }
    function _capitalize(str) {
        return str[0].toUpperCase() + str.substring(1);
    }
    function _getter(p) {
        return function () {
            return this[p];
        };
    }
    var booleanProps = ['isConstructor', 'isEval', 'isNative', 'isToplevel'];
    var numericProps = ['columnNumber', 'lineNumber'];
    var stringProps = ['fileName', 'functionName', 'source'];
    var arrayProps = ['args'];
    function StackFrame(obj) {
        if (obj instanceof Object) {
            var props = booleanProps.concat(numericProps.concat(stringProps.concat(arrayProps)));
            for (var i = 0; i < props.length; i++) {
                if (obj.hasOwnProperty(props[i]) && obj[props[i]] !== undefined) {
                    this['set' + _capitalize(props[i])](obj[props[i]]);
                }
            }
        }
    }
    StackFrame.prototype = {
        getArgs: function () {
            return this.args;
        },
        setArgs: function (v) {
            if (Object.prototype.toString.call(v) !== '[object Array]') {
                throw new TypeError('Args must be an Array');
            }
            this.args = v;
        },
        getEvalOrigin: function () {
            return this.evalOrigin;
        },
        setEvalOrigin: function (v) {
            if (v instanceof StackFrame) {
                this.evalOrigin = v;
            } else if (v instanceof Object) {
                this.evalOrigin = new StackFrame(v);
            } else {
                throw new TypeError('Eval Origin must be an Object or StackFrame');
            }
        },
        toString: function () {
            var functionName = this.getFunctionName() || '{anonymous}';
            var args = '(' + (this.getArgs() || []).join(',') + ')';
            var fileName = this.getFileName() ? '@' + this.getFileName() : '';
            var lineNumber = _isNumber(this.getLineNumber()) ? ':' + this.getLineNumber() : '';
            var columnNumber = _isNumber(this.getColumnNumber()) ? ':' + this.getColumnNumber() : '';
            return functionName + args + fileName + lineNumber + columnNumber;
        }
    };
    for (var i = 0; i < booleanProps.length; i++) {
        StackFrame.prototype['get' + _capitalize(booleanProps[i])] = _getter(booleanProps[i]);
        StackFrame.prototype['set' + _capitalize(booleanProps[i])] = function (p) {
            return function (v) {
                this[p] = Boolean(v);
            };
        }(booleanProps[i]);
    }
    for (var j = 0; j < numericProps.length; j++) {
        StackFrame.prototype['get' + _capitalize(numericProps[j])] = _getter(numericProps[j]);
        StackFrame.prototype['set' + _capitalize(numericProps[j])] = function (p) {
            return function (v) {
                if (!_isNumber(v)) {
                    throw new TypeError(p + ' must be a Number');
                }
                this[p] = Number(v);
            };
        }(numericProps[j]);
    }
    for (var k = 0; k < stringProps.length; k++) {
        StackFrame.prototype['get' + _capitalize(stringProps[k])] = _getter(stringProps[k]);
        StackFrame.prototype['set' + _capitalize(stringProps[k])] = function (p) {
            return function (v) {
                this[p] = String(v);
            };
        }(stringProps[k]);
    }
    return StackFrame;
});
});

var errorStackParser = createCommonjsModule(function (module, exports) {
(function (root, factory) {
    'use strict';
    if (typeof undefined === 'function' && undefined.amd) {
        undefined('error-stack-parser', ['stackframe'], factory);
    } else {
        module.exports = factory(stackframe);
    }
})(commonjsGlobal, function ErrorStackParser(StackFrame) {
    'use strict';
    var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\S+\:\d+/;
    var CHROME_IE_STACK_REGEXP = /^\s*at .*(\S+\:\d+|\(native\))/m;
    var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\[native code\])?$/;
    return {
        parse: function ErrorStackParser$$parse(error) {
            if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {
                return this.parseOpera(error);
            } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {
                return this.parseV8OrIE(error);
            } else if (error.stack) {
                return this.parseFFOrSafari(error);
            } else {
                throw new Error('Cannot parse given Error object');
            }
        },
        extractLocation: function ErrorStackParser$$extractLocation(urlLike) {
            if (urlLike.indexOf(':') === -1) {
                return [urlLike];
            }
            var regExp = /(.+?)(?:\:(\d+))?(?:\:(\d+))?$/;
            var parts = regExp.exec(urlLike.replace(/[\(\)]/g, ''));
            return [parts[1], parts[2] || undefined, parts[3] || undefined];
        },
        parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {
            var filtered = error.stack.split('\n').filter(function (line) {
                return !!line.match(CHROME_IE_STACK_REGEXP);
            }, this);
            return filtered.map(function (line) {
                if (line.indexOf('(eval ') > -1) {
                    line = line.replace(/eval code/g, 'eval').replace(/(\(eval at [^\()]*)|(\)\,.*$)/g, '');
                }
                var tokens = line.replace(/^\s+/, '').replace(/\(eval code/g, '(').split(/\s+/).slice(1);
                var locationParts = this.extractLocation(tokens.pop());
                var functionName = tokens.join(' ') || undefined;
                var fileName = ['eval', '<anonymous>'].indexOf(locationParts[0]) > -1 ? undefined : locationParts[0];
                return new StackFrame({
                    functionName: functionName,
                    fileName: fileName,
                    lineNumber: locationParts[1],
                    columnNumber: locationParts[2],
                    source: line
                });
            }, this);
        },
        parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {
            var filtered = error.stack.split('\n').filter(function (line) {
                return !line.match(SAFARI_NATIVE_CODE_REGEXP);
            }, this);
            return filtered.map(function (line) {
                if (line.indexOf(' > eval') > -1) {
                    line = line.replace(/ line (\d+)(?: > eval line \d+)* > eval\:\d+\:\d+/g, ':$1');
                }
                if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {
                    return new StackFrame({
                        functionName: line
                    });
                } else {
                    var tokens = line.split('@');
                    var locationParts = this.extractLocation(tokens.pop());
                    var functionName = tokens.join('@') || undefined;
                    return new StackFrame({
                        functionName: functionName,
                        fileName: locationParts[0],
                        lineNumber: locationParts[1],
                        columnNumber: locationParts[2],
                        source: line
                    });
                }
            }, this);
        },
        parseOpera: function ErrorStackParser$$parseOpera(e) {
            if (!e.stacktrace || e.message.indexOf('\n') > -1 && e.message.split('\n').length > e.stacktrace.split('\n').length) {
                return this.parseOpera9(e);
            } else if (!e.stack) {
                return this.parseOpera10(e);
            } else {
                return this.parseOpera11(e);
            }
        },
        parseOpera9: function ErrorStackParser$$parseOpera9(e) {
            var lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
            var lines = e.message.split('\n');
            var result = [];
            for (var i = 2, len = lines.length; i < len; i += 2) {
                var match = lineRE.exec(lines[i]);
                if (match) {
                    result.push(new StackFrame({
                        fileName: match[2],
                        lineNumber: match[1],
                        source: lines[i]
                    }));
                }
            }
            return result;
        },
        parseOpera10: function ErrorStackParser$$parseOpera10(e) {
            var lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
            var lines = e.stacktrace.split('\n');
            var result = [];
            for (var i = 0, len = lines.length; i < len; i += 2) {
                var match = lineRE.exec(lines[i]);
                if (match) {
                    result.push(new StackFrame({
                        functionName: match[3] || undefined,
                        fileName: match[2],
                        lineNumber: match[1],
                        source: lines[i]
                    }));
                }
            }
            return result;
        },
        parseOpera11: function ErrorStackParser$$parseOpera11(error) {
            var filtered = error.stack.split('\n').filter(function (line) {
                return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);
            }, this);
            return filtered.map(function (line) {
                var tokens = line.split('@');
                var locationParts = this.extractLocation(tokens.pop());
                var functionCall = tokens.shift() || '';
                var functionName = functionCall.replace(/<anonymous function(: (\w+))?>/, '$2').replace(/\([^\)]*\)/g, '') || undefined;
                var argsRaw;
                if (functionCall.match(/\(([^\)]*)\)/)) {
                    argsRaw = functionCall.replace(/^[^\(]+\(([^\)]*)\)$/, '$1');
                }
                var args = argsRaw === undefined || argsRaw === '[arguments not available]' ? undefined : argsRaw.split(',');
                return new StackFrame({
                    functionName: functionName,
                    args: args,
                    fileName: locationParts[0],
                    lineNumber: locationParts[1],
                    columnNumber: locationParts[2],
                    source: line
                });
            }, this);
        }
    };
});
});

var hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var styleShortHands = {
  borderColor: {
    borderTopColor: true,
    borderRightColor: true,
    borderBottomColor: true,
    borderLeftColor: true
  },
  borderRadius: {
    borderTopLeftRadius: true,
    borderTopRightRadius: true,
    borderBottomRightRadius: true,
    borderBottomLeftRadius: true
  },
  borderStyle: {
    borderTopStyle: true,
    borderRightStyle: true,
    borderBottomStyle: true,
    borderLeftStyle: true
  },
  borderWidth: {
    borderTopWidth: true,
    borderRightWidth: true,
    borderBottomWidth: true,
    borderLeftWidth: true
  },
  margin: {
    marginTop: true,
    marginRight: true,
    marginBottom: true,
    marginLeft: true
  },
  marginHorizontal: {
    marginRight: true,
    marginLeft: true
  },
  marginVertical: {
    marginTop: true,
    marginBottom: true
  },
  overflow: {
    overflowX: true,
    overflowY: true
  },
  padding: {
    paddingTop: true,
    paddingRight: true,
    paddingBottom: true,
    paddingLeft: true
  },
  paddingHorizontal: {
    paddingRight: true,
    paddingLeft: true
  },
  paddingVertical: {
    paddingTop: true,
    paddingBottom: true
  },
  textDecorationLine: {
    textDecoration: true
  },
  writingDirection: {
    direction: true
  }
};
var sortProps = function sortProps(propsArray) {
  return propsArray.sort(function (a, b) {
    var expandedA = styleShortHands[a];
    var expandedB = styleShortHands[b];
    if (expandedA && expandedA[b]) {
      return -1;
    } else if (expandedB && expandedB[a]) {
      return 1;
    }
    return a < b ? -1 : a > b ? 1 : 0;
  });
};
var expandStyle = function expandStyle(style) {
  if (!style) return style;
  var propsArray = Object.keys(style);
  var sortedProps = sortProps(propsArray);
  var resolvedStyle = {};
  for (var i = 0; i < sortedProps.length; i++) {
    var key = sortedProps[i];
    var expandedProps = styleShortHands[key];
    var value = style[key];
    if (expandedProps) {
      for (var propName in expandedProps) {
        if (hasOwnProperty$3.call(expandedProps, propName)) {
          resolvedStyle[propName] = value;
        }
      }
    } else {
      resolvedStyle[key] = value;
    }
  }
  return resolvedStyle;
};
var expandStyle_1 = expandStyle;

var index$10 = createCommonjsModule(function (module) {
'use strict';
var _expandStyle = expandStyle_1;
var _expandStyle2 = _interopRequireDefault(_expandStyle);
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var hasOwnProperty = Object.prototype.hasOwnProperty;
var _id = 0;
var guid = function guid() {
  return _id++;
};
var declarationRegistry = {};
var extractRules = function extractRules(style) {
  var declarations = {};
  Object.keys(style).forEach(function (key) {
    if (key[0] === ':') {
    } else if (key[0] === '@') {
    } else {
      declarations[key] = style[key];
    }
  });
  return {
    declarations: declarations
  };
};
var registerStyle = function registerStyle(style) {
  var id = guid();
  var rules = extractRules(style);
  declarationRegistry[id] = (0, _expandStyle2.default)(rules.declarations);
  return id;
};
var getStyle = function getStyle(id) {
  return declarationRegistry[id];
};
var create = function create(styles) {
  var result = {};
  Object.keys(styles).forEach(function (key) {
    result[key] = registerStyle(styles[key]);
  });
  return result;
};
var mergeTransforms = function mergeTransforms(a, b) {
  if (!a || a.length === 0) return b;
  var result = [];
  var transformsInA = a.reduce(function (hash, t) {
    var key = Object.keys(t)[0];
    result.push(t);
    hash[key] = result.length - 1;
    return hash;
  }, {});
  b.forEach(function (t) {
    var key = Object.keys(t)[0];
    var index = transformsInA[key];
    if (index !== undefined) {
      result[index] = t;
    } else {
      result.push(t);
    }
  });
  return result;
};
var mergeStyle = function mergeStyle(a, b) {
  var key = void 0;
  for (key in b) {
    if (hasOwnProperty.call(b, key)) {
      switch (key) {
        case 'transform':
          a[key] = mergeTransforms(a[key], b[key]);
          break;
        default:
          a[key] = b[key];
          break;
      }
    }
  }
  return a;
};
var flattenStyle = function flattenStyle(input) {
  if (Array.isArray(input)) {
    return input.reduce(function (acc, val) {
      return mergeStyle(acc, flattenStyle(val));
    }, {});
  } else if (typeof input === 'number') {
    return getStyle(input);
  } else if (!input) {
    return undefined;
  }
  return (0, _expandStyle2.default)(input);
};
var StyleSheet = {
  hairlineWidth: 1,
  absoluteFill: registerStyle({
    position: 'absolute',
    top: 0,
    left: 0,
    bottom: 0,
    right: 0
  }),
  create: create,
  flatten: flattenStyle,
  resolve: function resolve(style) {
    return { style: flattenStyle(style) };
  }
};
module.exports = StyleSheet;
});

var TextStylePropTypes = {};

var ViewStylePropTypes = {};

var Text_1 = createCommonjsModule(function (module) {
'use strict';
var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();
var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};
var _react = react;
var _react2 = _interopRequireDefault(_react);
var _stylesheet = index$10;
var _stylesheet2 = _interopRequireDefault(_stylesheet);
var _TextStylePropTypes = TextStylePropTypes;
var _TextStylePropTypes2 = _interopRequireDefault(_TextStylePropTypes);
var _ViewStylePropTypes = ViewStylePropTypes;
var _ViewStylePropTypes2 = _interopRequireDefault(_ViewStylePropTypes);
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && (typeof call === "object" || typeof call === "function") ? call : self;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var propTypes = {
  style: _react.PropTypes.shape(_extends({}, _ViewStylePropTypes2.default, _TextStylePropTypes2.default)),
  name: _react.PropTypes.string,
  children: _react.PropTypes.node
};
var Text = function (_React$Component) {
  _inherits(Text, _React$Component);
  function Text() {
    _classCallCheck(this, Text);
    return _possibleConstructorReturn(this, (Text.__proto__ || Object.getPrototypeOf(Text)).apply(this, arguments));
  }
  _createClass(Text, [{
    key: 'render',
    value: function render() {
      return _react2.default.createElement('text', {
        name: this.props.name,
        style: _stylesheet2.default.flatten(this.props.style)
      }, this.props.children);
    }
  }]);
  return Text;
}(_react2.default.Component);
Text.propTypes = propTypes;
module.exports = Text;
});

var View_1 = createCommonjsModule(function (module) {
'use strict';
var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();
var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};
var _react = react;
var _react2 = _interopRequireDefault(_react);
var _stylesheet = index$10;
var _stylesheet2 = _interopRequireDefault(_stylesheet);
var _ViewStylePropTypes = ViewStylePropTypes;
var _ViewStylePropTypes2 = _interopRequireDefault(_ViewStylePropTypes);
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && (typeof call === "object" || typeof call === "function") ? call : self;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var propTypes = {
  style: _react.PropTypes.shape(_extends({}, _ViewStylePropTypes2.default)),
  name: _react.PropTypes.string,
  children: _react.PropTypes.node
};
var View = function (_React$Component) {
  _inherits(View, _React$Component);
  function View() {
    _classCallCheck(this, View);
    return _possibleConstructorReturn(this, (View.__proto__ || Object.getPrototypeOf(View)).apply(this, arguments));
  }
  _createClass(View, [{
    key: 'render',
    value: function render() {
      return _react2.default.createElement('view', {
        name: this.props.name,
        style: _stylesheet2.default.flatten(this.props.style)
      }, this.props.children);
    }
  }]);
  return View;
}(_react2.default.Component);
View.propTypes = propTypes;
module.exports = View;
});

var RedBox_1 = createCommonjsModule(function (module, exports) {
'use strict';
Object.defineProperty(exports, "__esModule", {
  value: true
});
var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();
var _react = react;
var _react2 = _interopRequireDefault(_react);
var _errorStackParser = errorStackParser;
var _errorStackParser2 = _interopRequireDefault(_errorStackParser);
var _stylesheet = index$10;
var _stylesheet2 = _interopRequireDefault(_stylesheet);
var _Text = Text_1;
var _Text2 = _interopRequireDefault(_Text);
var _View = View_1;
var _View2 = _interopRequireDefault(_View);
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && (typeof call === "object" || typeof call === "function") ? call : self;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var styles = _stylesheet2.default.create({
  redbox: {
    padding: 10,
    width: 480,
    backgroundColor: 'rgb(204, 0, 0)'
  },
  message: {
    fontWeight: 'bold',
    fontSize: 16,
    lineHeight: 16 * 1.2,
    color: 'white'
  },
  stack: {
    fontFamily: 'Monaco',
    marginTop: 20,
    color: 'white'
  }
});
var propTypes = {
  error: _react.PropTypes.instanceOf(Error).isRequired
};
var RedBox = function (_React$Component) {
  _inherits(RedBox, _React$Component);
  function RedBox() {
    _classCallCheck(this, RedBox);
    return _possibleConstructorReturn(this, (RedBox.__proto__ || Object.getPrototypeOf(RedBox)).apply(this, arguments));
  }
  _createClass(RedBox, [{
    key: 'renderFrames',
    value: function renderFrames(frames) {
      return frames.map(function (f, index) {
        return _react2.default.createElement(_Text2.default, { key: index, style: styles.stack }, f.functionName);
      });
    }
  }, {
    key: 'render',
    value: function render() {
      var error = this.props.error;
      var frames = void 0;
      var parseError = void 0;
      var frameChildren = void 0;
      try {
        frames = _errorStackParser2.default.parse(error);
      } catch (e) {
        parseError = new Error('Failed to parse stack trace. Stack trace information unavailable.');
      }
      if (parseError) {
        frameChildren = _react2.default.createElement(_View2.default, { style: styles.frame, key: 0 }, _react2.default.createElement(_View2.default, null, parseError.message));
      }
      if (frames) {
        frameChildren = this.renderFrames(frames);
      }
      return _react2.default.createElement(_View2.default, { name: 'RedBox', style: styles.redbox }, _react2.default.createElement(_Text2.default, { name: 'Message', style: styles.message }, error.name + ': ' + error.message), _react2.default.createElement(_View2.default, { name: 'Frames', style: styles.stack }, frameChildren));
    }
  }]);
  return RedBox;
}(_react2.default.Component);
RedBox.defaultProps = {
  useLines: true,
  useColumns: true
};
RedBox.propTypes = propTypes;
exports.default = RedBox;
});

var render_1 = createCommonjsModule(function (module) {
'use strict';
var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};
var _react = react;
var _react2 = _interopRequireDefault(_react);
var _reactTestRenderer = index$4;
var _reactTestRenderer2 = _interopRequireDefault(_reactTestRenderer);
var _cssLayout = cssLayout;
var _cssLayout2 = _interopRequireDefault(_cssLayout);
var _Context = Context_1;
var _Context2 = _interopRequireDefault(_Context);
var _createStringMeasurer = createStringMeasurer_1;
var _createStringMeasurer2 = _interopRequireDefault(_createStringMeasurer);
var _renderers = index$6;
var _renderers2 = _interopRequireDefault(_renderers);
var _RedBox = RedBox_1;
var _RedBox2 = _interopRequireDefault(_RedBox);
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var hasAnyDefined = function hasAnyDefined(obj, names) {
  return names.some(function (key) {
    return obj[key] !== undefined;
  });
};
var pick = function pick(obj, keys) {
  var result = {};
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (obj[key] !== undefined) {
      result[key] = obj[key];
    }
  }
  return result;
};
var INHERITABLE_STYLES = ['color', 'fontFamily', 'fontSize', 'fontStyle', 'fontWeight', 'textShadowOffset', 'textShadowRadius', 'textShadowColor', 'letterSpacing', 'lineHeight', 'textAlign', 'writingDirection'];
var reactTreeToFlexTree = function reactTreeToFlexTree(node, context) {
  if (typeof node === 'string') {
    var _textStyle = context.getInheritedStyles();
    return {
      type: 'text',
      style: {
        measure: (0, _createStringMeasurer2.default)(node, _textStyle)
      },
      textStyle: _textStyle,
      props: {},
      value: node,
      children: []
    };
  }
  var children = node.children || [];
  var style = node.props.style || {};
  var textStyle = void 0;
  if (node.type === 'text' && node.props.style && hasAnyDefined(style, INHERITABLE_STYLES)) {
    var inheritableStyles = pick(style, INHERITABLE_STYLES);
    context.addInheritableStyles(inheritableStyles);
    textStyle = _extends({}, context.getInheritedStyles(), inheritableStyles);
  } else {
    textStyle = context.getInheritedStyles();
  }
  return {
    type: node.type,
    style: style,
    textStyle: textStyle,
    props: node.props,
    value: null,
    children: children.map(function (child) {
      return reactTreeToFlexTree(child, context.forChildren());
    })
  };
};
var renderToSketch = function renderToSketch(node, layer) {
  var type = node.type,
      style = node.style,
      textStyle = node.textStyle,
      layout = node.layout,
      value = node.value,
      props = node.props,
      children = node.children;
  var Renderer = _renderers2.default[type];
  if (Renderer == null) {
    throw new Error('Could not find renderer for type \'' + type + '\'');
  }
  var renderer = new Renderer();
  var groupLayer = renderer.renderGroupLayer(layout, style, textStyle, props, value);
  var backingLayers = renderer.renderBackingLayers(layout, style, textStyle, props, value);
  layer.addLayers([groupLayer]);
  groupLayer.addLayers(backingLayers);
  children.map(function (child) {
    return renderToSketch(child, groupLayer);
  });
};
var buildTree = function buildTree(element) {
  var renderer = _reactTestRenderer2.default.create(element);
  var json = renderer.toJSON();
  var tree = reactTreeToFlexTree(json, new _Context2.default());
  (0, _cssLayout2.default)(tree);
  return tree;
};
function render(element, context) {
  var page = context.document.currentPage();
  try {
    var tree = buildTree(element);
    renderToSketch(tree, page);
  } catch (err) {
    var _tree = buildTree(_react2.default.createElement(_RedBox2.default, { error: err }));
    renderToSketch(_tree, page);
  }
}
module.exports = render;
});

var Platform_1 = createCommonjsModule(function (module, exports) {
'use strict';
Object.defineProperty(exports, "__esModule", {
  value: true
});
var Platform = {
  OS: 'sketch',
  Version: 1,
  select: function select(obj) {
    return obj.sketch;
  }
};
exports.default = Platform;
});

var Artboard_1 = createCommonjsModule(function (module) {
'use strict';
var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();
var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};
var _react = react;
var _react2 = _interopRequireDefault(_react);
var _stylesheet = index$10;
var _stylesheet2 = _interopRequireDefault(_stylesheet);
var _ViewStylePropTypes = ViewStylePropTypes;
var _ViewStylePropTypes2 = _interopRequireDefault(_ViewStylePropTypes);
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && (typeof call === "object" || typeof call === "function") ? call : self;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var propTypes = {
  style: _react.PropTypes.shape(_extends({}, _ViewStylePropTypes2.default)),
  name: _react.PropTypes.string.isRequired,
  children: _react.PropTypes.node
};
var Artboard = function (_React$Component) {
  _inherits(Artboard, _React$Component);
  function Artboard() {
    _classCallCheck(this, Artboard);
    return _possibleConstructorReturn(this, (Artboard.__proto__ || Object.getPrototypeOf(Artboard)).apply(this, arguments));
  }
  _createClass(Artboard, [{
    key: 'render',
    value: function render() {
      return _react2.default.createElement('artboard', {
        style: _stylesheet2.default.flatten(this.props.style),
        name: this.props.name
      }, this.props.children);
    }
  }]);
  return Artboard;
}(_react2.default.Component);
Artboard.propTypes = propTypes;
module.exports = Artboard;
});

var Image_1 = createCommonjsModule(function (module, exports) {
'use strict';
Object.defineProperty(exports, "__esModule", {
  value: true
});
var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();
var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};
var _react = react;
var _react2 = _interopRequireDefault(_react);
var _stylesheet = index$10;
var _stylesheet2 = _interopRequireDefault(_stylesheet);
var _ViewStylePropTypes = ViewStylePropTypes;
var _ViewStylePropTypes2 = _interopRequireDefault(_ViewStylePropTypes);
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && (typeof call === "object" || typeof call === "function") ? call : self;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var ImageSourcePropType = _react.PropTypes.oneOfType([_react.PropTypes.shape({
  uri: _react.PropTypes.string.isRequired
}), _react.PropTypes.string]);
var ResizeModePropType = _react.PropTypes.oneOf(['contain', 'cover', 'stretch', 'center', 'repeat', 'none']);
var propTypes = {
  children: _react.PropTypes.any,
  defaultSource: ImageSourcePropType,
  resizeMode: ResizeModePropType,
  source: ImageSourcePropType,
  style: _react.PropTypes.shape(_extends({}, _ViewStylePropTypes2.default, {
    resizeMode: ResizeModePropType
  }))
};
var ResizeModes = {
  contain: 'Fit',
  cover: 'Fill',
  stretch: 'Stretch'
};
var Image = function (_React$Component) {
  _inherits(Image, _React$Component);
  function Image() {
    _classCallCheck(this, Image);
    return _possibleConstructorReturn(this, (Image.__proto__ || Object.getPrototypeOf(Image)).apply(this, arguments));
  }
  _createClass(Image, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          children = _props.children,
          source = _props.source,
          defaultSource = _props.defaultSource,
          resizeMode = _props.resizeMode;
      var style = _stylesheet2.default.flatten(this.props.style);
      var sketchResizeMode = ResizeModes[resizeMode || style.resizeMode];
      return _react2.default.createElement('image', {
        style: style,
        source: source || defaultSource,
        resizeMode: sketchResizeMode
      }, children);
    }
  }]);
  return Image;
}(_react2.default.Component);
Image.propTypes = propTypes;
exports.default = Image;
});

var index$2 = createCommonjsModule(function (module) {
'use strict';
var _render = render_1;
var _render2 = _interopRequireDefault(_render);
var _Platform = Platform_1;
var _Platform2 = _interopRequireDefault(_Platform);
var _stylesheet = index$10;
var _stylesheet2 = _interopRequireDefault(_stylesheet);
var _Artboard = Artboard_1;
var _Artboard2 = _interopRequireDefault(_Artboard);
var _Image = Image_1;
var _Image2 = _interopRequireDefault(_Image);
var _RedBox = RedBox_1;
var _RedBox2 = _interopRequireDefault(_RedBox);
var _View = View_1;
var _View2 = _interopRequireDefault(_View);
var _Text = Text_1;
var _Text2 = _interopRequireDefault(_Text);
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
module.exports = {
  render: _render2.default,
  StyleSheet: _stylesheet2.default,
  Artboard: _Artboard2.default,
  Image: _Image2.default,
  RedBox: _RedBox2.default,
  Text: _Text2.default,
  View: _View2.default,
  Platform: _Platform2.default
};
});
var index_1 = index$2.render;
var index_6 = index$2.Text;
var index_7 = index$2.View;

var chroma = createCommonjsModule(function (module, exports) {
/**
 * @license
 *
 * chroma.js - JavaScript library for color conversions
 *
 * Copyright (c) 2011-2015, Gregor Aisch
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * 3. The name Gregor Aisch may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
(function () {
  var Color,
      DEG2RAD,
      LAB_CONSTANTS,
      PI,
      PITHIRD,
      RAD2DEG,
      TWOPI,
      _guess_formats,
      _guess_formats_sorted,
      _input,
      _interpolators,
      abs,
      atan2,
      bezier,
      blend,
      blend_f,
      brewer,
      burn,
      chroma,
      clip_rgb,
      cmyk2rgb,
      colors,
      cos,
      css2rgb,
      darken,
      dodge,
      each,
      floor,
      hex2rgb,
      hsi2rgb,
      hsl2css,
      hsl2rgb,
      hsv2rgb,
      interpolate,
      interpolate_hsx,
      interpolate_lab,
      interpolate_num,
      interpolate_rgb,
      lab2lch,
      lab2rgb,
      lab_xyz,
      lch2lab,
      lch2rgb,
      lighten,
      limit,
      log,
      luminance_x,
      m,
      max,
      multiply,
      normal,
      num2rgb,
      overlay,
      pow,
      rgb2cmyk,
      rgb2css,
      rgb2hex,
      rgb2hsi,
      rgb2hsl,
      rgb2hsv,
      rgb2lab,
      rgb2lch,
      rgb2luminance,
      rgb2num,
      rgb2temperature,
      rgb2xyz,
      rgb_xyz,
      rnd,
      root,
      round,
      screen,
      sin,
      sqrt,
      temperature2rgb,
      type,
      unpack,
      w3cx11,
      xyz_lab,
      xyz_rgb,
      slice = [].slice;
  type = function () {
    var classToType, len, name, o, ref;
    classToType = {};
    ref = "Boolean Number String Function Array Date RegExp Undefined Null".split(" ");
    for (o = 0, len = ref.length; o < len; o++) {
      name = ref[o];
      classToType["[object " + name + "]"] = name.toLowerCase();
    }
    return function (obj) {
      var strType;
      strType = Object.prototype.toString.call(obj);
      return classToType[strType] || "object";
    };
  }();
  limit = function (x, min, max) {
    if (min == null) {
      min = 0;
    }
    if (max == null) {
      max = 1;
    }
    if (x < min) {
      x = min;
    }
    if (x > max) {
      x = max;
    }
    return x;
  };
  unpack = function (args) {
    if (args.length >= 3) {
      return [].slice.call(args);
    } else {
      return args[0];
    }
  };
  clip_rgb = function (rgb) {
    var i;
    for (i in rgb) {
      if (i < 3) {
        if (rgb[i] < 0) {
          rgb[i] = 0;
        }
        if (rgb[i] > 255) {
          rgb[i] = 255;
        }
      } else if (i === 3) {
        if (rgb[i] < 0) {
          rgb[i] = 0;
        }
        if (rgb[i] > 1) {
          rgb[i] = 1;
        }
      }
    }
    return rgb;
  };
  PI = Math.PI, round = Math.round, cos = Math.cos, floor = Math.floor, pow = Math.pow, log = Math.log, sin = Math.sin, sqrt = Math.sqrt, atan2 = Math.atan2, max = Math.max, abs = Math.abs;
  TWOPI = PI * 2;
  PITHIRD = PI / 3;
  DEG2RAD = PI / 180;
  RAD2DEG = 180 / PI;
  chroma = function () {
    if (arguments[0] instanceof Color) {
      return arguments[0];
    }
    return function (func, args, ctor) {
      ctor.prototype = func.prototype;
      var child = new ctor(),
          result = func.apply(child, args);
      return Object(result) === result ? result : child;
    }(Color, arguments, function () {});
  };
  _interpolators = [];
  if ('object' !== "undefined" && module !== null && module.exports != null) {
    module.exports = chroma;
  }
  if (typeof undefined === 'function' && undefined.amd) {
    undefined([], function () {
      return chroma;
    });
  } else {
    root = 'object' !== "undefined" && exports !== null ? exports : this;
    root.chroma = chroma;
  }
  chroma.version = '1.2.1';
  _input = {};
  _guess_formats = [];
  _guess_formats_sorted = false;
  Color = function () {
    function Color() {
      var arg, args, chk, len, len1, me, mode, o, w;
      me = this;
      args = [];
      for (o = 0, len = arguments.length; o < len; o++) {
        arg = arguments[o];
        if (arg != null) {
          args.push(arg);
        }
      }
      mode = args[args.length - 1];
      if (_input[mode] != null) {
        me._rgb = clip_rgb(_input[mode](unpack(args.slice(0, -1))));
      } else {
        if (!_guess_formats_sorted) {
          _guess_formats = _guess_formats.sort(function (a, b) {
            return b.p - a.p;
          });
          _guess_formats_sorted = true;
        }
        for (w = 0, len1 = _guess_formats.length; w < len1; w++) {
          chk = _guess_formats[w];
          mode = chk.test.apply(chk, args);
          if (mode) {
            break;
          }
        }
        if (mode) {
          me._rgb = clip_rgb(_input[mode].apply(_input, args));
        }
      }
      if (me._rgb == null) {
        console.warn('unknown format: ' + args);
      }
      if (me._rgb == null) {
        me._rgb = [0, 0, 0];
      }
      if (me._rgb.length === 3) {
        me._rgb.push(1);
      }
    }
    Color.prototype.alpha = function (alpha) {
      if (arguments.length) {
        this._rgb[3] = alpha;
        return this;
      }
      return this._rgb[3];
    };
    Color.prototype.toString = function () {
      return this.name();
    };
    return Color;
  }();
  chroma._input = _input;
  /**
  	ColorBrewer colors for chroma.js
  	Copyright (c) 2002 Cynthia Brewer, Mark Harrower, and The
  	Pennsylvania State University.
  	Licensed under the Apache License, Version 2.0 (the "License");
  	you may not use this file except in compliance with the License.
  	You may obtain a copy of the License at
  	http://www.apache.org/licenses/LICENSE-2.0
  	Unless required by applicable law or agreed to in writing, software distributed
  	under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
  	CONDITIONS OF ANY KIND, either express or implied. See the License for the
  	specific language governing permissions and limitations under the License.
      @preserve
   */
  chroma.brewer = brewer = {
    OrRd: ['#fff7ec', '#fee8c8', '#fdd49e', '#fdbb84', '#fc8d59', '#ef6548', '#d7301f', '#b30000', '#7f0000'],
    PuBu: ['#fff7fb', '#ece7f2', '#d0d1e6', '#a6bddb', '#74a9cf', '#3690c0', '#0570b0', '#045a8d', '#023858'],
    BuPu: ['#f7fcfd', '#e0ecf4', '#bfd3e6', '#9ebcda', '#8c96c6', '#8c6bb1', '#88419d', '#810f7c', '#4d004b'],
    Oranges: ['#fff5eb', '#fee6ce', '#fdd0a2', '#fdae6b', '#fd8d3c', '#f16913', '#d94801', '#a63603', '#7f2704'],
    BuGn: ['#f7fcfd', '#e5f5f9', '#ccece6', '#99d8c9', '#66c2a4', '#41ae76', '#238b45', '#006d2c', '#00441b'],
    YlOrBr: ['#ffffe5', '#fff7bc', '#fee391', '#fec44f', '#fe9929', '#ec7014', '#cc4c02', '#993404', '#662506'],
    YlGn: ['#ffffe5', '#f7fcb9', '#d9f0a3', '#addd8e', '#78c679', '#41ab5d', '#238443', '#006837', '#004529'],
    Reds: ['#fff5f0', '#fee0d2', '#fcbba1', '#fc9272', '#fb6a4a', '#ef3b2c', '#cb181d', '#a50f15', '#67000d'],
    RdPu: ['#fff7f3', '#fde0dd', '#fcc5c0', '#fa9fb5', '#f768a1', '#dd3497', '#ae017e', '#7a0177', '#49006a'],
    Greens: ['#f7fcf5', '#e5f5e0', '#c7e9c0', '#a1d99b', '#74c476', '#41ab5d', '#238b45', '#006d2c', '#00441b'],
    YlGnBu: ['#ffffd9', '#edf8b1', '#c7e9b4', '#7fcdbb', '#41b6c4', '#1d91c0', '#225ea8', '#253494', '#081d58'],
    Purples: ['#fcfbfd', '#efedf5', '#dadaeb', '#bcbddc', '#9e9ac8', '#807dba', '#6a51a3', '#54278f', '#3f007d'],
    GnBu: ['#f7fcf0', '#e0f3db', '#ccebc5', '#a8ddb5', '#7bccc4', '#4eb3d3', '#2b8cbe', '#0868ac', '#084081'],
    Greys: ['#ffffff', '#f0f0f0', '#d9d9d9', '#bdbdbd', '#969696', '#737373', '#525252', '#252525', '#000000'],
    YlOrRd: ['#ffffcc', '#ffeda0', '#fed976', '#feb24c', '#fd8d3c', '#fc4e2a', '#e31a1c', '#bd0026', '#800026'],
    PuRd: ['#f7f4f9', '#e7e1ef', '#d4b9da', '#c994c7', '#df65b0', '#e7298a', '#ce1256', '#980043', '#67001f'],
    Blues: ['#f7fbff', '#deebf7', '#c6dbef', '#9ecae1', '#6baed6', '#4292c6', '#2171b5', '#08519c', '#08306b'],
    PuBuGn: ['#fff7fb', '#ece2f0', '#d0d1e6', '#a6bddb', '#67a9cf', '#3690c0', '#02818a', '#016c59', '#014636'],
    Spectral: ['#9e0142', '#d53e4f', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#e6f598', '#abdda4', '#66c2a5', '#3288bd', '#5e4fa2'],
    RdYlGn: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#d9ef8b', '#a6d96a', '#66bd63', '#1a9850', '#006837'],
    RdBu: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#f7f7f7', '#d1e5f0', '#92c5de', '#4393c3', '#2166ac', '#053061'],
    PiYG: ['#8e0152', '#c51b7d', '#de77ae', '#f1b6da', '#fde0ef', '#f7f7f7', '#e6f5d0', '#b8e186', '#7fbc41', '#4d9221', '#276419'],
    PRGn: ['#40004b', '#762a83', '#9970ab', '#c2a5cf', '#e7d4e8', '#f7f7f7', '#d9f0d3', '#a6dba0', '#5aae61', '#1b7837', '#00441b'],
    RdYlBu: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee090', '#ffffbf', '#e0f3f8', '#abd9e9', '#74add1', '#4575b4', '#313695'],
    BrBG: ['#543005', '#8c510a', '#bf812d', '#dfc27d', '#f6e8c3', '#f5f5f5', '#c7eae5', '#80cdc1', '#35978f', '#01665e', '#003c30'],
    RdGy: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#ffffff', '#e0e0e0', '#bababa', '#878787', '#4d4d4d', '#1a1a1a'],
    PuOr: ['#7f3b08', '#b35806', '#e08214', '#fdb863', '#fee0b6', '#f7f7f7', '#d8daeb', '#b2abd2', '#8073ac', '#542788', '#2d004b'],
    Set2: ['#66c2a5', '#fc8d62', '#8da0cb', '#e78ac3', '#a6d854', '#ffd92f', '#e5c494', '#b3b3b3'],
    Accent: ['#7fc97f', '#beaed4', '#fdc086', '#ffff99', '#386cb0', '#f0027f', '#bf5b17', '#666666'],
    Set1: ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf', '#999999'],
    Set3: ['#8dd3c7', '#ffffb3', '#bebada', '#fb8072', '#80b1d3', '#fdb462', '#b3de69', '#fccde5', '#d9d9d9', '#bc80bd', '#ccebc5', '#ffed6f'],
    Dark2: ['#1b9e77', '#d95f02', '#7570b3', '#e7298a', '#66a61e', '#e6ab02', '#a6761d', '#666666'],
    Paired: ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c', '#fdbf6f', '#ff7f00', '#cab2d6', '#6a3d9a', '#ffff99', '#b15928'],
    Pastel2: ['#b3e2cd', '#fdcdac', '#cbd5e8', '#f4cae4', '#e6f5c9', '#fff2ae', '#f1e2cc', '#cccccc'],
    Pastel1: ['#fbb4ae', '#b3cde3', '#ccebc5', '#decbe4', '#fed9a6', '#ffffcc', '#e5d8bd', '#fddaec', '#f2f2f2']
  };
  w3cx11 = {
    indigo: "#4b0082",
    gold: "#ffd700",
    hotpink: "#ff69b4",
    firebrick: "#b22222",
    indianred: "#cd5c5c",
    yellow: "#ffff00",
    mistyrose: "#ffe4e1",
    darkolivegreen: "#556b2f",
    olive: "#808000",
    darkseagreen: "#8fbc8f",
    pink: "#ffc0cb",
    tomato: "#ff6347",
    lightcoral: "#f08080",
    orangered: "#ff4500",
    navajowhite: "#ffdead",
    lime: "#00ff00",
    palegreen: "#98fb98",
    darkslategrey: "#2f4f4f",
    greenyellow: "#adff2f",
    burlywood: "#deb887",
    seashell: "#fff5ee",
    mediumspringgreen: "#00fa9a",
    fuchsia: "#ff00ff",
    papayawhip: "#ffefd5",
    blanchedalmond: "#ffebcd",
    chartreuse: "#7fff00",
    dimgray: "#696969",
    black: "#000000",
    peachpuff: "#ffdab9",
    springgreen: "#00ff7f",
    aquamarine: "#7fffd4",
    white: "#ffffff",
    orange: "#ffa500",
    lightsalmon: "#ffa07a",
    darkslategray: "#2f4f4f",
    brown: "#a52a2a",
    ivory: "#fffff0",
    dodgerblue: "#1e90ff",
    peru: "#cd853f",
    lawngreen: "#7cfc00",
    chocolate: "#d2691e",
    crimson: "#dc143c",
    forestgreen: "#228b22",
    darkgrey: "#a9a9a9",
    lightseagreen: "#20b2aa",
    cyan: "#00ffff",
    mintcream: "#f5fffa",
    silver: "#c0c0c0",
    antiquewhite: "#faebd7",
    mediumorchid: "#ba55d3",
    skyblue: "#87ceeb",
    gray: "#808080",
    darkturquoise: "#00ced1",
    goldenrod: "#daa520",
    darkgreen: "#006400",
    floralwhite: "#fffaf0",
    darkviolet: "#9400d3",
    darkgray: "#a9a9a9",
    moccasin: "#ffe4b5",
    saddlebrown: "#8b4513",
    grey: "#808080",
    darkslateblue: "#483d8b",
    lightskyblue: "#87cefa",
    lightpink: "#ffb6c1",
    mediumvioletred: "#c71585",
    slategrey: "#708090",
    red: "#ff0000",
    deeppink: "#ff1493",
    limegreen: "#32cd32",
    darkmagenta: "#8b008b",
    palegoldenrod: "#eee8aa",
    plum: "#dda0dd",
    turquoise: "#40e0d0",
    lightgrey: "#d3d3d3",
    lightgoldenrodyellow: "#fafad2",
    darkgoldenrod: "#b8860b",
    lavender: "#e6e6fa",
    maroon: "#800000",
    yellowgreen: "#9acd32",
    sandybrown: "#f4a460",
    thistle: "#d8bfd8",
    violet: "#ee82ee",
    navy: "#000080",
    magenta: "#ff00ff",
    dimgrey: "#696969",
    tan: "#d2b48c",
    rosybrown: "#bc8f8f",
    olivedrab: "#6b8e23",
    blue: "#0000ff",
    lightblue: "#add8e6",
    ghostwhite: "#f8f8ff",
    honeydew: "#f0fff0",
    cornflowerblue: "#6495ed",
    slateblue: "#6a5acd",
    linen: "#faf0e6",
    darkblue: "#00008b",
    powderblue: "#b0e0e6",
    seagreen: "#2e8b57",
    darkkhaki: "#bdb76b",
    snow: "#fffafa",
    sienna: "#a0522d",
    mediumblue: "#0000cd",
    royalblue: "#4169e1",
    lightcyan: "#e0ffff",
    green: "#008000",
    mediumpurple: "#9370db",
    midnightblue: "#191970",
    cornsilk: "#fff8dc",
    paleturquoise: "#afeeee",
    bisque: "#ffe4c4",
    slategray: "#708090",
    darkcyan: "#008b8b",
    khaki: "#f0e68c",
    wheat: "#f5deb3",
    teal: "#008080",
    darkorchid: "#9932cc",
    deepskyblue: "#00bfff",
    salmon: "#fa8072",
    darkred: "#8b0000",
    steelblue: "#4682b4",
    palevioletred: "#db7093",
    lightslategray: "#778899",
    aliceblue: "#f0f8ff",
    lightslategrey: "#778899",
    lightgreen: "#90ee90",
    orchid: "#da70d6",
    gainsboro: "#dcdcdc",
    mediumseagreen: "#3cb371",
    lightgray: "#d3d3d3",
    mediumturquoise: "#48d1cc",
    lemonchiffon: "#fffacd",
    cadetblue: "#5f9ea0",
    lightyellow: "#ffffe0",
    lavenderblush: "#fff0f5",
    coral: "#ff7f50",
    purple: "#800080",
    aqua: "#00ffff",
    whitesmoke: "#f5f5f5",
    mediumslateblue: "#7b68ee",
    darkorange: "#ff8c00",
    mediumaquamarine: "#66cdaa",
    darksalmon: "#e9967a",
    beige: "#f5f5dc",
    blueviolet: "#8a2be2",
    azure: "#f0ffff",
    lightsteelblue: "#b0c4de",
    oldlace: "#fdf5e6",
    rebeccapurple: "#663399"
  };
  chroma.colors = colors = w3cx11;
  lab2rgb = function () {
    var a, args, b, g, l, r, x, y, z;
    args = unpack(arguments);
    l = args[0], a = args[1], b = args[2];
    y = (l + 16) / 116;
    x = isNaN(a) ? y : y + a / 500;
    z = isNaN(b) ? y : y - b / 200;
    y = LAB_CONSTANTS.Yn * lab_xyz(y);
    x = LAB_CONSTANTS.Xn * lab_xyz(x);
    z = LAB_CONSTANTS.Zn * lab_xyz(z);
    r = xyz_rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z);
    g = xyz_rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z);
    b = xyz_rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z);
    r = limit(r, 0, 255);
    g = limit(g, 0, 255);
    b = limit(b, 0, 255);
    return [r, g, b, args.length > 3 ? args[3] : 1];
  };
  xyz_rgb = function (r) {
    return round(255 * (r <= 0.00304 ? 12.92 * r : 1.055 * pow(r, 1 / 2.4) - 0.055));
  };
  lab_xyz = function (t) {
    if (t > LAB_CONSTANTS.t1) {
      return t * t * t;
    } else {
      return LAB_CONSTANTS.t2 * (t - LAB_CONSTANTS.t0);
    }
  };
  LAB_CONSTANTS = {
    Kn: 18,
    Xn: 0.950470,
    Yn: 1,
    Zn: 1.088830,
    t0: 0.137931034,
    t1: 0.206896552,
    t2: 0.12841855,
    t3: 0.008856452
  };
  rgb2lab = function () {
    var b, g, r, ref, ref1, x, y, z;
    ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
    ref1 = rgb2xyz(r, g, b), x = ref1[0], y = ref1[1], z = ref1[2];
    return [116 * y - 16, 500 * (x - y), 200 * (y - z)];
  };
  rgb_xyz = function (r) {
    if ((r /= 255) <= 0.04045) {
      return r / 12.92;
    } else {
      return pow((r + 0.055) / 1.055, 2.4);
    }
  };
  xyz_lab = function (t) {
    if (t > LAB_CONSTANTS.t3) {
      return pow(t, 1 / 3);
    } else {
      return t / LAB_CONSTANTS.t2 + LAB_CONSTANTS.t0;
    }
  };
  rgb2xyz = function () {
    var b, g, r, ref, x, y, z;
    ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
    r = rgb_xyz(r);
    g = rgb_xyz(g);
    b = rgb_xyz(b);
    x = xyz_lab((0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / LAB_CONSTANTS.Xn);
    y = xyz_lab((0.2126729 * r + 0.7151522 * g + 0.0721750 * b) / LAB_CONSTANTS.Yn);
    z = xyz_lab((0.0193339 * r + 0.1191920 * g + 0.9503041 * b) / LAB_CONSTANTS.Zn);
    return [x, y, z];
  };
  chroma.lab = function () {
    return function (func, args, ctor) {
      ctor.prototype = func.prototype;
      var child = new ctor(),
          result = func.apply(child, args);
      return Object(result) === result ? result : child;
    }(Color, slice.call(arguments).concat(['lab']), function () {});
  };
  _input.lab = lab2rgb;
  Color.prototype.lab = function () {
    return rgb2lab(this._rgb);
  };
  bezier = function (colors) {
    var I, I0, I1, c, lab0, lab1, lab2, lab3, ref, ref1, ref2;
    colors = function () {
      var len, o, results;
      results = [];
      for (o = 0, len = colors.length; o < len; o++) {
        c = colors[o];
        results.push(chroma(c));
      }
      return results;
    }();
    if (colors.length === 2) {
      ref = function () {
        var len, o, results;
        results = [];
        for (o = 0, len = colors.length; o < len; o++) {
          c = colors[o];
          results.push(c.lab());
        }
        return results;
      }(), lab0 = ref[0], lab1 = ref[1];
      I = function (t) {
        var i, lab;
        lab = function () {
          var o, results;
          results = [];
          for (i = o = 0; o <= 2; i = ++o) {
            results.push(lab0[i] + t * (lab1[i] - lab0[i]));
          }
          return results;
        }();
        return chroma.lab.apply(chroma, lab);
      };
    } else if (colors.length === 3) {
      ref1 = function () {
        var len, o, results;
        results = [];
        for (o = 0, len = colors.length; o < len; o++) {
          c = colors[o];
          results.push(c.lab());
        }
        return results;
      }(), lab0 = ref1[0], lab1 = ref1[1], lab2 = ref1[2];
      I = function (t) {
        var i, lab;
        lab = function () {
          var o, results;
          results = [];
          for (i = o = 0; o <= 2; i = ++o) {
            results.push((1 - t) * (1 - t) * lab0[i] + 2 * (1 - t) * t * lab1[i] + t * t * lab2[i]);
          }
          return results;
        }();
        return chroma.lab.apply(chroma, lab);
      };
    } else if (colors.length === 4) {
      ref2 = function () {
        var len, o, results;
        results = [];
        for (o = 0, len = colors.length; o < len; o++) {
          c = colors[o];
          results.push(c.lab());
        }
        return results;
      }(), lab0 = ref2[0], lab1 = ref2[1], lab2 = ref2[2], lab3 = ref2[3];
      I = function (t) {
        var i, lab;
        lab = function () {
          var o, results;
          results = [];
          for (i = o = 0; o <= 2; i = ++o) {
            results.push((1 - t) * (1 - t) * (1 - t) * lab0[i] + 3 * (1 - t) * (1 - t) * t * lab1[i] + 3 * (1 - t) * t * t * lab2[i] + t * t * t * lab3[i]);
          }
          return results;
        }();
        return chroma.lab.apply(chroma, lab);
      };
    } else if (colors.length === 5) {
      I0 = bezier(colors.slice(0, 3));
      I1 = bezier(colors.slice(2, 5));
      I = function (t) {
        if (t < 0.5) {
          return I0(t * 2);
        } else {
          return I1((t - 0.5) * 2);
        }
      };
    }
    return I;
  };
  chroma.bezier = function (colors) {
    var f;
    f = bezier(colors);
    f.scale = function () {
      return chroma.scale(f);
    };
    return f;
  };
  chroma.cubehelix = function (start, rotations, hue, gamma, lightness) {
    var dh, dl, f;
    if (start == null) {
      start = 300;
    }
    if (rotations == null) {
      rotations = -1.5;
    }
    if (hue == null) {
      hue = 1;
    }
    if (gamma == null) {
      gamma = 1;
    }
    if (lightness == null) {
      lightness = [0, 1];
    }
    dl = lightness[1] - lightness[0];
    dh = 0;
    f = function (fract) {
      var a, amp, b, cos_a, g, h, l, r, sin_a;
      a = TWOPI * ((start + 120) / 360 + rotations * fract);
      l = pow(lightness[0] + dl * fract, gamma);
      h = dh !== 0 ? hue[0] + fract * dh : hue;
      amp = h * l * (1 - l) / 2;
      cos_a = cos(a);
      sin_a = sin(a);
      r = l + amp * (-0.14861 * cos_a + 1.78277 * sin_a);
      g = l + amp * (-0.29227 * cos_a - 0.90649 * sin_a);
      b = l + amp * (+1.97294 * cos_a);
      return chroma(clip_rgb([r * 255, g * 255, b * 255]));
    };
    f.start = function (s) {
      if (s == null) {
        return start;
      }
      start = s;
      return f;
    };
    f.rotations = function (r) {
      if (r == null) {
        return rotations;
      }
      rotations = r;
      return f;
    };
    f.gamma = function (g) {
      if (g == null) {
        return gamma;
      }
      gamma = g;
      return f;
    };
    f.hue = function (h) {
      if (h == null) {
        return hue;
      }
      hue = h;
      if (type(hue) === 'array') {
        dh = hue[1] - hue[0];
        if (dh === 0) {
          hue = hue[1];
        }
      } else {
        dh = 0;
      }
      return f;
    };
    f.lightness = function (h) {
      if (h == null) {
        return lightness;
      }
      lightness = h;
      if (type(lightness) === 'array') {
        dl = lightness[1] - lightness[0];
        if (dl === 0) {
          lightness = lightness[1];
        }
      } else {
        dl = 0;
      }
      return f;
    };
    f.scale = function () {
      return chroma.scale(f);
    };
    f.hue(hue);
    return f;
  };
  chroma.random = function () {
    var code, digits, i, o;
    digits = '0123456789abcdef';
    code = '#';
    for (i = o = 0; o < 6; i = ++o) {
      code += digits.charAt(floor(Math.random() * 16));
    }
    return new Color(code);
  };
  chroma.average = function (colors) {
    var a, b, c, g, l, len, o, r, rgba;
    r = g = b = a = 0;
    l = colors.length;
    for (o = 0, len = colors.length; o < len; o++) {
      c = colors[o];
      rgba = chroma(c).rgba();
      r += rgba[0];
      g += rgba[1];
      b += rgba[2];
      a += rgba[3];
    }
    return new Color(r / l, g / l, b / l, a / l);
  };
  _input.rgb = function () {
    var k, ref, results, v;
    ref = unpack(arguments);
    results = [];
    for (k in ref) {
      v = ref[k];
      results.push(v);
    }
    return results;
  };
  chroma.rgb = function () {
    return function (func, args, ctor) {
      ctor.prototype = func.prototype;
      var child = new ctor(),
          result = func.apply(child, args);
      return Object(result) === result ? result : child;
    }(Color, slice.call(arguments).concat(['rgb']), function () {});
  };
  Color.prototype.rgb = function () {
    return this._rgb.slice(0, 3);
  };
  Color.prototype.rgba = function () {
    return this._rgb;
  };
  _guess_formats.push({
    p: 15,
    test: function (n) {
      var a;
      a = unpack(arguments);
      if (type(a) === 'array' && a.length === 3) {
        return 'rgb';
      }
      if (a.length === 4 && type(a[3]) === "number" && a[3] >= 0 && a[3] <= 1) {
        return 'rgb';
      }
    }
  });
  hex2rgb = function (hex) {
    var a, b, g, r, rgb, u;
    if (hex.match(/^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/)) {
      if (hex.length === 4 || hex.length === 7) {
        hex = hex.substr(1);
      }
      if (hex.length === 3) {
        hex = hex.split("");
        hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
      }
      u = parseInt(hex, 16);
      r = u >> 16;
      g = u >> 8 & 0xFF;
      b = u & 0xFF;
      return [r, g, b, 1];
    }
    if (hex.match(/^#?([A-Fa-f0-9]{8})$/)) {
      if (hex.length === 9) {
        hex = hex.substr(1);
      }
      u = parseInt(hex, 16);
      r = u >> 24 & 0xFF;
      g = u >> 16 & 0xFF;
      b = u >> 8 & 0xFF;
      a = round((u & 0xFF) / 0xFF * 100) / 100;
      return [r, g, b, a];
    }
    if (_input.css != null && (rgb = _input.css(hex))) {
      return rgb;
    }
    throw "unknown color: " + hex;
  };
  rgb2hex = function (channels, mode) {
    var a, b, g, hxa, r, str, u;
    if (mode == null) {
      mode = 'rgb';
    }
    r = channels[0], g = channels[1], b = channels[2], a = channels[3];
    u = r << 16 | g << 8 | b;
    str = "000000" + u.toString(16);
    str = str.substr(str.length - 6);
    hxa = '0' + round(a * 255).toString(16);
    hxa = hxa.substr(hxa.length - 2);
    return "#" + function () {
      switch (mode.toLowerCase()) {
        case 'rgba':
          return str + hxa;
        case 'argb':
          return hxa + str;
        default:
          return str;
      }
    }();
  };
  _input.hex = function (h) {
    return hex2rgb(h);
  };
  chroma.hex = function () {
    return function (func, args, ctor) {
      ctor.prototype = func.prototype;
      var child = new ctor(),
          result = func.apply(child, args);
      return Object(result) === result ? result : child;
    }(Color, slice.call(arguments).concat(['hex']), function () {});
  };
  Color.prototype.hex = function (mode) {
    if (mode == null) {
      mode = 'rgb';
    }
    return rgb2hex(this._rgb, mode);
  };
  _guess_formats.push({
    p: 10,
    test: function (n) {
      if (arguments.length === 1 && type(n) === "string") {
        return 'hex';
      }
    }
  });
  hsl2rgb = function () {
    var args, b, c, g, h, i, l, o, r, ref, s, t1, t2, t3;
    args = unpack(arguments);
    h = args[0], s = args[1], l = args[2];
    if (s === 0) {
      r = g = b = l * 255;
    } else {
      t3 = [0, 0, 0];
      c = [0, 0, 0];
      t2 = l < 0.5 ? l * (1 + s) : l + s - l * s;
      t1 = 2 * l - t2;
      h /= 360;
      t3[0] = h + 1 / 3;
      t3[1] = h;
      t3[2] = h - 1 / 3;
      for (i = o = 0; o <= 2; i = ++o) {
        if (t3[i] < 0) {
          t3[i] += 1;
        }
        if (t3[i] > 1) {
          t3[i] -= 1;
        }
        if (6 * t3[i] < 1) {
          c[i] = t1 + (t2 - t1) * 6 * t3[i];
        } else if (2 * t3[i] < 1) {
          c[i] = t2;
        } else if (3 * t3[i] < 2) {
          c[i] = t1 + (t2 - t1) * (2 / 3 - t3[i]) * 6;
        } else {
          c[i] = t1;
        }
      }
      ref = [round(c[0] * 255), round(c[1] * 255), round(c[2] * 255)], r = ref[0], g = ref[1], b = ref[2];
    }
    if (args.length > 3) {
      return [r, g, b, args[3]];
    } else {
      return [r, g, b];
    }
  };
  rgb2hsl = function (r, g, b) {
    var h, l, min, ref, s;
    if (r !== void 0 && r.length >= 3) {
      ref = r, r = ref[0], g = ref[1], b = ref[2];
    }
    r /= 255;
    g /= 255;
    b /= 255;
    min = Math.min(r, g, b);
    max = Math.max(r, g, b);
    l = (max + min) / 2;
    if (max === min) {
      s = 0;
      h = Number.NaN;
    } else {
      s = l < 0.5 ? (max - min) / (max + min) : (max - min) / (2 - max - min);
    }
    if (r === max) {
      h = (g - b) / (max - min);
    } else if (g === max) {
      h = 2 + (b - r) / (max - min);
    } else if (b === max) {
      h = 4 + (r - g) / (max - min);
    }
    h *= 60;
    if (h < 0) {
      h += 360;
    }
    return [h, s, l];
  };
  chroma.hsl = function () {
    return function (func, args, ctor) {
      ctor.prototype = func.prototype;
      var child = new ctor(),
          result = func.apply(child, args);
      return Object(result) === result ? result : child;
    }(Color, slice.call(arguments).concat(['hsl']), function () {});
  };
  _input.hsl = hsl2rgb;
  Color.prototype.hsl = function () {
    return rgb2hsl(this._rgb);
  };
  hsv2rgb = function () {
    var args, b, f, g, h, i, p, q, r, ref, ref1, ref2, ref3, ref4, ref5, s, t, v;
    args = unpack(arguments);
    h = args[0], s = args[1], v = args[2];
    v *= 255;
    if (s === 0) {
      r = g = b = v;
    } else {
      if (h === 360) {
        h = 0;
      }
      if (h > 360) {
        h -= 360;
      }
      if (h < 0) {
        h += 360;
      }
      h /= 60;
      i = floor(h);
      f = h - i;
      p = v * (1 - s);
      q = v * (1 - s * f);
      t = v * (1 - s * (1 - f));
      switch (i) {
        case 0:
          ref = [v, t, p], r = ref[0], g = ref[1], b = ref[2];
          break;
        case 1:
          ref1 = [q, v, p], r = ref1[0], g = ref1[1], b = ref1[2];
          break;
        case 2:
          ref2 = [p, v, t], r = ref2[0], g = ref2[1], b = ref2[2];
          break;
        case 3:
          ref3 = [p, q, v], r = ref3[0], g = ref3[1], b = ref3[2];
          break;
        case 4:
          ref4 = [t, p, v], r = ref4[0], g = ref4[1], b = ref4[2];
          break;
        case 5:
          ref5 = [v, p, q], r = ref5[0], g = ref5[1], b = ref5[2];
      }
    }
    r = round(r);
    g = round(g);
    b = round(b);
    return [r, g, b, args.length > 3 ? args[3] : 1];
  };
  rgb2hsv = function () {
    var b, delta, g, h, min, r, ref, s, v;
    ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
    min = Math.min(r, g, b);
    max = Math.max(r, g, b);
    delta = max - min;
    v = max / 255.0;
    if (max === 0) {
      h = Number.NaN;
      s = 0;
    } else {
      s = delta / max;
      if (r === max) {
        h = (g - b) / delta;
      }
      if (g === max) {
        h = 2 + (b - r) / delta;
      }
      if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h *= 60;
      if (h < 0) {
        h += 360;
      }
    }
    return [h, s, v];
  };
  chroma.hsv = function () {
    return function (func, args, ctor) {
      ctor.prototype = func.prototype;
      var child = new ctor(),
          result = func.apply(child, args);
      return Object(result) === result ? result : child;
    }(Color, slice.call(arguments).concat(['hsv']), function () {});
  };
  _input.hsv = hsv2rgb;
  Color.prototype.hsv = function () {
    return rgb2hsv(this._rgb);
  };
  num2rgb = function (num) {
    var b, g, r;
    if (type(num) === "number" && num >= 0 && num <= 0xFFFFFF) {
      r = num >> 16;
      g = num >> 8 & 0xFF;
      b = num & 0xFF;
      return [r, g, b, 1];
    }
    console.warn("unknown num color: " + num);
    return [0, 0, 0, 1];
  };
  rgb2num = function () {
    var b, g, r, ref;
    ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
    return (r << 16) + (g << 8) + b;
  };
  chroma.num = function (num) {
    return new Color(num, 'num');
  };
  Color.prototype.num = function (mode) {
    if (mode == null) {
      mode = 'rgb';
    }
    return rgb2num(this._rgb, mode);
  };
  _input.num = num2rgb;
  _guess_formats.push({
    p: 10,
    test: function (n) {
      if (arguments.length === 1 && type(n) === "number" && n >= 0 && n <= 0xFFFFFF) {
        return 'num';
      }
    }
  });
  css2rgb = function (css) {
    var aa, ab, hsl, i, m, o, rgb, w;
    css = css.toLowerCase();
    if (chroma.colors != null && chroma.colors[css]) {
      return hex2rgb(chroma.colors[css]);
    }
    if (m = css.match(/rgb\(\s*(\-?\d+),\s*(\-?\d+)\s*,\s*(\-?\d+)\s*\)/)) {
      rgb = m.slice(1, 4);
      for (i = o = 0; o <= 2; i = ++o) {
        rgb[i] = +rgb[i];
      }
      rgb[3] = 1;
    } else if (m = css.match(/rgba\(\s*(\-?\d+),\s*(\-?\d+)\s*,\s*(\-?\d+)\s*,\s*([01]|[01]?\.\d+)\)/)) {
      rgb = m.slice(1, 5);
      for (i = w = 0; w <= 3; i = ++w) {
        rgb[i] = +rgb[i];
      }
    } else if (m = css.match(/rgb\(\s*(\-?\d+(?:\.\d+)?)%,\s*(\-?\d+(?:\.\d+)?)%\s*,\s*(\-?\d+(?:\.\d+)?)%\s*\)/)) {
      rgb = m.slice(1, 4);
      for (i = aa = 0; aa <= 2; i = ++aa) {
        rgb[i] = round(rgb[i] * 2.55);
      }
      rgb[3] = 1;
    } else if (m = css.match(/rgba\(\s*(\-?\d+(?:\.\d+)?)%,\s*(\-?\d+(?:\.\d+)?)%\s*,\s*(\-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)/)) {
      rgb = m.slice(1, 5);
      for (i = ab = 0; ab <= 2; i = ++ab) {
        rgb[i] = round(rgb[i] * 2.55);
      }
      rgb[3] = +rgb[3];
    } else if (m = css.match(/hsl\(\s*(\-?\d+(?:\.\d+)?),\s*(\-?\d+(?:\.\d+)?)%\s*,\s*(\-?\d+(?:\.\d+)?)%\s*\)/)) {
      hsl = m.slice(1, 4);
      hsl[1] *= 0.01;
      hsl[2] *= 0.01;
      rgb = hsl2rgb(hsl);
      rgb[3] = 1;
    } else if (m = css.match(/hsla\(\s*(\-?\d+(?:\.\d+)?),\s*(\-?\d+(?:\.\d+)?)%\s*,\s*(\-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)/)) {
      hsl = m.slice(1, 4);
      hsl[1] *= 0.01;
      hsl[2] *= 0.01;
      rgb = hsl2rgb(hsl);
      rgb[3] = +m[4];
    }
    return rgb;
  };
  rgb2css = function (rgba) {
    var mode;
    mode = rgba[3] < 1 ? 'rgba' : 'rgb';
    if (mode === 'rgb') {
      return mode + '(' + rgba.slice(0, 3).map(round).join(',') + ')';
    } else if (mode === 'rgba') {
      return mode + '(' + rgba.slice(0, 3).map(round).join(',') + ',' + rgba[3] + ')';
    } else {}
  };
  rnd = function (a) {
    return round(a * 100) / 100;
  };
  hsl2css = function (hsl, alpha) {
    var mode;
    mode = alpha < 1 ? 'hsla' : 'hsl';
    hsl[0] = rnd(hsl[0] || 0);
    hsl[1] = rnd(hsl[1] * 100) + '%';
    hsl[2] = rnd(hsl[2] * 100) + '%';
    if (mode === 'hsla') {
      hsl[3] = alpha;
    }
    return mode + '(' + hsl.join(',') + ')';
  };
  _input.css = function (h) {
    return css2rgb(h);
  };
  chroma.css = function () {
    return function (func, args, ctor) {
      ctor.prototype = func.prototype;
      var child = new ctor(),
          result = func.apply(child, args);
      return Object(result) === result ? result : child;
    }(Color, slice.call(arguments).concat(['css']), function () {});
  };
  Color.prototype.css = function (mode) {
    if (mode == null) {
      mode = 'rgb';
    }
    if (mode.slice(0, 3) === 'rgb') {
      return rgb2css(this._rgb);
    } else if (mode.slice(0, 3) === 'hsl') {
      return hsl2css(this.hsl(), this.alpha());
    }
  };
  _input.named = function (name) {
    return hex2rgb(w3cx11[name]);
  };
  _guess_formats.push({
    p: 20,
    test: function (n) {
      if (arguments.length === 1 && w3cx11[n] != null) {
        return 'named';
      }
    }
  });
  Color.prototype.name = function (n) {
    var h, k;
    if (arguments.length) {
      if (w3cx11[n]) {
        this._rgb = hex2rgb(w3cx11[n]);
      }
      this._rgb[3] = 1;
      this;
    }
    h = this.hex();
    for (k in w3cx11) {
      if (h === w3cx11[k]) {
        return k;
      }
    }
    return h;
  };
  lch2lab = function () {
    var c, h, l, ref;
    ref = unpack(arguments), l = ref[0], c = ref[1], h = ref[2];
    h = h * DEG2RAD;
    return [l, cos(h) * c, sin(h) * c];
  };
  lch2rgb = function () {
    var L, a, args, b, c, g, h, l, r, ref, ref1;
    args = unpack(arguments);
    l = args[0], c = args[1], h = args[2];
    ref = lch2lab(l, c, h), L = ref[0], a = ref[1], b = ref[2];
    ref1 = lab2rgb(L, a, b), r = ref1[0], g = ref1[1], b = ref1[2];
    return [limit(r, 0, 255), limit(g, 0, 255), limit(b, 0, 255), args.length > 3 ? args[3] : 1];
  };
  lab2lch = function () {
    var a, b, c, h, l, ref;
    ref = unpack(arguments), l = ref[0], a = ref[1], b = ref[2];
    c = sqrt(a * a + b * b);
    h = (atan2(b, a) * RAD2DEG + 360) % 360;
    if (round(c * 10000) === 0) {
      h = Number.NaN;
    }
    return [l, c, h];
  };
  rgb2lch = function () {
    var a, b, g, l, r, ref, ref1;
    ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
    ref1 = rgb2lab(r, g, b), l = ref1[0], a = ref1[1], b = ref1[2];
    return lab2lch(l, a, b);
  };
  chroma.lch = function () {
    var args;
    args = unpack(arguments);
    return new Color(args, 'lch');
  };
  chroma.hcl = function () {
    var args;
    args = unpack(arguments);
    return new Color(args, 'hcl');
  };
  _input.lch = lch2rgb;
  _input.hcl = function () {
    var c, h, l, ref;
    ref = unpack(arguments), h = ref[0], c = ref[1], l = ref[2];
    return lch2rgb([l, c, h]);
  };
  Color.prototype.lch = function () {
    return rgb2lch(this._rgb);
  };
  Color.prototype.hcl = function () {
    return rgb2lch(this._rgb).reverse();
  };
  rgb2cmyk = function (mode) {
    var b, c, f, g, k, m, r, ref, y;
    if (mode == null) {
      mode = 'rgb';
    }
    ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
    r = r / 255;
    g = g / 255;
    b = b / 255;
    k = 1 - Math.max(r, Math.max(g, b));
    f = k < 1 ? 1 / (1 - k) : 0;
    c = (1 - r - k) * f;
    m = (1 - g - k) * f;
    y = (1 - b - k) * f;
    return [c, m, y, k];
  };
  cmyk2rgb = function () {
    var alpha, args, b, c, g, k, m, r, y;
    args = unpack(arguments);
    c = args[0], m = args[1], y = args[2], k = args[3];
    alpha = args.length > 4 ? args[4] : 1;
    if (k === 1) {
      return [0, 0, 0, alpha];
    }
    r = c >= 1 ? 0 : round(255 * (1 - c) * (1 - k));
    g = m >= 1 ? 0 : round(255 * (1 - m) * (1 - k));
    b = y >= 1 ? 0 : round(255 * (1 - y) * (1 - k));
    return [r, g, b, alpha];
  };
  _input.cmyk = function () {
    return cmyk2rgb(unpack(arguments));
  };
  chroma.cmyk = function () {
    return function (func, args, ctor) {
      ctor.prototype = func.prototype;
      var child = new ctor(),
          result = func.apply(child, args);
      return Object(result) === result ? result : child;
    }(Color, slice.call(arguments).concat(['cmyk']), function () {});
  };
  Color.prototype.cmyk = function () {
    return rgb2cmyk(this._rgb);
  };
  _input.gl = function () {
    var i, k, o, rgb, v;
    rgb = function () {
      var ref, results;
      ref = unpack(arguments);
      results = [];
      for (k in ref) {
        v = ref[k];
        results.push(v);
      }
      return results;
    }.apply(this, arguments);
    for (i = o = 0; o <= 2; i = ++o) {
      rgb[i] *= 255;
    }
    return rgb;
  };
  chroma.gl = function () {
    return function (func, args, ctor) {
      ctor.prototype = func.prototype;
      var child = new ctor(),
          result = func.apply(child, args);
      return Object(result) === result ? result : child;
    }(Color, slice.call(arguments).concat(['gl']), function () {});
  };
  Color.prototype.gl = function () {
    var rgb;
    rgb = this._rgb;
    return [rgb[0] / 255, rgb[1] / 255, rgb[2] / 255, rgb[3]];
  };
  rgb2luminance = function (r, g, b) {
    var ref;
    ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
    r = luminance_x(r);
    g = luminance_x(g);
    b = luminance_x(b);
    return 0.2126 * r + 0.7152 * g + 0.0722 * b;
  };
  luminance_x = function (x) {
    x /= 255;
    if (x <= 0.03928) {
      return x / 12.92;
    } else {
      return pow((x + 0.055) / 1.055, 2.4);
    }
  };
  _interpolators = [];
  interpolate = function (col1, col2, f, m) {
    var interpol, len, o, res;
    if (f == null) {
      f = 0.5;
    }
    if (m == null) {
      m = 'rgb';
    }
    if (type(col1) !== 'object') {
      col1 = chroma(col1);
    }
    if (type(col2) !== 'object') {
      col2 = chroma(col2);
    }
    for (o = 0, len = _interpolators.length; o < len; o++) {
      interpol = _interpolators[o];
      if (m === interpol[0]) {
        res = interpol[1](col1, col2, f, m);
        break;
      }
    }
    if (res == null) {
      throw "color mode " + m + " is not supported";
    }
    res.alpha(col1.alpha() + f * (col2.alpha() - col1.alpha()));
    return res;
  };
  chroma.interpolate = interpolate;
  Color.prototype.interpolate = function (col2, f, m) {
    return interpolate(this, col2, f, m);
  };
  chroma.mix = interpolate;
  Color.prototype.mix = Color.prototype.interpolate;
  interpolate_rgb = function (col1, col2, f, m) {
    var xyz0, xyz1;
    xyz0 = col1._rgb;
    xyz1 = col2._rgb;
    return new Color(xyz0[0] + f * (xyz1[0] - xyz0[0]), xyz0[1] + f * (xyz1[1] - xyz0[1]), xyz0[2] + f * (xyz1[2] - xyz0[2]), m);
  };
  _interpolators.push(['rgb', interpolate_rgb]);
  Color.prototype.luminance = function (lum, mode) {
    var cur_lum, eps, max_iter, test;
    if (mode == null) {
      mode = 'rgb';
    }
    if (!arguments.length) {
      return rgb2luminance(this._rgb);
    }
    if (lum === 0) {
      this._rgb = [0, 0, 0, this._rgb[3]];
    } else if (lum === 1) {
      this._rgb = [255, 255, 255, this._rgb[3]];
    } else {
      eps = 1e-7;
      max_iter = 20;
      test = function (l, h) {
        var lm, m;
        m = l.interpolate(h, 0.5, mode);
        lm = m.luminance();
        if (Math.abs(lum - lm) < eps || !max_iter--) {
          return m;
        }
        if (lm > lum) {
          return test(l, m);
        }
        return test(m, h);
      };
      cur_lum = rgb2luminance(this._rgb);
      this._rgb = (cur_lum > lum ? test(chroma('black'), this) : test(this, chroma('white'))).rgba();
    }
    return this;
  };
  temperature2rgb = function (kelvin) {
    var b, g, r, temp;
    temp = kelvin / 100;
    if (temp < 66) {
      r = 255;
      g = -155.25485562709179 - 0.44596950469579133 * (g = temp - 2) + 104.49216199393888 * log(g);
      b = temp < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (b = temp - 10) + 115.67994401066147 * log(b);
    } else {
      r = 351.97690566805693 + 0.114206453784165 * (r = temp - 55) - 40.25366309332127 * log(r);
      g = 325.4494125711974 + 0.07943456536662342 * (g = temp - 50) - 28.0852963507957 * log(g);
      b = 255;
    }
    return clip_rgb([r, g, b]);
  };
  rgb2temperature = function () {
    var b, eps, g, maxTemp, minTemp, r, ref, rgb, temp;
    ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
    minTemp = 1000;
    maxTemp = 40000;
    eps = 0.4;
    while (maxTemp - minTemp > eps) {
      temp = (maxTemp + minTemp) * 0.5;
      rgb = temperature2rgb(temp);
      if (rgb[2] / rgb[0] >= b / r) {
        maxTemp = temp;
      } else {
        minTemp = temp;
      }
    }
    return round(temp);
  };
  chroma.temperature = chroma.kelvin = function () {
    return function (func, args, ctor) {
      ctor.prototype = func.prototype;
      var child = new ctor(),
          result = func.apply(child, args);
      return Object(result) === result ? result : child;
    }(Color, slice.call(arguments).concat(['temperature']), function () {});
  };
  _input.temperature = _input.kelvin = _input.K = temperature2rgb;
  Color.prototype.temperature = function () {
    return rgb2temperature(this._rgb);
  };
  Color.prototype.kelvin = Color.prototype.temperature;
  chroma.contrast = function (a, b) {
    var l1, l2, ref, ref1;
    if ((ref = type(a)) === 'string' || ref === 'number') {
      a = new Color(a);
    }
    if ((ref1 = type(b)) === 'string' || ref1 === 'number') {
      b = new Color(b);
    }
    l1 = a.luminance();
    l2 = b.luminance();
    if (l1 > l2) {
      return (l1 + 0.05) / (l2 + 0.05);
    } else {
      return (l2 + 0.05) / (l1 + 0.05);
    }
  };
  Color.prototype.get = function (modechan) {
    var channel, i, me, mode, ref, src;
    me = this;
    ref = modechan.split('.'), mode = ref[0], channel = ref[1];
    src = me[mode]();
    if (channel) {
      i = mode.indexOf(channel);
      if (i > -1) {
        return src[i];
      } else {
        return console.warn('unknown channel ' + channel + ' in mode ' + mode);
      }
    } else {
      return src;
    }
  };
  Color.prototype.set = function (modechan, value) {
    var channel, i, me, mode, ref, src;
    me = this;
    ref = modechan.split('.'), mode = ref[0], channel = ref[1];
    if (channel) {
      src = me[mode]();
      i = mode.indexOf(channel);
      if (i > -1) {
        if (type(value) === 'string') {
          switch (value.charAt(0)) {
            case '+':
              src[i] += +value;
              break;
            case '-':
              src[i] += +value;
              break;
            case '*':
              src[i] *= +value.substr(1);
              break;
            case '/':
              src[i] /= +value.substr(1);
              break;
            default:
              src[i] = +value;
          }
        } else {
          src[i] = value;
        }
      } else {
        console.warn('unknown channel ' + channel + ' in mode ' + mode);
      }
    } else {
      src = value;
    }
    me._rgb = chroma(src, mode).alpha(me.alpha())._rgb;
    return me;
  };
  Color.prototype.darken = function (amount) {
    var lab, me;
    if (amount == null) {
      amount = 1;
    }
    me = this;
    lab = me.lab();
    lab[0] -= LAB_CONSTANTS.Kn * amount;
    return chroma.lab(lab).alpha(me.alpha());
  };
  Color.prototype.brighten = function (amount) {
    if (amount == null) {
      amount = 1;
    }
    return this.darken(-amount);
  };
  Color.prototype.darker = Color.prototype.darken;
  Color.prototype.brighter = Color.prototype.brighten;
  Color.prototype.saturate = function (amount) {
    var lch, me;
    if (amount == null) {
      amount = 1;
    }
    me = this;
    lch = me.lch();
    lch[1] += amount * LAB_CONSTANTS.Kn;
    if (lch[1] < 0) {
      lch[1] = 0;
    }
    return chroma.lch(lch).alpha(me.alpha());
  };
  Color.prototype.desaturate = function (amount) {
    if (amount == null) {
      amount = 1;
    }
    return this.saturate(-amount);
  };
  Color.prototype.premultiply = function () {
    var a, rgb;
    rgb = this.rgb();
    a = this.alpha();
    return chroma(rgb[0] * a, rgb[1] * a, rgb[2] * a, a);
  };
  blend = function (bottom, top, mode) {
    if (!blend[mode]) {
      throw 'unknown blend mode ' + mode;
    }
    return blend[mode](bottom, top);
  };
  blend_f = function (f) {
    return function (bottom, top) {
      var c0, c1;
      c0 = chroma(top).rgb();
      c1 = chroma(bottom).rgb();
      return chroma(f(c0, c1), 'rgb');
    };
  };
  each = function (f) {
    return function (c0, c1) {
      var i, o, out;
      out = [];
      for (i = o = 0; o <= 3; i = ++o) {
        out[i] = f(c0[i], c1[i]);
      }
      return out;
    };
  };
  normal = function (a, b) {
    return a;
  };
  multiply = function (a, b) {
    return a * b / 255;
  };
  darken = function (a, b) {
    if (a > b) {
      return b;
    } else {
      return a;
    }
  };
  lighten = function (a, b) {
    if (a > b) {
      return a;
    } else {
      return b;
    }
  };
  screen = function (a, b) {
    return 255 * (1 - (1 - a / 255) * (1 - b / 255));
  };
  overlay = function (a, b) {
    if (b < 128) {
      return 2 * a * b / 255;
    } else {
      return 255 * (1 - 2 * (1 - a / 255) * (1 - b / 255));
    }
  };
  burn = function (a, b) {
    return 255 * (1 - (1 - b / 255) / (a / 255));
  };
  dodge = function (a, b) {
    if (a === 255) {
      return 255;
    }
    a = 255 * (b / 255) / (1 - a / 255);
    if (a > 255) {
      return 255;
    } else {
      return a;
    }
  };
  blend.normal = blend_f(each(normal));
  blend.multiply = blend_f(each(multiply));
  blend.screen = blend_f(each(screen));
  blend.overlay = blend_f(each(overlay));
  blend.darken = blend_f(each(darken));
  blend.lighten = blend_f(each(lighten));
  blend.dodge = blend_f(each(dodge));
  blend.burn = blend_f(each(burn));
  chroma.blend = blend;
  chroma.analyze = function (data) {
    var len, o, r, val;
    r = {
      min: Number.MAX_VALUE,
      max: Number.MAX_VALUE * -1,
      sum: 0,
      values: [],
      count: 0
    };
    for (o = 0, len = data.length; o < len; o++) {
      val = data[o];
      if (val != null && !isNaN(val)) {
        r.values.push(val);
        r.sum += val;
        if (val < r.min) {
          r.min = val;
        }
        if (val > r.max) {
          r.max = val;
        }
        r.count += 1;
      }
    }
    r.domain = [r.min, r.max];
    r.limits = function (mode, num) {
      return chroma.limits(r, mode, num);
    };
    return r;
  };
  chroma.scale = function (colors, positions) {
    var _classes, _colorCache, _colors, _correctLightness, _domain, _fixed, _max, _min, _mode, _nacol, _out, _padding, _pos, _spread, classifyValue, f, getClass, getColor, resetCache, setColors, tmap;
    _mode = 'rgb';
    _nacol = chroma('#ccc');
    _spread = 0;
    _fixed = false;
    _domain = [0, 1];
    _pos = [];
    _padding = [0, 0];
    _classes = false;
    _colors = [];
    _out = false;
    _min = 0;
    _max = 1;
    _correctLightness = false;
    _colorCache = {};
    setColors = function (colors) {
      var c, col, o, ref, ref1, ref2, w;
      if (colors == null) {
        colors = ['#fff', '#000'];
      }
      if (colors != null && type(colors) === 'string' && ((ref = chroma.brewer) != null ? ref[colors] : void 0) != null) {
        colors = chroma.brewer[colors];
      }
      if (type(colors) === 'array') {
        colors = colors.slice(0);
        for (c = o = 0, ref1 = colors.length - 1; 0 <= ref1 ? o <= ref1 : o >= ref1; c = 0 <= ref1 ? ++o : --o) {
          col = colors[c];
          if (type(col) === "string") {
            colors[c] = chroma(col);
          }
        }
        _pos.length = 0;
        for (c = w = 0, ref2 = colors.length - 1; 0 <= ref2 ? w <= ref2 : w >= ref2; c = 0 <= ref2 ? ++w : --w) {
          _pos.push(c / (colors.length - 1));
        }
      }
      resetCache();
      return _colors = colors;
    };
    getClass = function (value) {
      var i, n;
      if (_classes != null) {
        n = _classes.length - 1;
        i = 0;
        while (i < n && value >= _classes[i]) {
          i++;
        }
        return i - 1;
      }
      return 0;
    };
    tmap = function (t) {
      return t;
    };
    classifyValue = function (value) {
      var i, maxc, minc, n, val;
      val = value;
      if (_classes.length > 2) {
        n = _classes.length - 1;
        i = getClass(value);
        minc = _classes[0] + (_classes[1] - _classes[0]) * (0 + _spread * 0.5);
        maxc = _classes[n - 1] + (_classes[n] - _classes[n - 1]) * (1 - _spread * 0.5);
        val = _min + (_classes[i] + (_classes[i + 1] - _classes[i]) * 0.5 - minc) / (maxc - minc) * (_max - _min);
      }
      return val;
    };
    getColor = function (val, bypassMap) {
      var c, col, i, k, o, p, ref, t;
      if (bypassMap == null) {
        bypassMap = false;
      }
      if (isNaN(val)) {
        return _nacol;
      }
      if (!bypassMap) {
        if (_classes && _classes.length > 2) {
          c = getClass(val);
          t = c / (_classes.length - 2);
          t = _padding[0] + t * (1 - _padding[0] - _padding[1]);
        } else if (_max !== _min) {
          t = (val - _min) / (_max - _min);
          t = _padding[0] + t * (1 - _padding[0] - _padding[1]);
          t = Math.min(1, Math.max(0, t));
        } else {
          t = 1;
        }
      } else {
        t = val;
      }
      if (!bypassMap) {
        t = tmap(t);
      }
      k = Math.floor(t * 10000);
      if (_colorCache[k]) {
        col = _colorCache[k];
      } else {
        if (type(_colors) === 'array') {
          for (i = o = 0, ref = _pos.length - 1; 0 <= ref ? o <= ref : o >= ref; i = 0 <= ref ? ++o : --o) {
            p = _pos[i];
            if (t <= p) {
              col = _colors[i];
              break;
            }
            if (t >= p && i === _pos.length - 1) {
              col = _colors[i];
              break;
            }
            if (t > p && t < _pos[i + 1]) {
              t = (t - p) / (_pos[i + 1] - p);
              col = chroma.interpolate(_colors[i], _colors[i + 1], t, _mode);
              break;
            }
          }
        } else if (type(_colors) === 'function') {
          col = _colors(t);
        }
        _colorCache[k] = col;
      }
      return col;
    };
    resetCache = function () {
      return _colorCache = {};
    };
    setColors(colors);
    f = function (v) {
      var c;
      c = chroma(getColor(v));
      if (_out && c[_out]) {
        return c[_out]();
      } else {
        return c;
      }
    };
    f.classes = function (classes) {
      var d;
      if (classes != null) {
        if (type(classes) === 'array') {
          _classes = classes;
          _domain = [classes[0], classes[classes.length - 1]];
        } else {
          d = chroma.analyze(_domain);
          if (classes === 0) {
            _classes = [d.min, d.max];
          } else {
            _classes = chroma.limits(d, 'e', classes);
          }
        }
        return f;
      }
      return _classes;
    };
    f.domain = function (domain) {
      var c, d, k, len, o, ref, w;
      if (!arguments.length) {
        return _domain;
      }
      _min = domain[0];
      _max = domain[domain.length - 1];
      _pos = [];
      k = _colors.length;
      if (domain.length === k && _min !== _max) {
        for (o = 0, len = domain.length; o < len; o++) {
          d = domain[o];
          _pos.push((d - _min) / (_max - _min));
        }
      } else {
        for (c = w = 0, ref = k - 1; 0 <= ref ? w <= ref : w >= ref; c = 0 <= ref ? ++w : --w) {
          _pos.push(c / (k - 1));
        }
      }
      _domain = [_min, _max];
      return f;
    };
    f.mode = function (_m) {
      if (!arguments.length) {
        return _mode;
      }
      _mode = _m;
      resetCache();
      return f;
    };
    f.range = function (colors, _pos) {
      setColors(colors, _pos);
      return f;
    };
    f.out = function (_o) {
      _out = _o;
      return f;
    };
    f.spread = function (val) {
      if (!arguments.length) {
        return _spread;
      }
      _spread = val;
      return f;
    };
    f.correctLightness = function (v) {
      if (v == null) {
        v = true;
      }
      _correctLightness = v;
      resetCache();
      if (_correctLightness) {
        tmap = function (t) {
          var L0, L1, L_actual, L_diff, L_ideal, max_iter, pol, t0, t1;
          L0 = getColor(0, true).lab()[0];
          L1 = getColor(1, true).lab()[0];
          pol = L0 > L1;
          L_actual = getColor(t, true).lab()[0];
          L_ideal = L0 + (L1 - L0) * t;
          L_diff = L_actual - L_ideal;
          t0 = 0;
          t1 = 1;
          max_iter = 20;
          while (Math.abs(L_diff) > 1e-2 && max_iter-- > 0) {
            (function () {
              if (pol) {
                L_diff *= -1;
              }
              if (L_diff < 0) {
                t0 = t;
                t += (t1 - t) * 0.5;
              } else {
                t1 = t;
                t += (t0 - t) * 0.5;
              }
              L_actual = getColor(t, true).lab()[0];
              return L_diff = L_actual - L_ideal;
            })();
          }
          return t;
        };
      } else {
        tmap = function (t) {
          return t;
        };
      }
      return f;
    };
    f.padding = function (p) {
      if (p != null) {
        if (type(p) === 'number') {
          p = [p, p];
        }
        _padding = p;
        return f;
      } else {
        return _padding;
      }
    };
    f.colors = function () {
      var dd, dm, i, numColors, o, out, ref, results, samples, w;
      numColors = 0;
      out = 'hex';
      if (arguments.length === 0) {
        return _colors.map(function (c) {
          return c[out]();
        });
      }
      if (arguments.length === 1) {
        if (type(arguments[0]) === 'string') {
          out = arguments[0];
        } else {
          numColors = arguments[0];
        }
      }
      if (arguments.length === 2) {
        numColors = arguments[0], out = arguments[1];
      }
      if (numColors) {
        dm = _domain[0];
        dd = _domain[1] - dm;
        return function () {
          results = [];
          for (var o = 0; 0 <= numColors ? o < numColors : o > numColors; 0 <= numColors ? o++ : o--) {
            results.push(o);
          }
          return results;
        }.apply(this).map(function (i) {
          return f(dm + i / (numColors - 1) * dd)[out]();
        });
      }
      colors = [];
      samples = [];
      if (_classes && _classes.length > 2) {
        for (i = w = 1, ref = _classes.length; 1 <= ref ? w < ref : w > ref; i = 1 <= ref ? ++w : --w) {
          samples.push((_classes[i - 1] + _classes[i]) * 0.5);
        }
      } else {
        samples = _domain;
      }
      return samples.map(function (v) {
        return f(v)[out]();
      });
    };
    return f;
  };
  if (chroma.scales == null) {
    chroma.scales = {};
  }
  chroma.scales.cool = function () {
    return chroma.scale([chroma.hsl(180, 1, .9), chroma.hsl(250, .7, .4)]);
  };
  chroma.scales.hot = function () {
    return chroma.scale(['#000', '#f00', '#ff0', '#fff'], [0, .25, .75, 1]).mode('rgb');
  };
  chroma.analyze = function (data, key, filter) {
    var add, k, len, o, r, val, visit;
    r = {
      min: Number.MAX_VALUE,
      max: Number.MAX_VALUE * -1,
      sum: 0,
      values: [],
      count: 0
    };
    if (filter == null) {
      filter = function () {
        return true;
      };
    }
    add = function (val) {
      if (val != null && !isNaN(val)) {
        r.values.push(val);
        r.sum += val;
        if (val < r.min) {
          r.min = val;
        }
        if (val > r.max) {
          r.max = val;
        }
        r.count += 1;
      }
    };
    visit = function (val, k) {
      if (filter(val, k)) {
        if (key != null && type(key) === 'function') {
          return add(key(val));
        } else if (key != null && type(key) === 'string' || type(key) === 'number') {
          return add(val[key]);
        } else {
          return add(val);
        }
      }
    };
    if (type(data) === 'array') {
      for (o = 0, len = data.length; o < len; o++) {
        val = data[o];
        visit(val);
      }
    } else {
      for (k in data) {
        val = data[k];
        visit(val, k);
      }
    }
    r.domain = [r.min, r.max];
    r.limits = function (mode, num) {
      return chroma.limits(r, mode, num);
    };
    return r;
  };
  chroma.limits = function (data, mode, num) {
    var aa, ab, ac, ad, ae, af, ag, ah, ai, aj, ak, al, am, assignments, best, centroids, cluster, clusterSizes, dist, i, j, kClusters, limits, max_log, min, min_log, mindist, n, nb_iters, newCentroids, o, p, pb, pr, ref, ref1, ref10, ref11, ref12, ref13, ref14, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, repeat, sum, tmpKMeansBreaks, value, values, w;
    if (mode == null) {
      mode = 'equal';
    }
    if (num == null) {
      num = 7;
    }
    if (type(data) === 'array') {
      data = chroma.analyze(data);
    }
    min = data.min;
    max = data.max;
    sum = data.sum;
    values = data.values.sort(function (a, b) {
      return a - b;
    });
    limits = [];
    if (mode.substr(0, 1) === 'c') {
      limits.push(min);
      limits.push(max);
    }
    if (mode.substr(0, 1) === 'e') {
      limits.push(min);
      for (i = o = 1, ref = num - 1; 1 <= ref ? o <= ref : o >= ref; i = 1 <= ref ? ++o : --o) {
        limits.push(min + i / num * (max - min));
      }
      limits.push(max);
    } else if (mode.substr(0, 1) === 'l') {
      if (min <= 0) {
        throw 'Logarithmic scales are only possible for values > 0';
      }
      min_log = Math.LOG10E * log(min);
      max_log = Math.LOG10E * log(max);
      limits.push(min);
      for (i = w = 1, ref1 = num - 1; 1 <= ref1 ? w <= ref1 : w >= ref1; i = 1 <= ref1 ? ++w : --w) {
        limits.push(pow(10, min_log + i / num * (max_log - min_log)));
      }
      limits.push(max);
    } else if (mode.substr(0, 1) === 'q') {
      limits.push(min);
      for (i = aa = 1, ref2 = num - 1; 1 <= ref2 ? aa <= ref2 : aa >= ref2; i = 1 <= ref2 ? ++aa : --aa) {
        p = values.length * i / num;
        pb = floor(p);
        if (pb === p) {
          limits.push(values[pb]);
        } else {
          pr = p - pb;
          limits.push(values[pb] * pr + values[pb + 1] * (1 - pr));
        }
      }
      limits.push(max);
    } else if (mode.substr(0, 1) === 'k') {
      n = values.length;
      assignments = new Array(n);
      clusterSizes = new Array(num);
      repeat = true;
      nb_iters = 0;
      centroids = null;
      centroids = [];
      centroids.push(min);
      for (i = ab = 1, ref3 = num - 1; 1 <= ref3 ? ab <= ref3 : ab >= ref3; i = 1 <= ref3 ? ++ab : --ab) {
        centroids.push(min + i / num * (max - min));
      }
      centroids.push(max);
      while (repeat) {
        for (j = ac = 0, ref4 = num - 1; 0 <= ref4 ? ac <= ref4 : ac >= ref4; j = 0 <= ref4 ? ++ac : --ac) {
          clusterSizes[j] = 0;
        }
        for (i = ad = 0, ref5 = n - 1; 0 <= ref5 ? ad <= ref5 : ad >= ref5; i = 0 <= ref5 ? ++ad : --ad) {
          value = values[i];
          mindist = Number.MAX_VALUE;
          for (j = ae = 0, ref6 = num - 1; 0 <= ref6 ? ae <= ref6 : ae >= ref6; j = 0 <= ref6 ? ++ae : --ae) {
            dist = abs(centroids[j] - value);
            if (dist < mindist) {
              mindist = dist;
              best = j;
            }
          }
          clusterSizes[best]++;
          assignments[i] = best;
        }
        newCentroids = new Array(num);
        for (j = af = 0, ref7 = num - 1; 0 <= ref7 ? af <= ref7 : af >= ref7; j = 0 <= ref7 ? ++af : --af) {
          newCentroids[j] = null;
        }
        for (i = ag = 0, ref8 = n - 1; 0 <= ref8 ? ag <= ref8 : ag >= ref8; i = 0 <= ref8 ? ++ag : --ag) {
          cluster = assignments[i];
          if (newCentroids[cluster] === null) {
            newCentroids[cluster] = values[i];
          } else {
            newCentroids[cluster] += values[i];
          }
        }
        for (j = ah = 0, ref9 = num - 1; 0 <= ref9 ? ah <= ref9 : ah >= ref9; j = 0 <= ref9 ? ++ah : --ah) {
          newCentroids[j] *= 1 / clusterSizes[j];
        }
        repeat = false;
        for (j = ai = 0, ref10 = num - 1; 0 <= ref10 ? ai <= ref10 : ai >= ref10; j = 0 <= ref10 ? ++ai : --ai) {
          if (newCentroids[j] !== centroids[i]) {
            repeat = true;
            break;
          }
        }
        centroids = newCentroids;
        nb_iters++;
        if (nb_iters > 200) {
          repeat = false;
        }
      }
      kClusters = {};
      for (j = aj = 0, ref11 = num - 1; 0 <= ref11 ? aj <= ref11 : aj >= ref11; j = 0 <= ref11 ? ++aj : --aj) {
        kClusters[j] = [];
      }
      for (i = ak = 0, ref12 = n - 1; 0 <= ref12 ? ak <= ref12 : ak >= ref12; i = 0 <= ref12 ? ++ak : --ak) {
        cluster = assignments[i];
        kClusters[cluster].push(values[i]);
      }
      tmpKMeansBreaks = [];
      for (j = al = 0, ref13 = num - 1; 0 <= ref13 ? al <= ref13 : al >= ref13; j = 0 <= ref13 ? ++al : --al) {
        tmpKMeansBreaks.push(kClusters[j][0]);
        tmpKMeansBreaks.push(kClusters[j][kClusters[j].length - 1]);
      }
      tmpKMeansBreaks = tmpKMeansBreaks.sort(function (a, b) {
        return a - b;
      });
      limits.push(tmpKMeansBreaks[0]);
      for (i = am = 1, ref14 = tmpKMeansBreaks.length - 1; am <= ref14; i = am += 2) {
        if (!isNaN(tmpKMeansBreaks[i])) {
          limits.push(tmpKMeansBreaks[i]);
        }
      }
    }
    return limits;
  };
  hsi2rgb = function (h, s, i) {
    var args, b, g, r;
    args = unpack(arguments);
    h = args[0], s = args[1], i = args[2];
    h /= 360;
    if (h < 1 / 3) {
      b = (1 - s) / 3;
      r = (1 + s * cos(TWOPI * h) / cos(PITHIRD - TWOPI * h)) / 3;
      g = 1 - (b + r);
    } else if (h < 2 / 3) {
      h -= 1 / 3;
      r = (1 - s) / 3;
      g = (1 + s * cos(TWOPI * h) / cos(PITHIRD - TWOPI * h)) / 3;
      b = 1 - (r + g);
    } else {
      h -= 2 / 3;
      g = (1 - s) / 3;
      b = (1 + s * cos(TWOPI * h) / cos(PITHIRD - TWOPI * h)) / 3;
      r = 1 - (g + b);
    }
    r = limit(i * r * 3);
    g = limit(i * g * 3);
    b = limit(i * b * 3);
    return [r * 255, g * 255, b * 255, args.length > 3 ? args[3] : 1];
  };
  rgb2hsi = function () {
    var b, g, h, i, min, r, ref, s;
    ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
    TWOPI = Math.PI * 2;
    r /= 255;
    g /= 255;
    b /= 255;
    min = Math.min(r, g, b);
    i = (r + g + b) / 3;
    s = 1 - min / i;
    if (s === 0) {
      h = 0;
    } else {
      h = (r - g + (r - b)) / 2;
      h /= Math.sqrt((r - g) * (r - g) + (r - b) * (g - b));
      h = Math.acos(h);
      if (b > g) {
        h = TWOPI - h;
      }
      h /= TWOPI;
    }
    return [h * 360, s, i];
  };
  chroma.hsi = function () {
    return function (func, args, ctor) {
      ctor.prototype = func.prototype;
      var child = new ctor(),
          result = func.apply(child, args);
      return Object(result) === result ? result : child;
    }(Color, slice.call(arguments).concat(['hsi']), function () {});
  };
  _input.hsi = hsi2rgb;
  Color.prototype.hsi = function () {
    return rgb2hsi(this._rgb);
  };
  interpolate_hsx = function (col1, col2, f, m) {
    var dh, hue, hue0, hue1, lbv, lbv0, lbv1, res, sat, sat0, sat1, xyz0, xyz1;
    if (m === 'hsl') {
      xyz0 = col1.hsl();
      xyz1 = col2.hsl();
    } else if (m === 'hsv') {
      xyz0 = col1.hsv();
      xyz1 = col2.hsv();
    } else if (m === 'hsi') {
      xyz0 = col1.hsi();
      xyz1 = col2.hsi();
    } else if (m === 'lch' || m === 'hcl') {
      m = 'hcl';
      xyz0 = col1.hcl();
      xyz1 = col2.hcl();
    }
    if (m.substr(0, 1) === 'h') {
      hue0 = xyz0[0], sat0 = xyz0[1], lbv0 = xyz0[2];
      hue1 = xyz1[0], sat1 = xyz1[1], lbv1 = xyz1[2];
    }
    if (!isNaN(hue0) && !isNaN(hue1)) {
      if (hue1 > hue0 && hue1 - hue0 > 180) {
        dh = hue1 - (hue0 + 360);
      } else if (hue1 < hue0 && hue0 - hue1 > 180) {
        dh = hue1 + 360 - hue0;
      } else {
        dh = hue1 - hue0;
      }
      hue = hue0 + f * dh;
    } else if (!isNaN(hue0)) {
      hue = hue0;
      if ((lbv1 === 1 || lbv1 === 0) && m !== 'hsv') {
        sat = sat0;
      }
    } else if (!isNaN(hue1)) {
      hue = hue1;
      if ((lbv0 === 1 || lbv0 === 0) && m !== 'hsv') {
        sat = sat1;
      }
    } else {
      hue = Number.NaN;
    }
    if (sat == null) {
      sat = sat0 + f * (sat1 - sat0);
    }
    lbv = lbv0 + f * (lbv1 - lbv0);
    return res = chroma[m](hue, sat, lbv);
  };
  _interpolators = _interpolators.concat(function () {
    var len, o, ref, results;
    ref = ['hsv', 'hsl', 'hsi', 'hcl', 'lch'];
    results = [];
    for (o = 0, len = ref.length; o < len; o++) {
      m = ref[o];
      results.push([m, interpolate_hsx]);
    }
    return results;
  }());
  interpolate_num = function (col1, col2, f, m) {
    var n1, n2;
    n1 = col1.num();
    n2 = col2.num();
    return chroma.num(n1 + (n2 - n1) * f, 'num');
  };
  _interpolators.push(['num', interpolate_num]);
  interpolate_lab = function (col1, col2, f, m) {
    var res, xyz0, xyz1;
    xyz0 = col1.lab();
    xyz1 = col2.lab();
    return res = new Color(xyz0[0] + f * (xyz1[0] - xyz0[0]), xyz0[1] + f * (xyz1[1] - xyz0[1]), xyz0[2] + f * (xyz1[2] - xyz0[2]), m);
  };
  _interpolators.push(['lab', interpolate_lab]);
}).call(commonjsGlobal);
});

var runtime = createCommonjsModule(function (module, exports) {
'use strict';
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SuperCall = SuperCall;
exports.CFunc = CFunc;
const objc_super_typeEncoding = '{objc_super="receiver"@"super_class"#}';
function SuperCall(selector, argTypes, returnType) {
  const func = CFunc("objc_msgSendSuper", [{ type: '^' + objc_super_typeEncoding }, { type: ":" }, ...argTypes], returnType);
  return function (...args) {
    const struct = make_objc_super(this, this.superclass());
    const structPtr = MOPointer.alloc().initWithValue_(struct);
    return func(structPtr, selector, ...args);
  };
}
function makeStruct(def) {
  if (typeof def !== 'object' || Object.keys(def).length == 0) {
    return def;
  }
  const name = Object.keys(def)[0];
  const values = def[name];
  const structure = MOStruct.structureWithName_memberNames_runtime(name, Object.keys(values), Mocha.sharedRuntime());
  Object.keys(values).map(member => {
    structure[member] = makeStruct(values[member]);
  });
  return structure;
}
function make_objc_super(self, cls) {
  return makeStruct({
    objc_super: {
      receiver: self,
      super_class: cls
    }
  });
}
function setKeys(o, d) {
  const funcDict = NSMutableDictionary.dictionary();
  funcDict.o = o;
  Object.keys(d).map(k => funcDict.setValue_forKeyPath(d[k], "o." + k));
}
function CFunc(name, args, retVal) {
  function makeArgument(a) {
    if (!a) return null;
    const arg = MOBridgeSupportArgument.alloc().init();
    setKeys(arg, {
      type64: a.type
    });
    return arg;
  }
  const func = MOBridgeSupportFunction.alloc().init();
  setKeys(func, {
    name: name,
    arguments: args.map(makeArgument),
    returnValue: makeArgument(retVal)
  });
  return func;
}
function addStructToBridgeSupport(key, structDef) {
  const symbols = MOBridgeSupportController.sharedController().valueForKey('symbols');
  if (!symbols) throw Error("Something has changed within bridge support so we can't add our definitions");
  if (symbols[key] !== null) return;
  const def = MOBridgeSupportStruct.alloc().init();
  setKeys(def, {
    name: key,
    type: structDef.type
  });
  symbols[key] = def;
}
const object_getInstanceVariable = exports.object_getInstanceVariable = CFunc("object_getInstanceVariable", [{ type: "@" }, { type: '*' }, { type: "^@" }], { type: "^{objc_ivar=}" });
const object_setInstanceVariable = exports.object_setInstanceVariable = CFunc("object_setInstanceVariable", [{ type: "@" }, { type: '*' }, { type: "@" }], { type: "^{objc_ivar=}" });
addStructToBridgeSupport('objc_super', { type: objc_super_typeEncoding });
});

var index$13 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SuperCall = undefined;
exports.default = ObjCClass;
var _runtime = runtime;
exports.SuperCall = _runtime.SuperCall;
const SuperInit = (0, _runtime.SuperCall)(NSStringFromSelector("init"), [], { type: "@" });
function ObjCClass(defn) {
  const superclass = defn.superclass || NSObject;
  const className = (defn.className || defn.classname || "ObjCClass") + NSUUID.UUID().UUIDString();
  const reserved = new Set(['className', 'classname', 'superclass']);
  var cls = MOClassDescription.allocateDescriptionForClassWithName_superclass_(className, superclass);
  const ivars = [];
  for (var key in defn) {
    const v = defn[key];
    if (typeof v == 'function' && key !== 'init') {
      var selector = NSSelectorFromString(key);
      cls.addInstanceMethodWithSelector_function_(selector, v);
    } else if (!reserved.has(key)) {
      ivars.push(key);
      cls.addInstanceVariableWithName_typeEncoding(key, "@");
    }
  }
  cls.addInstanceMethodWithSelector_function_(NSSelectorFromString('init'), function () {
    const self = SuperInit.call(this);
    ivars.map(name => {
      Object.defineProperty(self, name, {
        get() {
          return getIvar(self, name);
        },
        set(v) {
          (0, _runtime.object_setInstanceVariable)(self, name, v);
        }
      });
      self[name] = defn[name];
    });
    if (typeof defn.init == 'function') defn.init.call(this);
    return self;
  });
  return cls.registerClass();
}
function getIvar(obj, name) {
  const retPtr = MOPointer.new();
  (0, _runtime.object_getInstanceVariable)(obj, name, retPtr);
  return retPtr.value().retain().autorelease();
}
});

var _ObjCClass = index$13;
const ObjCClass = _ObjCClass.default;
function response(httpResponse, data) {
  const keys = [];
  const all = [];
  const headers = {};
  let header;
  for (var i = 0; i < httpResponse.allHeaderFields().allKeys().length; i++) {
    const key = httpResponse.allHeaderFields().allKeys()[i].toLowerCase();
    const value = httpResponse.allHeaderFields()[key];
    keys.push(key);
    all.push([key, value]);
    header = headers[key];
    headers[key] = header ? `${header},${value}` : value;
  }
  return {
    ok: (httpResponse.statusCode() / 200 | 0) == 1,
    status: httpResponse.statusCode(),
    statusText: NSHTTPURLResponse.localizedStringForStatusCode(httpResponse.statusCode()),
    url: httpResponse.URL(),
    clone: response.bind(this, httpResponse, data),
    text() {
      return new Promise((resolve, reject) => {
        const str = NSString.alloc().initWithData_encoding(data, NSASCIIStringEncoding);
        if (str) {
          resolve(str);
        } else {
          reject(new Error("Couldn't parse body"));
        }
      });
    },
    json() {
      return new Promise((resolve, reject) => {
        const str = NSString.alloc().initWithData_encoding(data, NSUTF8StringEncoding);
        if (str) {
          const obj = JSON.parse(str);
          resolve(obj);
        } else {
          reject(new Error("Could not parse JSON because it is not valid UTF-8 data."));
        }
      });
    },
    xml() {
      return Promise.reject('not implemented yet');
    },
    blob() {
      return Promise.resolve(data);
    },
    headers: {
      keys: () => keys,
      entries: () => all,
      get: n => headers[n.toLowerCase()],
      has: n => n.toLowerCase() in headers
    }
  };
}
let DelegateClass;
function fetch(urlString, options) {
  options = options || {};
  coscript.setShouldKeepAround(true);
  return new Promise((resolve, reject) => {
    const url = NSURL.alloc().initWithString_(urlString);
    const request = NSMutableURLRequest.requestWithURL_(url);
    request.setHTTPMethod(options.method || 'GET');
    for (let i in options.headers) {
      request.setValue_forHTTPHeaderField(options.headers[i], i);
    }
    if (options.body) {
      request.setHTTPBody(data);
    }
    if (!DelegateClass) {
      DelegateClass = ObjCClass({
        classname: 'FetchPolyfillDelegate',
        data: NSMutableData.alloc().init(),
        httpResponse: null,
        callbacks: null,
        'connectionDidFinishLoading:'(connection) {
          coscript.setShouldKeepAround(false);
          return this.callbacks.resolve(response(this.httpResponse, this.data));
        },
        'connection:didReceiveResponse:'(connection, httpResponse) {
          this.httpResponse = httpResponse;
        },
        'connection:didFailWithError:'(connection, error) {
          coscript.setShouldKeepAround(false);
          const reject = this.callbacks.reject;
          return reject(error);
        },
        'connection:didReceiveData:'(connection, data) {
          this.data.appendData(data);
        }
      });
    }
    const connectionDelegate = DelegateClass.new();
    connectionDelegate.callbacks = NSDictionary.dictionaryWithDictionary({
      resolve,
      reject
    });
    NSURLConnection.alloc().initWithRequest_delegate(request, connectionDelegate);
  });
}
const commonjsGlobal$1 = typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : commonjsGlobal;
commonjsGlobal$1.fetch = commonjsGlobal$1.fetch || fetch;
var index$12 = fetch;

const textColor = hex => {
  const vsWhite = chroma.contrast(hex, 'white');
  if (vsWhite > 4) {
    return '#FFF';
  }
  return chroma(hex).darken(3).hex();
};
const Swatch = ({ name, hex }) => react.createElement(
  index_7,
  {
    name: `Swatch ${name}`,
    style: {
      height: 96,
      width: 96,
      marginRight: 8,
      marginBottom: 8,
      backgroundColor: hex,
      padding: 8
    }
  },
  react.createElement(
    index_6,
    {
      name: 'Swatch Name',
      style: { color: textColor(hex), fontWeight: 'bold' }
    },
    name
  ),
  react.createElement(
    index_6,
    {
      name: 'Swatch Hex',
      style: { color: textColor(hex) }
    },
    hex
  )
);
const Color = {
  hex: react.PropTypes.string.isRequired,
  name: react.PropTypes.string.isRequired
};
Swatch.propTypes = Color;
const Document = ({ colors }) => react.createElement(
  index_7,
  {
    style: {
      flexDirection: 'row',
      flexWrap: 'wrap',
      width: (96 + 8) * 4
    }
  },
  Object.keys(colors).map(color => react.createElement(Swatch, {
    name: color,
    hex: colors[color],
    key: color
  }))
);
Document.propTypes = {
  colors: react.PropTypes.objectOf(react.PropTypes.string.isRequired).isRequired
};
var onRun = function (context) {
  {
    const doc = context.document;
    doc.showMessage("Loading JSON from github...");
    const URL = "https://gist.githubusercontent.com/darknoon/b096646539f535ad205f6f845c6f0803/raw/efe8741c3c9fcde021ca05cf1c879ca99533ffe3/colors.json";
    const colorList = index$12(URL).then(r => r.json()).then(colorList => {
      index_1(react.createElement(Document, { colors: colorList }), context);
      doc.hideMessage();
    }).catch(err => {
      doc.showMessage("" + err);log("ERROR:" + err);coscript.setShouldKeepAround(false);
    });
  }
};
